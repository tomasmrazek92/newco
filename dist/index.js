"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // bin/live-reload.js
  new EventSource(`${"http://localhost:3000"}/esbuild`).addEventListener("change", () => location.reload());

  // src/utils/gsapAnimate.js
  function gsapAnimate(element, isMobile) {
    const $el = $(element);
    const tl = gsap.timeline();
    if (isMobile)
      return;
    if ($el.is('[data-animation="heading"]')) {
      const type = $el.attr("data-split-type") || "word";
      const typeSplit = new SplitType($el, {
        types: "words, chars",
        tagName: "span"
      });
      tl.from($el.find(`.${type}`), {
        y: "2rem",
        opacity: 0,
        duration: 1,
        ease: "power3.out",
        stagger: 0.1
      });
      tl.to(
        [$el, $el.find(`.${type}`)],
        {
          visibility: "visible"
        },
        "<"
      );
    }
    if ($el.is('[data-animation="item"]')) {
      const stagger = $el.attr("data-stagger") || 0.2;
      tl.fromTo(
        $el,
        { y: "2rem", opacity: 0 },
        { y: "0rem", opacity: 1, visibility: "visible", stagger }
      );
    }
    if ($el.is('[data-animation="stagger"]')) {
      const staggerItems = $el.find('[data-animation="stagger-item"]');
      const stagger = $el.attr("data-stagger") || 0.1;
      gsap.set([$el, staggerItems], {
        visibility: "visible",
        immediateRender: true
      });
      tl.from(staggerItems, {
        y: "1rem",
        opacity: 0,
        stagger,
        clearProps: "visibility",
        overwrite: "auto",
        force3D: true
      });
    }
    if ($el.is('[data-animation="writer"]')) {
      const scoreText = $el.text();
      $el.text("");
      tl.to($elt, {
        duration: 2,
        text: scoreText,
        ease: "none"
      });
    }
    return tl;
  }

  // src/Animations.js
  var Sections = class {
    currentLink;
    isMobile;
    $content;
    intObs;
    constructor() {
      this.$content = $(".page-main");
      this.intObs = new IntersectionObserver(this.onIntersection.bind(this), { threshold: 0.2 });
    }
    init() {
      $("[data-animation]").each((i, elm) => {
        const $el = $(elm);
        const isHero = $el.closest(".section.cc-hero").length;
        if (!isHero) {
          this.intObs.observe(elm);
        }
      });
    }
    onIntersection(entries, observer) {
      entries.forEach((entry) => {
        const elm = entry.target;
        if (entry.isIntersecting && !elm.hasAttribute("animated")) {
          elm.setAttribute("animated", "");
          observer.unobserve(elm);
          gsapAnimate(elm, this.isMobile);
        }
      });
    }
  };

  // src/utils/globalFunctions.js
  var windowWidth = window.innerWidth;
  var uniqueIdCounters = {};
  var createResponsiveSwiper = (componentSelector, swiperSelector, classSelector, options, mode) => {
    let elements = $(componentSelector).add(swiperSelector);
    if (elements.length < 2)
      return;
    uniqueIdCounters[classSelector] = 0;
    uniqueIdCounters[classSelector] = uniqueIdCounters[classSelector] || 0;
    elements.each(function() {
      let uniqueKey = `${classSelector}_${uniqueIdCounters[classSelector]}`;
      addUniqueClassesToElements(this, swiperSelector, uniqueKey, [
        ".swiper-arrow",
        ".swiper-nav",
        ".swiper-drag-wrapper"
      ]);
      let swiperOptions = getMergedSwiperOptions(options, uniqueKey);
      manageSwiperInstance(this, swiperSelector, uniqueKey, classSelector, swiperOptions, mode);
      uniqueIdCounters[classSelector]++;
    });
  };
  var addUniqueClassesToElements = (context, swiperSelector, uniqueKey, controlSelectors) => {
    controlSelectors.forEach((selector) => {
      $(context).find(selector).addClass(uniqueKey);
    });
    $(context).find(swiperSelector).addClass(uniqueKey);
  };
  var getMergedSwiperOptions = (options, uniqueKey) => {
    const defaultPagination = {
      el: `.swiper-nav.${uniqueKey}`,
      type: "bullets",
      bulletActiveClass: "cc-active",
      bulletClass: "swiper-dot",
      clickable: true
    };
    const paginationConfig = options.pagination ? { ...defaultPagination, ...options.pagination } : defaultPagination;
    return {
      speed: 1e3,
      navigation: {
        prevEl: `.swiper-arrow.prev.${uniqueKey}`,
        nextEl: `.swiper-arrow.next.${uniqueKey}`
      },
      pagination: paginationConfig,
      ...options
    };
  };
  var manageSwiperInstance = (context, swiperSelector, uniqueKey, classSelector, swiperOptions, mode) => {
    swipers[classSelector] = swipers[classSelector] || {};
    swipers[classSelector][uniqueKey] = swipers[classSelector][uniqueKey] || {};
    let existingInstance = swipers[classSelector][uniqueKey];
    let existingSwiper = existingInstance.swiperInstance;
    let shouldInitDesktop = mode === "desktop" && window.matchMedia("(min-width: 992px)").matches;
    let shouldInitMobile = mode === "mobile" && window.matchMedia("(min-width: 0px) and (max-width: 991px)").matches;
    let shouldInitAll = mode === "all";
    const destroySwiper = () => {
      if (existingInstance.observer) {
        existingInstance.observer.disconnect();
        delete existingInstance.observer;
      }
      if (existingSwiper) {
        existingSwiper.destroy(true, true);
        delete swipers[classSelector][uniqueKey];
        console.log("Swiper destroyed for", swiperSelector, "with uniqueKey", uniqueKey);
      }
    };
    const reInitObserver = () => {
      if (existingInstance.observer) {
        existingInstance.observer.disconnect();
      }
      const swiperElement = $(`${swiperSelector}.${uniqueKey}`)[0];
      if (!swiperElement)
        return;
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && (shouldInitDesktop || shouldInitMobile || shouldInitAll)) {
            if (!existingSwiper) {
              let swiper = new Swiper(`${swiperSelector}.${uniqueKey}`, swiperOptions);
              swipers[classSelector][uniqueKey] = {
                swiperInstance: swiper,
                mode: shouldInitDesktop ? "desktop" : shouldInitMobile ? "mobile" : "all",
                initialized: true
              };
              observer.disconnect();
              console.log("Swiper initialized for", swiperSelector, "with uniqueKey", uniqueKey);
            }
          }
        });
      }, {});
      swipers[classSelector][uniqueKey].observer = observer;
      observer.observe(swiperElement);
    };
    if (!shouldInitDesktop && mode === "desktop")
      destroySwiper();
    else if (!shouldInitMobile && mode === "mobile")
      destroySwiper();
    else if (!shouldInitAll && mode === "all")
      destroySwiper();
    else if ((shouldInitDesktop || shouldInitMobile || shouldInitAll) && !existingSwiper) {
      reInitObserver();
    }
  };
  var runSwipers = (swiperInstances) => {
    swiperInstances.forEach((instance) => {
      createResponsiveSwiper(...instance);
    });
  };
  var initSwipers = (swiperInstances, swipersState) => {
    runSwipers(swiperInstances);
    window.addEventListener("resize", function() {
      if (window.innerWidth !== windowWidth) {
        windowWidth = window.innerWidth;
        runSwipers(swiperInstances);
      }
    });
  };

  // src/Carousels.js
  var Carousels = class {
    constructor() {
      const swiperInstances = [
        [
          ".section.cc-about",
          ".about-wrap",
          "about-slider",
          {
            slidesPerView: "auto",
            spaceBetween: 32
          },
          "mobile"
        ],
        [
          ".section.cc-team",
          ".team-list-wrap",
          "team-slider",
          {
            slidesPerView: "auto",
            spaceBetween: 16
          },
          "mobile"
        ],
        [
          ".section.cc-exp",
          ".experience_slider",
          "exp-slider",
          {
            slidesPerView: "auto",
            spaceBetween: 32
          },
          "mobile"
        ],
        [
          ".section.cc-exp-cards",
          ".exp-cards_wrap",
          "exp-cards-slider",
          {
            slidesPerView: "auto",
            spaceBetween: 32
          },
          "mobile"
        ],
        [
          ".section.cc-ceo",
          ".ceo_slider",
          "ceo-slider",
          {
            slidesPerView: "auto",
            spaceBetween: 16
          },
          "mobile"
        ]
      ];
      initSwipers(swiperInstances);
    }
  };

  // src/MobilePinning.js
  var MobilePinning = class {
    sections;
    constructor() {
      this.sections = $(".section_part");
    }
    start() {
      this.sections.each((index, section) => {
        if (index === this.sections.length - 1)
          return;
        const nextSection = this.sections[index + 1];
        const currentHeight = $(section).outerHeight();
        const isShortSection = currentHeight <= window.innerHeight;
        $(section).css({ position: "relative", zIndex: 1 });
        $(nextSection).css({ position: "relative", zIndex: 2 });
        ScrollTrigger.create({
          trigger: section,
          start: isShortSection ? "top top" : "bottom bottom",
          endTrigger: nextSection,
          end: "top top",
          pin: true,
          pinSpacing: false,
          anticipatePin: 1,
          onEnter: () => {
            $(section).css({ zIndex: 1 });
            $(nextSection).css({ zIndex: 2 });
          },
          onEnterBack: () => {
            $(section).css({ zIndex: 1 });
            $(nextSection).css({ zIndex: 2 });
          },
          onLeave: () => {
            $(section).css({ zIndex: 1 });
            $(nextSection).css({ zIndex: 2 });
          },
          onLeaveBack: () => {
            $(section).css({ zIndex: 1 });
            $(nextSection).css({ zIndex: 2 });
          }
        });
      });
    }
    kill() {
      ScrollTrigger.getAll().forEach((st) => {
        if (st.vars.pin)
          st.kill();
      });
      this.sections.each((_, section) => {
        $(section).css({ position: "", zIndex: "" });
      });
    }
  };

  // src/Modals.js
  var Modals = class {
    modalGroup;
    modals;
    modalTargets;
    constructor() {
      this.modalGroup = document.querySelector("[data-modal-group-status]");
      this.modals = document.querySelectorAll("[data-modal-name]");
      this.modalTargets = document.querySelectorAll("[data-modal-target]");
      this.modalTargets.forEach((modalTarget) => {
        modalTarget.addEventListener("click", this.openModal.bind(this));
      });
      document.querySelectorAll("[data-modal-close]").forEach((closeBtn) => {
        closeBtn.addEventListener("click", this.closeAllModals.bind(this));
      });
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          this.closeAllModals();
        }
      });
    }
    openModal(e) {
      const modalTarget = e.currentTarget;
      const modalTargetName = modalTarget.getAttribute("data-modal-target");
      this.modalTargets.forEach((target) => target.setAttribute("data-modal-status", "not-active"));
      this.modals.forEach((modal) => modal.setAttribute("data-modal-status", "not-active"));
      if (modalTargetName === "team") {
        let teamCard = $(modalTarget).closest(".team-list-item");
        let currentIndex = teamCard.parent().index();
        let teamName = teamCard.find("[data-team-name]").text();
        let teamRole = teamCard.find("[data-team-role]").text();
        $("[data-target-name]").text(teamName);
        $("[data-target-role]").text(teamRole);
        $(".team_visual .w-dyn-item").hide();
        $(".team_visual .w-dyn-item").eq(currentIndex).fadeIn();
        $(".team_role-rich-item").hide();
        $(".team_role-rich-item").eq(currentIndex).show();
      }
      document.querySelector(`[data-modal-target="${modalTargetName}"]`).setAttribute("data-modal-status", "active");
      document.querySelector(`[data-modal-name="${modalTargetName}"]`).setAttribute("data-modal-status", "active");
      if (this.modalGroup) {
        this.modalGroup.setAttribute("data-modal-group-status", "active");
      }
      window.dispatchEvent(new CustomEvent("modal_open"));
    }
    // Function to close all modals
    closeAllModals() {
      this.modalTargets.forEach((target) => target.setAttribute("data-modal-status", "not-active"));
      if (this.modalGroup) {
        this.modalGroup.setAttribute("data-modal-group-status", "not-active");
      }
      window.dispatchEvent(new CustomEvent("modal_closed"));
    }
  };

  // src/Nav.js
  var Nav = class {
    _isMobile;
    navbar;
    wNavBtn;
    navLinks;
    onScrollBound;
    _currentSection;
    navContainer;
    navBg;
    constructor() {
      this.navbar = $(".nav");
      this.wNavBtn = $(".w-nav-button");
      this.navLinks = $(".nav_menu-link");
      this.navContainer = document.querySelector(".nav_menu-inner");
      this.navBg = document.querySelector(".nav_menu-bg");
      this.contactBtns = document.querySelectorAll(".btn.cc-nav");
      this.onScrollBound = this.onScroll.bind(this);
      this.navLinks.on("click", (e) => {
        e.preventDefault();
        const linkId = $(e.currentTarget).attr("id");
        this.mobileScrollToSection(linkId);
        window.history.pushState({}, "", `${document.location.origin}#${linkId}`);
        window.dispatchEvent(new CustomEvent("clicked_nav", { detail: linkId }));
      });
      $(".nav_brand").on("click", () => {
        window.dispatchEvent(new CustomEvent("clicked_nav", { detail: "none" }));
      });
      this.createObserver(this.wNavBtn, this.menuCallback.bind(this));
      window.addEventListener("hashchange", this.deepLink.bind(this));
    }
    get isMobile() {
      return this._isMobile;
    }
    set isMobile(val) {
      if (val !== this._isMobile) {
        if (val) {
          window.addEventListener("scroll", this.onScrollBound);
        } else {
          window.removeEventListener("scroll", this.onScrollBound);
        }
      }
      this._isMobile = val;
    }
    get currentSection() {
      return this._currentSection;
    }
    set currentSection(section) {
      this._currentSection = section;
      const targetLink = this.navLinks.filter(`#${section}`);
      this.navLinks.removeClass("active");
      targetLink.addClass("active");
      this.animateNavBackground(targetLink[0]);
      this.updateContactBtn(section);
    }
    deepLink() {
      let linkId = document.location.hash.substring(1);
      if (linkId === "top") {
        linkId = "none";
      }
      if (linkId.trim() !== "") {
        window.dispatchEvent(new CustomEvent("clicked_nav", { detail: linkId }));
      }
    }
    mobileScrollToSection(linkId) {
      if (this.isMobile) {
        if (linkId === "top") {
          linkId = "none";
        }
        const targetSection = $(`.section_part[data-section="${linkId}"]`);
        if (targetSection.length) {
          const pinSpacer = targetSection.parent(".pin-spacer");
          let scrollTarget;
          if (pinSpacer.length) {
            scrollTarget = pinSpacer.offset().top;
          } else {
            scrollTarget = targetSection.offset().top;
          }
          gsap.to(window, { scrollTo: { y: scrollTarget }, duration: 2, ease: "power2.out" });
        }
      }
    }
    createObserver(targetNodes, callback) {
      targetNodes.each((i, node) => {
        const observer = new MutationObserver((mutationsList) => {
          mutationsList.forEach((mutation) => {
            if (mutation.type === "attributes" && mutation.attributeName === "class") {
              callback(mutation.target);
            }
          });
        });
        observer.observe(node, { attributes: true, attributeFilter: ["class"] });
      });
    }
    updateContactBtn(section) {
      if (!this.isMobile && section === "none") {
        this.contactBtns.forEach((elm) => elm.classList.add("start"));
      } else {
        this.contactBtns.forEach((elm) => elm.classList.remove("start"));
      }
    }
    animateNavBackground(targetLink) {
      if (!targetLink) {
        this.navBg.style.opacity = "0";
        return;
      }
      const containerRect = this.navContainer.getBoundingClientRect();
      const linkRect = targetLink.getBoundingClientRect();
      const relativeLeft = linkRect.left - containerRect.left;
      gsap.to(this.navBg, {
        x: relativeLeft,
        opacity: 1,
        width: linkRect.width,
        height: linkRect.height,
        duration: 0.4,
        ease: "power2.out"
      });
    }
    menuCallback() {
      if (this.wNavBtn.hasClass("w--open")) {
        this.navbar.addClass("open");
      } else {
        this.navbar.removeClass("open");
      }
    }
    onScroll() {
      if (this.navbar.length && this.isMobile) {
        if (window.scrollY > this.navbar.height() / 2) {
          if (!this.navbar.hasClass("active")) {
            this.navbar.addClass("active");
          }
        } else {
          if (this.navbar.hasClass("active")) {
            this.navbar.removeClass("active");
          }
        }
      }
    }
  };

  // src/Preloader.js
  var Preloader = class {
    SEEN_PRELOADED_KEY = "seen_preloader";
    isMobile = false;
    skip;
    constructor() {
      this.skip = window.sessionStorage.getItem(this.SEEN_PRELOADED_KEY) === "true" || document.location.hash !== "";
      if (!this.skip) {
        window.sessionStorage.setItem(this.SEEN_PRELOADED_KEY, "true");
      }
    }
    start() {
      let preloader = $(".page-load");
      let preloaderParts = $(".page-load_item");
      let preLoaderBgTop = $(".page-load_bg.cc-top");
      let preLoaderBgBottom = $(".page-load_bg.cc-bottom");
      let mainContent = $(".page-main");
      let sections = $(".section");
      let nav = $(".nav_wrapper");
      window.dispatchEvent(new CustomEvent("preloader_begin"));
      let tl = gsap.timeline({
        onComplete: () => {
          let heroItems = $(".section.cc-hero").find("[data-animation]");
          heroItems.each((i, elm) => {
            gsapAnimate($(elm), this.isMobile);
          });
          window.dispatchEvent(new CustomEvent("preloader_complete"));
        }
      });
      mainContent[0].style.display = "flex";
      gsap.set(sections, { autoAlpha: 0 });
      gsap.set(nav, { autoAlpha: 0 });
      preloaderParts.each(function(index) {
        if (index === 0) {
          tl.fromTo(
            $(this),
            {
              yPercent: 50,
              opacity: 0
            },
            {
              yPercent: 0,
              opacity: 1,
              delay: 1,
              duration: 0.5,
              display: "block"
            }
          );
          tl.to(
            preLoaderBgTop,
            {
              xPercent: -5,
              rotate: -3
            },
            "<"
          );
          tl.to(
            preLoaderBgBottom,
            {
              xPercent: 5,
              rotate: -3
            },
            "<"
          );
          tl.to($(this), {
            opacity: 0,
            delay: 1.5
          });
        }
        if (index === 1) {
          tl.fromTo(
            $(this),
            {
              opacity: 0,
              scale: 0.8
            },
            {
              display: "block",
              opacity: 1,
              scale: 1
            }
          );
          tl.to(
            preLoaderBgTop,
            {
              xPercent: -10,
              rotate: -6
            },
            "<"
          );
          tl.to(
            preLoaderBgBottom,
            {
              xPercent: 10,
              rotate: -6
            },
            "<"
          );
          tl.to($(this), {
            opacity: 0,
            delay: 0.7
          });
        }
        if (index === 2) {
          tl.to($(this), {
            display: "block"
          });
          tl.fromTo(
            $(this).find("span"),
            {
              yPercent: 50,
              opacity: 0
            },
            {
              yPercent: 0,
              opacity: 1
            }
          );
          tl.to(
            preLoaderBgTop,
            {
              xPercent: -15,
              rotate: -9
            },
            "<"
          );
          tl.to(
            preLoaderBgBottom,
            {
              xPercent: 15,
              rotate: -9
            },
            "<"
          );
          tl.to(
            $(this).find("span"),
            {
              yPercent: 0,
              opacity: 0,
              stagger: {
                each: 0.1
              },
              delay: 3
            },
            "<"
          );
          tl.to(
            preLoaderBgTop,
            {
              yPercent: -100
            },
            "<"
          );
          tl.to(
            preLoaderBgBottom,
            {
              xPercent: 100
            },
            "<"
          );
          tl.to($(this), {
            opacity: 0
          });
        }
      });
      tl.to(preloader, { autoAlpha: 0, duration: 1, ease: "linear" }, "<");
      tl.to(sections, { autoAlpha: 1, duration: 1, ease: "linear" }, "<");
      tl.to(nav, { autoAlpha: 1, display: "block", duration: 1, ease: "linear" }, "<");
      if (this.skip) {
        tl.progress(1);
      }
    }
  };

  // src/ScrollSnap.ts
  var _ScrollSnap = class {
    // ==============================================================
    // #endregion Properties
    // #region Lifecycle
    // ==============================================================
    /**
     *
     * @param sections The blades within that determine where the stop points are.
     */
    constructor(sections) {
      this.sections = sections;
      gsap.registerPlugin(ScrollToPlugin);
      this.intObs = new IntersectionObserver(this.onIntersectionBound, { threshold: 0.2 });
    }
    // #region Properties
    // ==============================================================
    // Public
    paused = false;
    // State
    isAnimating = false;
    isScrollingWithinSection = false;
    currentSectionIdx = 0;
    prevDir = null;
    prevScrollStrength = 0;
    targetX = 0;
    lastScrollTime = 0;
    // Other
    intObs;
    // Listeners
    onIntersectionBound = this.onIntersection.bind(this);
    onMouseWheelBound = this.onMouseWheel.bind(this);
    onKeyDownBound = this.onKeyDown.bind(this);
    onResizeBound = this.onResize.bind(this);
    // ==============================================================
    // #endregion Lifecycle
    // #region Public methods
    // ==============================================================
    start() {
      this.currentSectionIdx = 0;
      window.scrollTo({ left: 0, top: 0 });
      this.paused = false;
      this.sections.forEach((elm) => this.intObs.observe(elm));
      window.addEventListener("wheel", this.onMouseWheelBound, { passive: false });
      window.addEventListener("keydown", this.onKeyDownBound, { passive: false });
      window.addEventListener("resize", this.onResizeBound);
    }
    kill() {
      this.isAnimating = false;
      this.isScrollingWithinSection = false;
      this.prevScrollStrength = 0;
      this.targetX = 0;
      this.prevDir = null;
      this.intObs.disconnect();
      gsap.killTweensOf(window);
      window.removeEventListener("wheel", this.onMouseWheelBound);
      window.removeEventListener("keydown", this.onKeyDownBound);
      window.removeEventListener("resize", this.onResizeBound);
      gsap.killTweensOf(window);
    }
    /**
     * Animate to a target section
     * @param targetSectionIdx index of `this.sections` to animate to
     * @param instant Defaults to false. Whether or not you want to ignore the animation and jump straight to the end state.
     * @param fromScrollEvent Should be ignored/undefined when calling this method externally
     */
    gotoIdx(targetSectionIdx, instant = false, fromScrollEvent = false) {
      if (this.isAnimating) {
        return;
      }
      const dir = this.currentSectionIdx < targetSectionIdx ? 1 /* RIGHT */ : 0 /* LEFT */;
      this.currentSectionIdx = targetSectionIdx;
      this.isAnimating = !instant;
      this.isScrollingWithinSection = false;
      const targetSection = this.sections[this.currentSectionIdx];
      this.targetX = targetSection.offsetLeft;
      if (fromScrollEvent && dir === 0 /* LEFT */ && targetSection.offsetWidth > window.innerWidth) {
        this.targetX = targetSection.offsetLeft + targetSection.offsetWidth - window.innerWidth;
      }
      if (!instant) {
        window.dispatchEvent(new CustomEvent("scrolling", { detail: dir }));
      }
      gsap.to(window, {
        scrollTo: { x: this.targetX, y: 0 },
        duration: instant ? 0 : _ScrollSnap.SCROLL_DUR,
        ease: _ScrollSnap.SCROLL_EASE_BETWEEN_SECTIONS,
        onComplete: () => {
          this.isAnimating = false;
        }
      });
    }
    // ==============================================================
    // #endregion End Public methods
    // #region Private methods
    // ==============================================================
    /**
     * We're within a section that's wider than the viewport. Smooth the scrolling within it.
     */
    scrollWithinSection(e) {
      if (this.isAnimating) {
        return;
      }
      const scrollStrength = e.deltaY;
      const dir = scrollStrength > 0 ? 1 /* RIGHT */ : 0 /* LEFT */;
      if (!this.isScrollingWithinSection && Math.abs(scrollStrength) < this.prevScrollStrength && dir === this.prevDir) {
        return true;
      }
      this.targetX += scrollStrength * _ScrollSnap.SCROLL_STRENGTH_MULTIPLIER;
      const currentSection = this.sections[this.currentSectionIdx];
      const minX = currentSection.offsetLeft;
      const maxX = currentSection.offsetLeft + currentSection.offsetWidth - window.innerWidth;
      this.targetX = this.clamp(minX, this.targetX, maxX);
      if (!this.isScrollingWithinSection) {
        this.isScrollingWithinSection = true;
        this.smoothScrollWithinSection();
      }
      const currentX = window.scrollX;
      const buffer = 30;
      const isWithin = dir === 0 /* LEFT */ && currentX > minX + buffer || dir === 1 /* RIGHT */ && currentX < maxX - buffer;
      return isWithin;
    }
    /**
     * Ease between a current value and a target value
     */
    smoothScrollWithinSection() {
      const currentX = window.scrollX;
      const deltaX = this.targetX - currentX;
      const EASING = _ScrollSnap.SCROLL_EASE_WITHIN_SECTION;
      gsap.set(window, { scrollTo: { x: currentX + deltaX * EASING, y: 0 } });
      if (this.isScrollingWithinSection) {
        requestAnimationFrame(this.smoothScrollWithinSection.bind(this));
      }
    }
    /**
     * Go left or right. Calculate which section index that should be.
     * @param dir
     */
    go(dir) {
      this.prevDir = dir;
      let targetSectionIdx = this.currentSectionIdx + (dir === 1 /* RIGHT */ ? 1 : -1);
      targetSectionIdx = this.clamp(0, targetSectionIdx, this.sections.length - 1);
      if (targetSectionIdx !== this.currentSectionIdx) {
        this.gotoIdx(targetSectionIdx, false, true);
      }
    }
    /**
     * Simple utility to clamp a value between a min and max.
     * @param min Lowest possible value
     * @param val Current value
     * @param max Maximum possible value
     */
    clamp(min, val, max) {
      return Math.min(Math.max(val, min), max);
    }
    // ==============================================================
    // #endregion End Private methods
    // #region Event Listeners
    // ==============================================================
    /**
     * On sections coming on screen, evaluate which one is visible and report back to the main controller
     */
    onIntersection(entries) {
      const visibles = entries.filter((entry) => entry.isIntersecting);
      if (visibles.length) {
        const section = visibles[0].target;
        const idx = [...this.sections].findIndex((s) => s === section);
        this.currentSectionIdx = idx;
        window.dispatchEvent(new CustomEvent("go_to_section", { detail: idx }));
      }
    }
    /**
     * On mouse wheel interaction, figure out which way we're scrolling.
     */
    onMouseWheel(e) {
      if (this.paused) {
        return;
      }
      e.preventDefault();
      e.stopImmediatePropagation();
      const scrollStrength = e.deltaY;
      if (Math.abs(scrollStrength) < _ScrollSnap.MIN_SCROLL_STRENGTH) {
        this.prevScrollStrength = 0;
        return;
      }
      const currentTime = performance.now();
      const timeSinceLastScroll = currentTime - this.lastScrollTime;
      const currentSection = this.sections[this.currentSectionIdx];
      if (currentSection.offsetWidth > window.innerWidth) {
        const withinSectionBounds = this.scrollWithinSection(e);
        if (withinSectionBounds) {
          return;
        }
      }
      const dir = scrollStrength > 0 ? 1 /* RIGHT */ : 0 /* LEFT */;
      if (timeSinceLastScroll > _ScrollSnap.MOMENTUM_TIMEOUT && (Math.abs(scrollStrength) - this.prevScrollStrength > 20 || dir !== this.prevDir)) {
        this.lastScrollTime = currentTime;
        this.go(dir);
      }
      this.prevScrollStrength = Math.abs(scrollStrength);
    }
    /**
     * On keydown. So the user can still navigate via keyboard.
     */
    onKeyDown(e) {
      if (this.paused) {
        return;
      }
      const tagName = e.target.tagName.toLowerCase();
      if (tagName === "input" || tagName === "textarea" || tagName === "select" || e.target.isContentEditable) {
        return;
      }
      let dir;
      if (e.key === "ArrowDown" || e.key === "ArrowRight") {
        dir = 1 /* RIGHT */;
      } else if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
        dir = 0 /* LEFT */;
      } else {
        return;
      }
      const currentSection = this.sections[this.currentSectionIdx];
      if (currentSection.offsetWidth > window.innerWidth) {
        const scrollAmt = 300;
        const deltaY = dir === 1 /* RIGHT */ ? scrollAmt : -scrollAmt;
        const withinSectionBounds = this.scrollWithinSection(new WheelEvent("wheel", { deltaY }));
        if (withinSectionBounds) {
          return;
        }
      }
      this.go(dir);
    }
    /**
     * Window resize event handler
     */
    onResize() {
      if (this.paused) {
        return;
      }
      const targetSection = this.sections[this.currentSectionIdx];
      this.targetX = targetSection.offsetLeft;
      gsap.set(window, {
        scrollTo: { x: this.targetX, y: 0 }
      });
      this.isAnimating = false;
    }
    // ==============================================================
    // #endregion End Event Listeners
  };
  var ScrollSnap = _ScrollSnap;
  // Config
  __publicField(ScrollSnap, "SCROLL_DUR", 0.6);
  /** Speed at which scroll animation happens (in seconds) */
  __publicField(ScrollSnap, "SCROLL_EASE_BETWEEN_SECTIONS", "power2.out");
  /** Easing method of scroll animation from one section to another. From GSAP. */
  __publicField(ScrollSnap, "SCROLL_EASE_WITHIN_SECTION", 0.1);
  /** The easing strength when scrolling within a long section. */
  __publicField(ScrollSnap, "SCROLL_STRENGTH_MULTIPLIER", 0.6);
  /** Amount to strengthen or dampen the scrollwheel strength by when scrolling within a section. */
  __publicField(ScrollSnap, "MIN_SCROLL_STRENGTH", 10);
  /** The minimum strength/speed someone has to scroll in order to trigger the effect. */
  __publicField(ScrollSnap, "MOMENTUM_TIMEOUT", 250);

  // node_modules/.pnpm/three@0.173.0/node_modules/three/build/three.core.js
  var REVISION = "173";
  var CullFaceNone = 0;
  var CullFaceBack = 1;
  var CullFaceFront = 2;
  var PCFShadowMap = 1;
  var PCFSoftShadowMap = 2;
  var VSMShadowMap = 3;
  var FrontSide = 0;
  var BackSide = 1;
  var DoubleSide = 2;
  var NoBlending = 0;
  var NormalBlending = 1;
  var AdditiveBlending = 2;
  var SubtractiveBlending = 3;
  var MultiplyBlending = 4;
  var CustomBlending = 5;
  var AddEquation = 100;
  var SubtractEquation = 101;
  var ReverseSubtractEquation = 102;
  var MinEquation = 103;
  var MaxEquation = 104;
  var ZeroFactor = 200;
  var OneFactor = 201;
  var SrcColorFactor = 202;
  var OneMinusSrcColorFactor = 203;
  var SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = 205;
  var DstAlphaFactor = 206;
  var OneMinusDstAlphaFactor = 207;
  var DstColorFactor = 208;
  var OneMinusDstColorFactor = 209;
  var SrcAlphaSaturateFactor = 210;
  var ConstantColorFactor = 211;
  var OneMinusConstantColorFactor = 212;
  var ConstantAlphaFactor = 213;
  var OneMinusConstantAlphaFactor = 214;
  var NeverDepth = 0;
  var AlwaysDepth = 1;
  var LessDepth = 2;
  var LessEqualDepth = 3;
  var EqualDepth = 4;
  var GreaterEqualDepth = 5;
  var GreaterDepth = 6;
  var NotEqualDepth = 7;
  var MultiplyOperation = 0;
  var MixOperation = 1;
  var AddOperation = 2;
  var NoToneMapping = 0;
  var LinearToneMapping = 1;
  var ReinhardToneMapping = 2;
  var CineonToneMapping = 3;
  var ACESFilmicToneMapping = 4;
  var CustomToneMapping = 5;
  var AgXToneMapping = 6;
  var NeutralToneMapping = 7;
  var UVMapping = 300;
  var CubeReflectionMapping = 301;
  var CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = 304;
  var CubeUVReflectionMapping = 306;
  var RepeatWrapping = 1e3;
  var ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = 1002;
  var NearestFilter = 1003;
  var NearestMipmapNearestFilter = 1004;
  var NearestMipmapLinearFilter = 1005;
  var LinearFilter = 1006;
  var LinearMipmapNearestFilter = 1007;
  var LinearMipmapLinearFilter = 1008;
  var UnsignedByteType = 1009;
  var ByteType = 1010;
  var ShortType = 1011;
  var UnsignedShortType = 1012;
  var IntType = 1013;
  var UnsignedIntType = 1014;
  var FloatType = 1015;
  var HalfFloatType = 1016;
  var UnsignedShort4444Type = 1017;
  var UnsignedShort5551Type = 1018;
  var UnsignedInt248Type = 1020;
  var UnsignedInt5999Type = 35902;
  var AlphaFormat = 1021;
  var RGBFormat = 1022;
  var RGBAFormat = 1023;
  var LuminanceFormat = 1024;
  var LuminanceAlphaFormat = 1025;
  var DepthFormat = 1026;
  var DepthStencilFormat = 1027;
  var RedFormat = 1028;
  var RedIntegerFormat = 1029;
  var RGFormat = 1030;
  var RGIntegerFormat = 1031;
  var RGBAIntegerFormat = 1033;
  var RGB_S3TC_DXT1_Format = 33776;
  var RGBA_S3TC_DXT1_Format = 33777;
  var RGBA_S3TC_DXT3_Format = 33778;
  var RGBA_S3TC_DXT5_Format = 33779;
  var RGB_PVRTC_4BPPV1_Format = 35840;
  var RGB_PVRTC_2BPPV1_Format = 35841;
  var RGBA_PVRTC_4BPPV1_Format = 35842;
  var RGBA_PVRTC_2BPPV1_Format = 35843;
  var RGB_ETC1_Format = 36196;
  var RGB_ETC2_Format = 37492;
  var RGBA_ETC2_EAC_Format = 37496;
  var RGBA_ASTC_4x4_Format = 37808;
  var RGBA_ASTC_5x4_Format = 37809;
  var RGBA_ASTC_5x5_Format = 37810;
  var RGBA_ASTC_6x5_Format = 37811;
  var RGBA_ASTC_6x6_Format = 37812;
  var RGBA_ASTC_8x5_Format = 37813;
  var RGBA_ASTC_8x6_Format = 37814;
  var RGBA_ASTC_8x8_Format = 37815;
  var RGBA_ASTC_10x5_Format = 37816;
  var RGBA_ASTC_10x6_Format = 37817;
  var RGBA_ASTC_10x8_Format = 37818;
  var RGBA_ASTC_10x10_Format = 37819;
  var RGBA_ASTC_12x10_Format = 37820;
  var RGBA_ASTC_12x12_Format = 37821;
  var RGBA_BPTC_Format = 36492;
  var RGB_BPTC_SIGNED_Format = 36494;
  var RGB_BPTC_UNSIGNED_Format = 36495;
  var RED_RGTC1_Format = 36283;
  var SIGNED_RED_RGTC1_Format = 36284;
  var RED_GREEN_RGTC2_Format = 36285;
  var SIGNED_RED_GREEN_RGTC2_Format = 36286;
  var InterpolateDiscrete = 2300;
  var InterpolateLinear = 2301;
  var InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = 2401;
  var WrapAroundEnding = 2402;
  var BasicDepthPacking = 3200;
  var RGBADepthPacking = 3201;
  var TangentSpaceNormalMap = 0;
  var ObjectSpaceNormalMap = 1;
  var NoColorSpace = "";
  var SRGBColorSpace = "srgb";
  var LinearSRGBColorSpace = "srgb-linear";
  var LinearTransfer = "linear";
  var SRGBTransfer = "srgb";
  var KeepStencilOp = 7680;
  var AlwaysStencilFunc = 519;
  var NeverCompare = 512;
  var LessCompare = 513;
  var EqualCompare = 514;
  var LessEqualCompare = 515;
  var GreaterCompare = 516;
  var NotEqualCompare = 517;
  var GreaterEqualCompare = 518;
  var AlwaysCompare = 519;
  var StaticDrawUsage = 35044;
  var GLSL3 = "300 es";
  var WebGLCoordinateSystem = 2e3;
  var WebGPUCoordinateSystem = 2001;
  var EventDispatcher = class {
    addEventListener(type, listener) {
      if (this._listeners === void 0)
        this._listeners = {};
      const listeners = this._listeners;
      if (listeners[type] === void 0) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    }
    hasEventListener(type, listener) {
      const listeners = this._listeners;
      if (listeners === void 0)
        return false;
      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
    }
    removeEventListener(type, listener) {
      const listeners = this._listeners;
      if (listeners === void 0)
        return;
      const listenerArray = listeners[type];
      if (listenerArray !== void 0) {
        const index = listenerArray.indexOf(listener);
        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    }
    dispatchEvent(event) {
      const listeners = this._listeners;
      if (listeners === void 0)
        return;
      const listenerArray = listeners[event.type];
      if (listenerArray !== void 0) {
        event.target = this;
        const array = listenerArray.slice(0);
        for (let i = 0, l = array.length; i < l; i++) {
          array[i].call(this, event);
        }
        event.target = null;
      }
    }
  };
  var _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
  var DEG2RAD = Math.PI / 180;
  var RAD2DEG = 180 / Math.PI;
  function generateUUID() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toLowerCase();
  }
  function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function euclideanModulo(n, m) {
    return (n % m + m) % m;
  }
  function lerp(x, y, t) {
    return (1 - t) * x + t * y;
  }
  function denormalize(value, array) {
    switch (array.constructor) {
      case Float32Array:
        return value;
      case Uint32Array:
        return value / 4294967295;
      case Uint16Array:
        return value / 65535;
      case Uint8Array:
        return value / 255;
      case Int32Array:
        return Math.max(value / 2147483647, -1);
      case Int16Array:
        return Math.max(value / 32767, -1);
      case Int8Array:
        return Math.max(value / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function normalize(value, array) {
    switch (array.constructor) {
      case Float32Array:
        return value;
      case Uint32Array:
        return Math.round(value * 4294967295);
      case Uint16Array:
        return Math.round(value * 65535);
      case Uint8Array:
        return Math.round(value * 255);
      case Int32Array:
        return Math.round(value * 2147483647);
      case Int16Array:
        return Math.round(value * 32767);
      case Int8Array:
        return Math.round(value * 127);
      default:
        throw new Error("Invalid component type.");
    }
  }
  var Vector2 = class {
    constructor(x = 0, y = 0) {
      Vector2.prototype.isVector2 = true;
      this.x = x;
      this.y = y;
    }
    get width() {
      return this.x;
    }
    set width(value) {
      this.x = value;
    }
    get height() {
      return this.y;
    }
    set height(value) {
      this.y = value;
    }
    set(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    }
    add(v) {
      this.x += v.x;
      this.y += v.y;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      return this;
    }
    sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
      const x = this.x, y = this.y;
      const e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6];
      this.y = e[1] * x + e[4] * y + e[7];
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    }
    clamp(min, max) {
      this.x = clamp(this.x, min.x, max.x);
      this.y = clamp(this.y, min.y, max.y);
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = clamp(this.x, minVal, maxVal);
      this.y = clamp(this.y, minVal, maxVal);
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
    roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y;
    }
    cross(v) {
      return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      const angle = Math.atan2(-this.y, -this.x) + Math.PI;
      return angle;
    }
    angleTo(v) {
      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0)
        return Math.PI / 2;
      const theta = this.dot(v) / denominator;
      return Math.acos(clamp(theta, -1, 1));
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y;
      return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    }
    rotateAround(center, angle) {
      const c = Math.cos(angle), s = Math.sin(angle);
      const x = this.x - center.x;
      const y = this.y - center.y;
      this.x = x * c - y * s + center.x;
      this.y = x * s + y * c + center.y;
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
    }
  };
  var Matrix3 = class {
    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      Matrix3.prototype.isMatrix3 = true;
      this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      if (n11 !== void 0) {
        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
      }
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      const te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    }
    identity() {
      this.set(
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      );
      return this;
    }
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
    setFromMatrix4(m) {
      const me = m.elements;
      this.set(
        me[0],
        me[4],
        me[8],
        me[1],
        me[5],
        me[9],
        me[2],
        me[6],
        me[10]
      );
      return this;
    }
    multiply(m) {
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
      const ae = a.elements;
      const be = b.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[3], a13 = ae[6];
      const a21 = ae[1], a22 = ae[4], a23 = ae[7];
      const a31 = ae[2], a32 = ae[5], a33 = ae[8];
      const b11 = be[0], b12 = be[3], b13 = be[6];
      const b21 = be[1], b22 = be[4], b23 = be[7];
      const b31 = be[2], b32 = be[5], b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    }
    determinant() {
      const te = this.elements;
      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    }
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
    transpose() {
      let tmp;
      const m = this.elements;
      tmp = m[1];
      m[1] = m[3];
      m[3] = tmp;
      tmp = m[2];
      m[2] = m[6];
      m[6] = tmp;
      tmp = m[5];
      m[5] = m[7];
      m[7] = tmp;
      return this;
    }
    getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).invert().transpose();
    }
    transposeIntoArray(r) {
      const m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      const c = Math.cos(rotation);
      const s = Math.sin(rotation);
      this.set(
        sx * c,
        sx * s,
        -sx * (c * cx + s * cy) + cx + tx,
        -sy * s,
        sy * c,
        -sy * (-s * cx + c * cy) + cy + ty,
        0,
        0,
        1
      );
      return this;
    }
    //
    scale(sx, sy) {
      this.premultiply(_m3.makeScale(sx, sy));
      return this;
    }
    rotate(theta) {
      this.premultiply(_m3.makeRotation(-theta));
      return this;
    }
    translate(tx, ty) {
      this.premultiply(_m3.makeTranslation(tx, ty));
      return this;
    }
    // for 2D Transforms
    makeTranslation(x, y) {
      if (x.isVector2) {
        this.set(
          1,
          0,
          x.x,
          0,
          1,
          x.y,
          0,
          0,
          1
        );
      } else {
        this.set(
          1,
          0,
          x,
          0,
          1,
          y,
          0,
          0,
          1
        );
      }
      return this;
    }
    makeRotation(theta) {
      const c = Math.cos(theta);
      const s = Math.sin(theta);
      this.set(
        c,
        -s,
        0,
        s,
        c,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeScale(x, y) {
      this.set(
        x,
        0,
        0,
        0,
        y,
        0,
        0,
        0,
        1
      );
      return this;
    }
    //
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i = 0; i < 9; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < 9; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  };
  var _m3 = /* @__PURE__ */ new Matrix3();
  function arrayNeedsUint32(array) {
    for (let i = array.length - 1; i >= 0; --i) {
      if (array[i] >= 65535)
        return true;
    }
    return false;
  }
  function createElementNS(name) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", name);
  }
  function createCanvasElement() {
    const canvas = createElementNS("canvas");
    canvas.style.display = "block";
    return canvas;
  }
  var _cache = {};
  function warnOnce(message) {
    if (message in _cache)
      return;
    _cache[message] = true;
    console.warn(message);
  }
  function probeAsync(gl, sync, interval) {
    return new Promise(function(resolve, reject) {
      function probe() {
        switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
          case gl.WAIT_FAILED:
            reject();
            break;
          case gl.TIMEOUT_EXPIRED:
            setTimeout(probe, interval);
            break;
          default:
            resolve();
        }
      }
      setTimeout(probe, interval);
    });
  }
  function toNormalizedProjectionMatrix(projectionMatrix) {
    const m = projectionMatrix.elements;
    m[2] = 0.5 * m[2] + 0.5 * m[3];
    m[6] = 0.5 * m[6] + 0.5 * m[7];
    m[10] = 0.5 * m[10] + 0.5 * m[11];
    m[14] = 0.5 * m[14] + 0.5 * m[15];
  }
  function toReversedProjectionMatrix(projectionMatrix) {
    const m = projectionMatrix.elements;
    const isPerspectiveMatrix = m[11] === -1;
    if (isPerspectiveMatrix) {
      m[10] = -m[10] - 1;
      m[14] = -m[14];
    } else {
      m[10] = -m[10];
      m[14] = -m[14] + 1;
    }
  }
  var LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  );
  var XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  );
  function createColorManagement() {
    const ColorManagement2 = {
      enabled: true,
      workingColorSpace: LinearSRGBColorSpace,
      /**
       * Implementations of supported color spaces.
       *
       * Required:
       *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
       *	- whitePoint: reference white [ x y ]
       *	- transfer: transfer function (pre-defined)
       *	- toXYZ: Matrix3 RGB to XYZ transform
       *	- fromXYZ: Matrix3 XYZ to RGB transform
       *	- luminanceCoefficients: RGB luminance coefficients
       *
       * Optional:
       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
       *
       * Reference:
       * - https://www.russellcottrell.com/photo/matrixCalculator.htm
       */
      spaces: {},
      convert: function(color, sourceColorSpace, targetColorSpace) {
        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
          return color;
        }
        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
          color.r = SRGBToLinear(color.r);
          color.g = SRGBToLinear(color.g);
          color.b = SRGBToLinear(color.b);
        }
        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
        }
        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
          color.r = LinearToSRGB(color.r);
          color.g = LinearToSRGB(color.g);
          color.b = LinearToSRGB(color.b);
        }
        return color;
      },
      fromWorkingColorSpace: function(color, targetColorSpace) {
        return this.convert(color, this.workingColorSpace, targetColorSpace);
      },
      toWorkingColorSpace: function(color, sourceColorSpace) {
        return this.convert(color, sourceColorSpace, this.workingColorSpace);
      },
      getPrimaries: function(colorSpace) {
        return this.spaces[colorSpace].primaries;
      },
      getTransfer: function(colorSpace) {
        if (colorSpace === NoColorSpace)
          return LinearTransfer;
        return this.spaces[colorSpace].transfer;
      },
      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {
        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
      },
      define: function(colorSpaces) {
        Object.assign(this.spaces, colorSpaces);
      },
      // Internal APIs
      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {
        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);
      },
      _getDrawingBufferColorSpace: function(colorSpace) {
        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {
        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
      }
    };
    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];
    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
    const D65 = [0.3127, 0.329];
    ColorManagement2.define({
      [LinearSRGBColorSpace]: {
        primaries: REC709_PRIMARIES,
        whitePoint: D65,
        transfer: LinearTransfer,
        toXYZ: LINEAR_REC709_TO_XYZ,
        fromXYZ: XYZ_TO_LINEAR_REC709,
        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
      },
      [SRGBColorSpace]: {
        primaries: REC709_PRIMARIES,
        whitePoint: D65,
        transfer: SRGBTransfer,
        toXYZ: LINEAR_REC709_TO_XYZ,
        fromXYZ: XYZ_TO_LINEAR_REC709,
        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
      }
    });
    return ColorManagement2;
  }
  var ColorManagement = /* @__PURE__ */ createColorManagement();
  function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
  }
  var _canvas;
  var ImageUtils = class {
    static getDataURL(image) {
      if (/^data:/i.test(image.src)) {
        return image.src;
      }
      if (typeof HTMLCanvasElement === "undefined") {
        return image.src;
      }
      let canvas;
      if (image instanceof HTMLCanvasElement) {
        canvas = image;
      } else {
        if (_canvas === void 0)
          _canvas = createElementNS("canvas");
        _canvas.width = image.width;
        _canvas.height = image.height;
        const context = _canvas.getContext("2d");
        if (image instanceof ImageData) {
          context.putImageData(image, 0, 0);
        } else {
          context.drawImage(image, 0, 0, image.width, image.height);
        }
        canvas = _canvas;
      }
      return canvas.toDataURL("image/png");
    }
    static sRGBToLinear(image) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const canvas = createElementNS("canvas");
        canvas.width = image.width;
        canvas.height = image.height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, image.width, image.height);
        const imageData = context.getImageData(0, 0, image.width, image.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i++) {
          data[i] = SRGBToLinear(data[i] / 255) * 255;
        }
        context.putImageData(imageData, 0, 0);
        return canvas;
      } else if (image.data) {
        const data = image.data.slice(0);
        for (let i = 0; i < data.length; i++) {
          if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
            data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
          } else {
            data[i] = SRGBToLinear(data[i]);
          }
        }
        return {
          data,
          width: image.width,
          height: image.height
        };
      } else {
        console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
        return image;
      }
    }
  };
  var _sourceId = 0;
  var Source = class {
    constructor(data = null) {
      this.isSource = true;
      Object.defineProperty(this, "id", { value: _sourceId++ });
      this.uuid = generateUUID();
      this.data = data;
      this.dataReady = true;
      this.version = 0;
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.images[this.uuid] !== void 0) {
        return meta.images[this.uuid];
      }
      const output = {
        uuid: this.uuid,
        url: ""
      };
      const data = this.data;
      if (data !== null) {
        let url;
        if (Array.isArray(data)) {
          url = [];
          for (let i = 0, l = data.length; i < l; i++) {
            if (data[i].isDataTexture) {
              url.push(serializeImage(data[i].image));
            } else {
              url.push(serializeImage(data[i]));
            }
          }
        } else {
          url = serializeImage(data);
        }
        output.url = url;
      }
      if (!isRootObject) {
        meta.images[this.uuid] = output;
      }
      return output;
    }
  };
  function serializeImage(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return ImageUtils.getDataURL(image);
    } else {
      if (image.data) {
        return {
          data: Array.from(image.data),
          width: image.width,
          height: image.height,
          type: image.data.constructor.name
        };
      } else {
        console.warn("THREE.Texture: Unable to serialize Texture.");
        return {};
      }
    }
  }
  var _textureId = 0;
  var Texture = class extends EventDispatcher {
    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
      super();
      this.isTexture = true;
      Object.defineProperty(this, "id", { value: _textureId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.source = new Source(image);
      this.mipmaps = [];
      this.mapping = mapping;
      this.channel = 0;
      this.wrapS = wrapS;
      this.wrapT = wrapT;
      this.magFilter = magFilter;
      this.minFilter = minFilter;
      this.anisotropy = anisotropy;
      this.format = format;
      this.internalFormat = null;
      this.type = type;
      this.offset = new Vector2(0, 0);
      this.repeat = new Vector2(1, 1);
      this.center = new Vector2(0, 0);
      this.rotation = 0;
      this.matrixAutoUpdate = true;
      this.matrix = new Matrix3();
      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4;
      this.colorSpace = colorSpace;
      this.userData = {};
      this.version = 0;
      this.onUpdate = null;
      this.renderTarget = null;
      this.isRenderTargetTexture = false;
      this.pmremVersion = 0;
    }
    get image() {
      return this.source.data;
    }
    set image(value = null) {
      this.source.data = value;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.source = source.source;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.channel = source.channel;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.internalFormat = source.internalFormat;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.colorSpace = source.colorSpace;
      this.renderTarget = source.renderTarget;
      this.isRenderTargetTexture = source.isRenderTargetTexture;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      this.needsUpdate = true;
      return this;
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.textures[this.uuid] !== void 0) {
        return meta.textures[this.uuid];
      }
      const output = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(meta).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (Object.keys(this.userData).length > 0)
        output.userData = this.userData;
      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }
      return output;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(uv) {
      if (this.mapping !== UVMapping)
        return uv;
      uv.applyMatrix3(this.matrix);
      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;
          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }
            break;
        }
      }
      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;
          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }
            break;
        }
      }
      if (this.flipY) {
        uv.y = 1 - uv.y;
      }
      return uv;
    }
    set needsUpdate(value) {
      if (value === true) {
        this.version++;
        this.source.needsUpdate = true;
      }
    }
    set needsPMREMUpdate(value) {
      if (value === true) {
        this.pmremVersion++;
      }
    }
  };
  Texture.DEFAULT_IMAGE = null;
  Texture.DEFAULT_MAPPING = UVMapping;
  Texture.DEFAULT_ANISOTROPY = 1;
  var Vector4 = class {
    constructor(x = 0, y = 0, z = 0, w = 1) {
      Vector4.prototype.isVector4 = true;
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    get width() {
      return this.z;
    }
    set width(value) {
      this.z = value;
    }
    get height() {
      return this.w;
    }
    set height(value) {
      this.w = value;
    }
    set(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setZ(z) {
      this.z = z;
      return this;
    }
    setW(w) {
      this.w = w;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        case 3:
          this.w = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.w !== void 0 ? v.w : 1;
      return this;
    }
    add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      this.w += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      this.w += v.w * s;
      return this;
    }
    sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      this.w -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      this.w *= v.w;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    }
    applyMatrix4(m) {
      const x = this.x, y = this.y, z = this.z, w = this.w;
      const e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      this.w /= v.w;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
      this.w = 2 * Math.acos(q.w);
      const s = Math.sqrt(1 - q.w * q.w);
      if (s < 1e-4) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q.x / s;
        this.y = q.y / s;
        this.z = q.z / s;
      }
      return this;
    }
    setAxisAngleFromRotationMatrix(m) {
      let angle, x, y, z;
      const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          this.set(1, 0, 0, 0);
          return this;
        }
        angle = Math.PI;
        const xx = (m11 + 1) / 2;
        const yy = (m22 + 1) / 2;
        const zz = (m33 + 1) / 2;
        const xy = (m12 + m21) / 4;
        const xz = (m13 + m31) / 4;
        const yz = (m23 + m32) / 4;
        if (xx > yy && xx > zz) {
          if (xx < epsilon) {
            x = 0;
            y = 0.707106781;
            z = 0.707106781;
          } else {
            x = Math.sqrt(xx);
            y = xy / x;
            z = xz / x;
          }
        } else if (yy > zz) {
          if (yy < epsilon) {
            x = 0.707106781;
            y = 0;
            z = 0.707106781;
          } else {
            y = Math.sqrt(yy);
            x = xy / y;
            z = yz / y;
          }
        } else {
          if (zz < epsilon) {
            x = 0.707106781;
            y = 0.707106781;
            z = 0;
          } else {
            z = Math.sqrt(zz);
            x = xz / z;
            y = yz / z;
          }
        }
        this.set(x, y, z, angle);
        return this;
      }
      let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
      if (Math.abs(s) < 1e-3)
        s = 1;
      this.x = (m32 - m23) / s;
      this.y = (m13 - m31) / s;
      this.z = (m21 - m12) / s;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    }
    setFromMatrixPosition(m) {
      const e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      this.w = e[15];
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      this.w = Math.min(this.w, v.w);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      this.w = Math.max(this.w, v.w);
      return this;
    }
    clamp(min, max) {
      this.x = clamp(this.x, min.x, max.x);
      this.y = clamp(this.y, min.y, max.y);
      this.z = clamp(this.z, min.z, max.z);
      this.w = clamp(this.w, min.w, max.w);
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = clamp(this.x, minVal, maxVal);
      this.y = clamp(this.y, minVal, maxVal);
      this.z = clamp(this.z, minVal, maxVal);
      this.w = clamp(this.w, minVal, maxVal);
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    }
    roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      this.z = Math.trunc(this.z);
      this.w = Math.trunc(this.w);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      this.w += (v.w - this.w) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      this.w = v1.w + (v2.w - v1.w) * alpha;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      this.w = attribute.getW(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      this.w = Math.random();
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
      yield this.w;
    }
  };
  var RenderTarget = class extends EventDispatcher {
    constructor(width = 1, height = 1, options = {}) {
      super();
      this.isRenderTarget = true;
      this.width = width;
      this.height = height;
      this.depth = 1;
      this.scissor = new Vector4(0, 0, width, height);
      this.scissorTest = false;
      this.viewport = new Vector4(0, 0, width, height);
      const image = { width, height, depth: 1 };
      options = Object.assign({
        generateMipmaps: false,
        internalFormat: null,
        minFilter: LinearFilter,
        depthBuffer: true,
        stencilBuffer: false,
        resolveDepthBuffer: true,
        resolveStencilBuffer: true,
        depthTexture: null,
        samples: 0,
        count: 1
      }, options);
      const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
      texture.flipY = false;
      texture.generateMipmaps = options.generateMipmaps;
      texture.internalFormat = options.internalFormat;
      this.textures = [];
      const count = options.count;
      for (let i = 0; i < count; i++) {
        this.textures[i] = texture.clone();
        this.textures[i].isRenderTargetTexture = true;
        this.textures[i].renderTarget = this;
      }
      this.depthBuffer = options.depthBuffer;
      this.stencilBuffer = options.stencilBuffer;
      this.resolveDepthBuffer = options.resolveDepthBuffer;
      this.resolveStencilBuffer = options.resolveStencilBuffer;
      this._depthTexture = null;
      this.depthTexture = options.depthTexture;
      this.samples = options.samples;
    }
    get texture() {
      return this.textures[0];
    }
    set texture(value) {
      this.textures[0] = value;
    }
    set depthTexture(current) {
      if (this._depthTexture !== null)
        this._depthTexture.renderTarget = null;
      if (current !== null)
        current.renderTarget = this;
      this._depthTexture = current;
    }
    get depthTexture() {
      return this._depthTexture;
    }
    setSize(width, height, depth = 1) {
      if (this.width !== width || this.height !== height || this.depth !== depth) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        for (let i = 0, il = this.textures.length; i < il; i++) {
          this.textures[i].image.width = width;
          this.textures[i].image.height = height;
          this.textures[i].image.depth = depth;
        }
        this.dispose();
      }
      this.viewport.set(0, 0, width, height);
      this.scissor.set(0, 0, width, height);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.width = source.width;
      this.height = source.height;
      this.depth = source.depth;
      this.scissor.copy(source.scissor);
      this.scissorTest = source.scissorTest;
      this.viewport.copy(source.viewport);
      this.textures.length = 0;
      for (let i = 0, il = source.textures.length; i < il; i++) {
        this.textures[i] = source.textures[i].clone();
        this.textures[i].isRenderTargetTexture = true;
        this.textures[i].renderTarget = this;
      }
      const image = Object.assign({}, source.texture.image);
      this.texture.source = new Source(image);
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.resolveDepthBuffer = source.resolveDepthBuffer;
      this.resolveStencilBuffer = source.resolveStencilBuffer;
      if (source.depthTexture !== null)
        this.depthTexture = source.depthTexture.clone();
      this.samples = source.samples;
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  var WebGLRenderTarget = class extends RenderTarget {
    constructor(width = 1, height = 1, options = {}) {
      super(width, height, options);
      this.isWebGLRenderTarget = true;
    }
  };
  var DataArrayTexture = class extends Texture {
    constructor(data = null, width = 1, height = 1, depth = 1) {
      super(null);
      this.isDataArrayTexture = true;
      this.image = { data, width, height, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
      this.layerUpdates = /* @__PURE__ */ new Set();
    }
    addLayerUpdate(layerIndex) {
      this.layerUpdates.add(layerIndex);
    }
    clearLayerUpdates() {
      this.layerUpdates.clear();
    }
  };
  var Data3DTexture = class extends Texture {
    constructor(data = null, width = 1, height = 1, depth = 1) {
      super(null);
      this.isData3DTexture = true;
      this.image = { data, width, height, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
    }
  };
  var Quaternion = class {
    constructor(x = 0, y = 0, z = 0, w = 1) {
      this.isQuaternion = true;
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
      if (t === 0) {
        dst[dstOffset + 0] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
        return;
      }
      if (t === 1) {
        dst[dstOffset + 0] = x1;
        dst[dstOffset + 1] = y1;
        dst[dstOffset + 2] = z1;
        dst[dstOffset + 3] = w1;
        return;
      }
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        let s = 1 - t;
        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
        if (sqrSin > Number.EPSILON) {
          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
          s = Math.sin(s * len) / sin;
          t = Math.sin(t * len) / sin;
        }
        const tDir = t * dir;
        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir;
        if (s === 1 - t) {
          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      const x0 = src0[srcOffset0];
      const y0 = src0[srcOffset0 + 1];
      const z0 = src0[srcOffset0 + 2];
      const w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1];
      const y1 = src1[srcOffset1 + 1];
      const z1 = src1[srcOffset1 + 2];
      const w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(value) {
      this._w = value;
      this._onChangeCallback();
    }
    set(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this._onChangeCallback();
      return this;
    }
    setFromEuler(euler, update = true) {
      const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
      const cos = Math.cos;
      const sin = Math.sin;
      const c1 = cos(x / 2);
      const c2 = cos(y / 2);
      const c3 = cos(z / 2);
      const s1 = sin(x / 2);
      const s2 = sin(y / 2);
      const s3 = sin(z / 2);
      switch (order) {
        case "XYZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "YXZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "ZXY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "ZYX":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "YZX":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "XZY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
      }
      if (update === true)
        this._onChangeCallback();
      return this;
    }
    setFromAxisAngle(axis, angle) {
      const halfAngle = angle / 2, s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m) {
      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
      if (trace > 0) {
        const s = 0.5 / Math.sqrt(trace + 1);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this._w = (m32 - m23) / s;
        this._x = 0.25 * s;
        this._y = (m12 + m21) / s;
        this._z = (m13 + m31) / s;
      } else if (m22 > m33) {
        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this._w = (m13 - m31) / s;
        this._x = (m12 + m21) / s;
        this._y = 0.25 * s;
        this._z = (m23 + m32) / s;
      } else {
        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this._w = (m21 - m12) / s;
        this._x = (m13 + m31) / s;
        this._y = (m23 + m32) / s;
        this._z = 0.25 * s;
      }
      this._onChangeCallback();
      return this;
    }
    setFromUnitVectors(vFrom, vTo) {
      let r = vFrom.dot(vTo) + 1;
      if (r < Number.EPSILON) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }
      return this.normalize();
    }
    angleTo(q) {
      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
      const angle = this.angleTo(q);
      if (angle === 0)
        return this;
      const t = Math.min(1, step / angle);
      this.slerp(q, t);
      return this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    }
    dot(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this._onChangeCallback();
      return this;
    }
    multiply(q) {
      return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
      return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this._onChangeCallback();
      return this;
    }
    slerp(qb, t) {
      if (t === 0)
        return this;
      if (t === 1)
        return this.copy(qb);
      const x = this._x, y = this._y, z = this._z, w = this._w;
      let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1) {
        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;
        return this;
      }
      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        const s = 1 - t;
        this._w = s * w + t * this._w;
        this._x = s * x + t * this._x;
        this._y = s * y + t * this._y;
        this._z = s * z + t * this._z;
        this.normalize();
        return this;
      }
      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;
      this._onChangeCallback();
      return this;
    }
    slerpQuaternions(qa, qb, t) {
      return this.copy(qa).slerp(qb, t);
    }
    random() {
      const theta1 = 2 * Math.PI * Math.random();
      const theta2 = 2 * Math.PI * Math.random();
      const x0 = Math.random();
      const r1 = Math.sqrt(1 - x0);
      const r2 = Math.sqrt(x0);
      return this.set(
        r1 * Math.sin(theta1),
        r1 * Math.cos(theta1),
        r2 * Math.sin(theta2),
        r2 * Math.cos(theta2)
      );
    }
    equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this._x = attribute.getX(index);
      this._y = attribute.getY(index);
      this._z = attribute.getZ(index);
      this._w = attribute.getW(index);
      this._onChangeCallback();
      return this;
    }
    toJSON() {
      return this.toArray();
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x;
      yield this._y;
      yield this._z;
      yield this._w;
    }
  };
  var Vector3 = class {
    constructor(x = 0, y = 0, z = 0) {
      Vector3.prototype.isVector3 = true;
      this.x = x;
      this.y = y;
      this.z = z;
    }
    set(x, y, z) {
      if (z === void 0)
        z = this.z;
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setZ(z) {
      this.z = z;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    }
    add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    }
    sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
    multiplyVectors(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    }
    applyEuler(euler) {
      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    }
    applyNormalMatrix(m) {
      return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
    applyQuaternion(q) {
      const vx = this.x, vy = this.y, vz = this.z;
      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
      const tx = 2 * (qy * vz - qz * vy);
      const ty = 2 * (qz * vx - qx * vz);
      const tz = 2 * (qx * vy - qy * vx);
      this.x = vx + qw * tx + qy * tz - qz * ty;
      this.y = vy + qw * ty + qz * tx - qx * tz;
      this.z = vz + qw * tz + qx * ty - qy * tx;
      return this;
    }
    project(camera) {
      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
    clamp(min, max) {
      this.x = clamp(this.x, min.x, max.x);
      this.y = clamp(this.y, min.y, max.y);
      this.z = clamp(this.z, min.z, max.z);
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = clamp(this.x, minVal, maxVal);
      this.y = clamp(this.y, minVal, maxVal);
      this.z = clamp(this.z, minVal, maxVal);
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
    roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      this.z = Math.trunc(this.z);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    // TODO lengthSquared?
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
    cross(v) {
      return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
      const ax = a.x, ay = a.y, az = a.z;
      const bx = b.x, by = b.y, bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
    projectOnVector(v) {
      const denominator = v.lengthSq();
      if (denominator === 0)
        return this.set(0, 0, 0);
      const scalar = v.dot(this) / denominator;
      return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
      _vector$c.copy(this).projectOnVector(planeNormal);
      return this.sub(_vector$c);
    }
    reflect(normal) {
      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0)
        return Math.PI / 2;
      const theta = this.dot(v) / denominator;
      return Math.acos(clamp(theta, -1, 1));
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
      const sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
    setFromCylindrical(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    }
    setFromMatrixPosition(m) {
      const e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    }
    setFromMatrixScale(m) {
      const sx = this.setFromMatrixColumn(m, 0).length();
      const sy = this.setFromMatrixColumn(m, 1).length();
      const sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
    setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
      return this.fromArray(m.elements, index * 3);
    }
    setFromEuler(e) {
      this.x = e._x;
      this.y = e._y;
      this.z = e._z;
      return this;
    }
    setFromColor(c) {
      this.x = c.r;
      this.y = c.g;
      this.z = c.b;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
    randomDirection() {
      const theta = Math.random() * Math.PI * 2;
      const u = Math.random() * 2 - 1;
      const c = Math.sqrt(1 - u * u);
      this.x = c * Math.cos(theta);
      this.y = u;
      this.z = c * Math.sin(theta);
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
    }
  };
  var _vector$c = /* @__PURE__ */ new Vector3();
  var _quaternion$4 = /* @__PURE__ */ new Quaternion();
  var Box3 = class {
    constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
      this.isBox3 = true;
      this.min = min;
      this.max = max;
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromArray(array) {
      this.makeEmpty();
      for (let i = 0, il = array.length; i < il; i += 3) {
        this.expandByPoint(_vector$b.fromArray(array, i));
      }
      return this;
    }
    setFromBufferAttribute(attribute) {
      this.makeEmpty();
      for (let i = 0, il = attribute.count; i < il; i++) {
        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
      }
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
    setFromCenterAndSize(center, size) {
      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    setFromObject(object, precise = false) {
      this.makeEmpty();
      return this.expandByObject(object, precise);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    expandByObject(object, precise = false) {
      object.updateWorldMatrix(false, false);
      const geometry = object.geometry;
      if (geometry !== void 0) {
        const positionAttribute = geometry.getAttribute("position");
        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
          for (let i = 0, l = positionAttribute.count; i < l; i++) {
            if (object.isMesh === true) {
              object.getVertexPosition(i, _vector$b);
            } else {
              _vector$b.fromBufferAttribute(positionAttribute, i);
            }
            _vector$b.applyMatrix4(object.matrixWorld);
            this.expandByPoint(_vector$b);
          }
        } else {
          if (object.boundingBox !== void 0) {
            if (object.boundingBox === null) {
              object.computeBoundingBox();
            }
            _box$4.copy(object.boundingBox);
          } else {
            if (geometry.boundingBox === null) {
              geometry.computeBoundingBox();
            }
            _box$4.copy(geometry.boundingBox);
          }
          _box$4.applyMatrix4(object.matrixWorld);
          this.union(_box$4);
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        this.expandByObject(children[i], precise);
      }
      return this;
    }
    containsPoint(point) {
      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
      return target.set(
        (point.x - this.min.x) / (this.max.x - this.min.x),
        (point.y - this.min.y) / (this.max.y - this.min.y),
        (point.z - this.min.z) / (this.max.z - this.min.z)
      );
    }
    intersectsBox(box) {
      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
    }
    intersectsSphere(sphere) {
      this.clampPoint(sphere.center, _vector$b);
      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
      let min, max;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max >= -plane.constant;
    }
    intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(_center);
      _extents.subVectors(this.max, _center);
      _v0$2.subVectors(triangle.a, _center);
      _v1$7.subVectors(triangle.b, _center);
      _v2$4.subVectors(triangle.c, _center);
      _f0.subVectors(_v1$7, _v0$2);
      _f1.subVectors(_v2$4, _v1$7);
      _f2.subVectors(_v0$2, _v2$4);
      let axes = [
        0,
        -_f0.z,
        _f0.y,
        0,
        -_f1.z,
        _f1.y,
        0,
        -_f2.z,
        _f2.y,
        _f0.z,
        0,
        -_f0.x,
        _f1.z,
        0,
        -_f1.x,
        _f2.z,
        0,
        -_f2.x,
        -_f0.y,
        _f0.x,
        0,
        -_f1.y,
        _f1.x,
        0,
        -_f2.y,
        _f2.x,
        0
      ];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
        return false;
      }
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
        return false;
      }
      _triangleNormal.crossVectors(_f0, _f1);
      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
    }
    clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      return this.clampPoint(point, _vector$b).distanceTo(point);
    }
    getBoundingSphere(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
      } else {
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$b).length() * 0.5;
      }
      return target;
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty())
        this.makeEmpty();
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    applyMatrix4(matrix) {
      if (this.isEmpty())
        return this;
      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.setFromPoints(_points);
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  var _points = [
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3()
  ];
  var _vector$b = /* @__PURE__ */ new Vector3();
  var _box$4 = /* @__PURE__ */ new Box3();
  var _v0$2 = /* @__PURE__ */ new Vector3();
  var _v1$7 = /* @__PURE__ */ new Vector3();
  var _v2$4 = /* @__PURE__ */ new Vector3();
  var _f0 = /* @__PURE__ */ new Vector3();
  var _f1 = /* @__PURE__ */ new Vector3();
  var _f2 = /* @__PURE__ */ new Vector3();
  var _center = /* @__PURE__ */ new Vector3();
  var _extents = /* @__PURE__ */ new Vector3();
  var _triangleNormal = /* @__PURE__ */ new Vector3();
  var _testAxis = /* @__PURE__ */ new Vector3();
  function satForAxes(axes, v0, v1, v2, extents) {
    for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
      _testAxis.fromArray(axes, i);
      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p2 = v2.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
        return false;
      }
    }
    return true;
  }
  var _box$3 = /* @__PURE__ */ new Box3();
  var _v1$6 = /* @__PURE__ */ new Vector3();
  var _v2$3 = /* @__PURE__ */ new Vector3();
  var Sphere = class {
    constructor(center = new Vector3(), radius = -1) {
      this.isSphere = true;
      this.center = center;
      this.radius = radius;
    }
    set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    }
    setFromPoints(points, optionalCenter) {
      const center = this.center;
      if (optionalCenter !== void 0) {
        center.copy(optionalCenter);
      } else {
        _box$3.setFromPoints(points).getCenter(center);
      }
      let maxRadiusSq = 0;
      for (let i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    }
    copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      this.center.set(0, 0, 0);
      this.radius = -1;
      return this;
    }
    containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
      const radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
      return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
      const deltaLengthSq = this.center.distanceToSquared(point);
      target.copy(point);
      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }
      return target;
    }
    getBoundingBox(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
        return target;
      }
      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    }
    applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    }
    translate(offset) {
      this.center.add(offset);
      return this;
    }
    expandByPoint(point) {
      if (this.isEmpty()) {
        this.center.copy(point);
        this.radius = 0;
        return this;
      }
      _v1$6.subVectors(point, this.center);
      const lengthSq = _v1$6.lengthSq();
      if (lengthSq > this.radius * this.radius) {
        const length = Math.sqrt(lengthSq);
        const delta = (length - this.radius) * 0.5;
        this.center.addScaledVector(_v1$6, delta / length);
        this.radius += delta;
      }
      return this;
    }
    union(sphere) {
      if (sphere.isEmpty()) {
        return this;
      }
      if (this.isEmpty()) {
        this.copy(sphere);
        return this;
      }
      if (this.center.equals(sphere.center) === true) {
        this.radius = Math.max(this.radius, sphere.radius);
      } else {
        _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
        this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
        this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
      }
      return this;
    }
    equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _vector$a = /* @__PURE__ */ new Vector3();
  var _segCenter = /* @__PURE__ */ new Vector3();
  var _segDir = /* @__PURE__ */ new Vector3();
  var _diff = /* @__PURE__ */ new Vector3();
  var _edge1 = /* @__PURE__ */ new Vector3();
  var _edge2 = /* @__PURE__ */ new Vector3();
  var _normal$1 = /* @__PURE__ */ new Vector3();
  var Ray = class {
    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
      this.origin = origin;
      this.direction = direction;
    }
    set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    }
    copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    }
    at(t, target) {
      return target.copy(this.origin).addScaledVector(this.direction, t);
    }
    lookAt(v) {
      this.direction.copy(v).sub(this.origin).normalize();
      return this;
    }
    recast(t) {
      this.origin.copy(this.at(t, _vector$a));
      return this;
    }
    closestPointToPoint(point, target) {
      target.subVectors(point, this.origin);
      const directionDistance = target.dot(this.direction);
      if (directionDistance < 0) {
        return target.copy(this.origin);
      }
      return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
    }
    distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
      return _vector$a.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      _segDir.copy(v1).sub(v0).normalize();
      _diff.copy(this.origin).sub(_segCenter);
      const segExtent = v0.distanceTo(v1) * 0.5;
      const a01 = -this.direction.dot(_segDir);
      const b0 = _diff.dot(this.direction);
      const b1 = -_diff.dot(_segDir);
      const c = _diff.lengthSq();
      const det = Math.abs(1 - a01 * a01);
      let s0, s1, sqrDist, extDet;
      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              const invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
      }
      return sqrDist;
    }
    intersectSphere(sphere, target) {
      _vector$a.subVectors(sphere.center, this.origin);
      const tca = _vector$a.dot(this.direction);
      const d2 = _vector$a.dot(_vector$a) - tca * tca;
      const radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2)
        return null;
      const thc = Math.sqrt(radius2 - d2);
      const t0 = tca - thc;
      const t1 = tca + thc;
      if (t1 < 0)
        return null;
      if (t0 < 0)
        return this.at(t1, target);
      return this.at(t0, target);
    }
    intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
      const denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }
        return null;
      }
      const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
      return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {
      const t = this.distanceToPlane(plane);
      if (t === null) {
        return null;
      }
      return this.at(t, target);
    }
    intersectsPlane(plane) {
      const distToPoint = plane.distanceToPoint(this.origin);
      if (distToPoint === 0) {
        return true;
      }
      const denominator = plane.normal.dot(this.direction);
      if (denominator * distToPoint < 0) {
        return true;
      }
      return false;
    }
    intersectBox(box, target) {
      let tmin, tmax, tymin, tymax, tzmin, tzmax;
      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
      const origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if (tmin > tymax || tymin > tmax)
        return null;
      if (tymin > tmin || isNaN(tmin))
        tmin = tymin;
      if (tymax < tmax || isNaN(tmax))
        tmax = tymax;
      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }
      if (tmin > tzmax || tzmin > tmax)
        return null;
      if (tzmin > tmin || tmin !== tmin)
        tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax)
        tmax = tzmax;
      if (tmax < 0)
        return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
      return this.intersectBox(box, _vector$a) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {
      _edge1.subVectors(b, a);
      _edge2.subVectors(c, a);
      _normal$1.crossVectors(_edge1, _edge2);
      let DdN = this.direction.dot(_normal$1);
      let sign;
      if (DdN > 0) {
        if (backfaceCulling)
          return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      _diff.subVectors(this.origin, a);
      const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      const QdN = -sign * _diff.dot(_normal$1);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    }
    equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var Matrix4 = class {
    constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      Matrix4.prototype.isMatrix4 = true;
      this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
      if (n11 !== void 0) {
        this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
      }
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      const te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    }
    identity() {
      this.set(
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    clone() {
      return new Matrix4().fromArray(this.elements);
    }
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      te[9] = me[9];
      te[10] = me[10];
      te[11] = me[11];
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      te[15] = me[15];
      return this;
    }
    copyPosition(m) {
      const te = this.elements, me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    }
    setFromMatrix3(m) {
      const me = m.elements;
      this.set(
        me[0],
        me[3],
        me[6],
        0,
        me[1],
        me[4],
        me[7],
        0,
        me[2],
        me[5],
        me[8],
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
      this.set(
        xAxis.x,
        yAxis.x,
        zAxis.x,
        0,
        xAxis.y,
        yAxis.y,
        zAxis.y,
        0,
        xAxis.z,
        yAxis.z,
        zAxis.z,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    extractRotation(m) {
      const te = this.elements;
      const me = m.elements;
      const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
      const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromEuler(euler) {
      const te = this.elements;
      const x = euler.x, y = euler.y, z = euler.z;
      const a = Math.cos(x), b = Math.sin(x);
      const c = Math.cos(y), d = Math.sin(y);
      const e = Math.cos(z), f = Math.sin(z);
      if (euler.order === "XYZ") {
        const ae = a * e, af = a * f, be = b * e, bf = b * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler.order === "YXZ") {
        const ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce + df * b;
        te[4] = de * b - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b;
        te[2] = cf * b - de;
        te[6] = df + ce * b;
        te[10] = a * c;
      } else if (euler.order === "ZXY") {
        const ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce - df * b;
        te[4] = -a * f;
        te[8] = de + cf * b;
        te[1] = cf + de * b;
        te[5] = a * e;
        te[9] = df - ce * b;
        te[2] = -a * d;
        te[6] = b;
        te[10] = a * c;
      } else if (euler.order === "ZYX") {
        const ae = a * e, af = a * f, be = b * e, bf = b * f;
        te[0] = c * e;
        te[4] = be * d - af;
        te[8] = ae * d + bf;
        te[1] = c * f;
        te[5] = bf * d + ae;
        te[9] = af * d - be;
        te[2] = -d;
        te[6] = b * c;
        te[10] = a * c;
      } else if (euler.order === "YZX") {
        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler.order === "XZY") {
        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = ac * f + bd;
        te[5] = a * e;
        te[9] = ad * f - bc;
        te[2] = bc * f - ad;
        te[6] = b * e;
        te[10] = bd * f + ac;
      }
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromQuaternion(q) {
      return this.compose(_zero, q, _one);
    }
    lookAt(eye, target, up) {
      const te = this.elements;
      _z.subVectors(eye, target);
      if (_z.lengthSq() === 0) {
        _z.z = 1;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
      if (_x.lengthSq() === 0) {
        if (Math.abs(up.z) === 1) {
          _z.x += 1e-4;
        } else {
          _z.z += 1e-4;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
      }
      _x.normalize();
      _y.crossVectors(_z, _x);
      te[0] = _x.x;
      te[4] = _y.x;
      te[8] = _z.x;
      te[1] = _x.y;
      te[5] = _y.y;
      te[9] = _z.y;
      te[2] = _x.z;
      te[6] = _y.z;
      te[10] = _z.z;
      return this;
    }
    multiply(m) {
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
      const ae = a.elements;
      const be = b.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[4] *= s;
      te[8] *= s;
      te[12] *= s;
      te[1] *= s;
      te[5] *= s;
      te[9] *= s;
      te[13] *= s;
      te[2] *= s;
      te[6] *= s;
      te[10] *= s;
      te[14] *= s;
      te[3] *= s;
      te[7] *= s;
      te[11] *= s;
      te[15] *= s;
      return this;
    }
    determinant() {
      const te = this.elements;
      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
      const te = this.elements;
      let tmp;
      tmp = te[1];
      te[1] = te[4];
      te[4] = tmp;
      tmp = te[2];
      te[2] = te[8];
      te[8] = tmp;
      tmp = te[6];
      te[6] = te[9];
      te[9] = tmp;
      tmp = te[3];
      te[3] = te[12];
      te[12] = tmp;
      tmp = te[7];
      te[7] = te[13];
      te[13] = tmp;
      tmp = te[11];
      te[11] = te[14];
      te[14] = tmp;
      return this;
    }
    setPosition(x, y, z) {
      const te = this.elements;
      if (x.isVector3) {
        te[12] = x.x;
        te[13] = x.y;
        te[14] = x.z;
      } else {
        te[12] = x;
        te[13] = y;
        te[14] = z;
      }
      return this;
    }
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
    scale(v) {
      const te = this.elements;
      const x = v.x, y = v.y, z = v.z;
      te[0] *= x;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x;
      te[7] *= y;
      te[11] *= z;
      return this;
    }
    getMaxScaleOnAxis() {
      const te = this.elements;
      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
      if (x.isVector3) {
        this.set(
          1,
          0,
          0,
          x.x,
          0,
          1,
          0,
          x.y,
          0,
          0,
          1,
          x.z,
          0,
          0,
          0,
          1
        );
      } else {
        this.set(
          1,
          0,
          0,
          x,
          0,
          1,
          0,
          y,
          0,
          0,
          1,
          z,
          0,
          0,
          0,
          1
        );
      }
      return this;
    }
    makeRotationX(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(
        1,
        0,
        0,
        0,
        0,
        c,
        -s,
        0,
        0,
        s,
        c,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationY(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(
        c,
        0,
        s,
        0,
        0,
        1,
        0,
        0,
        -s,
        0,
        c,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationZ(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(
        c,
        -s,
        0,
        0,
        s,
        c,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationAxis(axis, angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      const t = 1 - c;
      const x = axis.x, y = axis.y, z = axis.z;
      const tx = t * x, ty = t * y;
      this.set(
        tx * x + c,
        tx * y - s * z,
        tx * z + s * y,
        0,
        tx * y + s * z,
        ty * y + c,
        ty * z - s * x,
        0,
        tx * z - s * y,
        ty * z + s * x,
        t * z * z + c,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeScale(x, y, z) {
      this.set(
        x,
        0,
        0,
        0,
        0,
        y,
        0,
        0,
        0,
        0,
        z,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeShear(xy, xz, yx, yz, zx, zy) {
      this.set(
        1,
        yx,
        zx,
        0,
        xy,
        1,
        zy,
        0,
        xz,
        yz,
        1,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    compose(position, quaternion, scale) {
      const te = this.elements;
      const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
      const x2 = x + x, y2 = y + y, z2 = z + z;
      const xx = x * x2, xy = x * y2, xz = x * z2;
      const yy = y * y2, yz = y * z2, zz = z * z2;
      const wx = w * x2, wy = w * y2, wz = w * z2;
      const sx = scale.x, sy = scale.y, sz = scale.z;
      te[0] = (1 - (yy + zz)) * sx;
      te[1] = (xy + wz) * sx;
      te[2] = (xz - wy) * sx;
      te[3] = 0;
      te[4] = (xy - wz) * sy;
      te[5] = (1 - (xx + zz)) * sy;
      te[6] = (yz + wx) * sy;
      te[7] = 0;
      te[8] = (xz + wy) * sz;
      te[9] = (yz - wx) * sz;
      te[10] = (1 - (xx + yy)) * sz;
      te[11] = 0;
      te[12] = position.x;
      te[13] = position.y;
      te[14] = position.z;
      te[15] = 1;
      return this;
    }
    decompose(position, quaternion, scale) {
      const te = this.elements;
      let sx = _v1$5.set(te[0], te[1], te[2]).length();
      const sy = _v1$5.set(te[4], te[5], te[6]).length();
      const sz = _v1$5.set(te[8], te[9], te[10]).length();
      const det = this.determinant();
      if (det < 0)
        sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      _m1$2.copy(this);
      const invSX = 1 / sx;
      const invSY = 1 / sy;
      const invSZ = 1 / sz;
      _m1$2.elements[0] *= invSX;
      _m1$2.elements[1] *= invSX;
      _m1$2.elements[2] *= invSX;
      _m1$2.elements[4] *= invSY;
      _m1$2.elements[5] *= invSY;
      _m1$2.elements[6] *= invSY;
      _m1$2.elements[8] *= invSZ;
      _m1$2.elements[9] *= invSZ;
      _m1$2.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(_m1$2);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    }
    makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
      const te = this.elements;
      const x = 2 * near / (right - left);
      const y = 2 * near / (top - bottom);
      const a = (right + left) / (right - left);
      const b = (top + bottom) / (top - bottom);
      let c, d;
      if (coordinateSystem === WebGLCoordinateSystem) {
        c = -(far + near) / (far - near);
        d = -2 * far * near / (far - near);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        c = -far / (far - near);
        d = -far * near / (far - near);
      } else {
        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
      }
      te[0] = x;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    }
    makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
      const te = this.elements;
      const w = 1 / (right - left);
      const h = 1 / (top - bottom);
      const p = 1 / (far - near);
      const x = (right + left) * w;
      const y = (top + bottom) * h;
      let z, zInv;
      if (coordinateSystem === WebGLCoordinateSystem) {
        z = (far + near) * p;
        zInv = -2 * p;
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        z = near * p;
        zInv = -1 * p;
      } else {
        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
      }
      te[0] = 2 * w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = 2 * h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = zInv;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    }
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i = 0; i < 16; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < 16; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
  };
  var _v1$5 = /* @__PURE__ */ new Vector3();
  var _m1$2 = /* @__PURE__ */ new Matrix4();
  var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
  var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
  var _x = /* @__PURE__ */ new Vector3();
  var _y = /* @__PURE__ */ new Vector3();
  var _z = /* @__PURE__ */ new Vector3();
  var _matrix$2 = /* @__PURE__ */ new Matrix4();
  var _quaternion$3 = /* @__PURE__ */ new Quaternion();
  var Euler = class {
    constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
      this.isEuler = true;
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(value) {
      this._order = value;
      this._onChangeCallback();
    }
    set(x, y, z, order = this._order) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m, order = this._order, update = true) {
      const te = m.elements;
      const m11 = te[0], m12 = te[4], m13 = te[8];
      const m21 = te[1], m22 = te[5], m23 = te[9];
      const m31 = te[2], m32 = te[6], m33 = te[10];
      switch (order) {
        case "XYZ":
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.9999999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
          break;
        case "YXZ":
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.9999999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
          break;
        case "ZXY":
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.9999999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
          break;
        case "ZYX":
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.9999999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
          break;
        case "YZX":
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.9999999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
          break;
        case "XZY":
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.9999999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
      }
      this._order = order;
      if (update === true)
        this._onChangeCallback();
      return this;
    }
    setFromQuaternion(q, order, update) {
      _matrix$2.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(_matrix$2, order, update);
    }
    setFromVector3(v, order = this._order) {
      return this.set(v.x, v.y, v.z, order);
    }
    reorder(newOrder) {
      _quaternion$3.setFromEuler(this);
      return this.setFromQuaternion(_quaternion$3, newOrder);
    }
    equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== void 0)
        this._order = array[3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x;
      yield this._y;
      yield this._z;
      yield this._order;
    }
  };
  Euler.DEFAULT_ORDER = "XYZ";
  var Layers = class {
    constructor() {
      this.mask = 1 | 0;
    }
    set(channel) {
      this.mask = (1 << channel | 0) >>> 0;
    }
    enable(channel) {
      this.mask |= 1 << channel | 0;
    }
    enableAll() {
      this.mask = 4294967295 | 0;
    }
    toggle(channel) {
      this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
      this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(layers) {
      return (this.mask & layers.mask) !== 0;
    }
    isEnabled(channel) {
      return (this.mask & (1 << channel | 0)) !== 0;
    }
  };
  var _object3DId = 0;
  var _v1$4 = /* @__PURE__ */ new Vector3();
  var _q1 = /* @__PURE__ */ new Quaternion();
  var _m1$1 = /* @__PURE__ */ new Matrix4();
  var _target = /* @__PURE__ */ new Vector3();
  var _position$3 = /* @__PURE__ */ new Vector3();
  var _scale$2 = /* @__PURE__ */ new Vector3();
  var _quaternion$2 = /* @__PURE__ */ new Quaternion();
  var _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
  var _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
  var _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
  var _addedEvent = { type: "added" };
  var _removedEvent = { type: "removed" };
  var _childaddedEvent = { type: "childadded", child: null };
  var _childremovedEvent = { type: "childremoved", child: null };
  var Object3D = class extends EventDispatcher {
    constructor() {
      super();
      this.isObject3D = true;
      Object.defineProperty(this, "id", { value: _object3DId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "Object3D";
      this.parent = null;
      this.children = [];
      this.up = Object3D.DEFAULT_UP.clone();
      const position = new Vector3();
      const rotation = new Euler();
      const quaternion = new Quaternion();
      const scale = new Vector3(1, 1, 1);
      function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
      }
      function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, void 0, false);
      }
      rotation._onChange(onRotationChange);
      quaternion._onChange(onQuaternionChange);
      Object.defineProperties(this, {
        position: {
          configurable: true,
          enumerable: true,
          value: position
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: rotation
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: quaternion
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: scale
        },
        modelViewMatrix: {
          value: new Matrix4()
        },
        normalMatrix: {
          value: new Matrix3()
        }
      });
      this.matrix = new Matrix4();
      this.matrixWorld = new Matrix4();
      this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
      this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
      this.matrixWorldNeedsUpdate = false;
      this.layers = new Layers();
      this.visible = true;
      this.castShadow = false;
      this.receiveShadow = false;
      this.frustumCulled = true;
      this.renderOrder = 0;
      this.animations = [];
      this.userData = {};
    }
    onBeforeShadow() {
    }
    onAfterShadow() {
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(matrix) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      this.matrix.premultiply(matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(q) {
      this.quaternion.premultiply(q);
      return this;
    }
    setRotationFromAxisAngle(axis, angle) {
      this.quaternion.setFromAxisAngle(axis, angle);
    }
    setRotationFromEuler(euler) {
      this.quaternion.setFromEuler(euler, true);
    }
    setRotationFromMatrix(m) {
      this.quaternion.setFromRotationMatrix(m);
    }
    setRotationFromQuaternion(q) {
      this.quaternion.copy(q);
    }
    rotateOnAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(_q1);
      return this;
    }
    rotateOnWorldAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(_q1);
      return this;
    }
    rotateX(angle) {
      return this.rotateOnAxis(_xAxis, angle);
    }
    rotateY(angle) {
      return this.rotateOnAxis(_yAxis, angle);
    }
    rotateZ(angle) {
      return this.rotateOnAxis(_zAxis, angle);
    }
    translateOnAxis(axis, distance) {
      _v1$4.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(_v1$4.multiplyScalar(distance));
      return this;
    }
    translateX(distance) {
      return this.translateOnAxis(_xAxis, distance);
    }
    translateY(distance) {
      return this.translateOnAxis(_yAxis, distance);
    }
    translateZ(distance) {
      return this.translateOnAxis(_zAxis, distance);
    }
    localToWorld(vector) {
      this.updateWorldMatrix(true, false);
      return vector.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(vector) {
      this.updateWorldMatrix(true, false);
      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
    }
    lookAt(x, y, z) {
      if (x.isVector3) {
        _target.copy(x);
      } else {
        _target.set(x, y, z);
      }
      const parent = this.parent;
      this.updateWorldMatrix(true, false);
      _position$3.setFromMatrixPosition(this.matrixWorld);
      if (this.isCamera || this.isLight) {
        _m1$1.lookAt(_position$3, _target, this.up);
      } else {
        _m1$1.lookAt(_target, _position$3, this.up);
      }
      this.quaternion.setFromRotationMatrix(_m1$1);
      if (parent) {
        _m1$1.extractRotation(parent.matrixWorld);
        _q1.setFromRotationMatrix(_m1$1);
        this.quaternion.premultiply(_q1.invert());
      }
    }
    add(object) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (object === this) {
        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
        return this;
      }
      if (object && object.isObject3D) {
        object.removeFromParent();
        object.parent = this;
        this.children.push(object);
        object.dispatchEvent(_addedEvent);
        _childaddedEvent.child = object;
        this.dispatchEvent(_childaddedEvent);
        _childaddedEvent.child = null;
      } else {
        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
      }
      return this;
    }
    remove(object) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) {
          this.remove(arguments[i]);
        }
        return this;
      }
      const index = this.children.indexOf(object);
      if (index !== -1) {
        object.parent = null;
        this.children.splice(index, 1);
        object.dispatchEvent(_removedEvent);
        _childremovedEvent.child = object;
        this.dispatchEvent(_childremovedEvent);
        _childremovedEvent.child = null;
      }
      return this;
    }
    removeFromParent() {
      const parent = this.parent;
      if (parent !== null) {
        parent.remove(this);
      }
      return this;
    }
    clear() {
      return this.remove(...this.children);
    }
    attach(object) {
      this.updateWorldMatrix(true, false);
      _m1$1.copy(this.matrixWorld).invert();
      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);
        _m1$1.multiply(object.parent.matrixWorld);
      }
      object.applyMatrix4(_m1$1);
      object.removeFromParent();
      object.parent = this;
      this.children.push(object);
      object.updateWorldMatrix(false, true);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
      return this;
    }
    getObjectById(id) {
      return this.getObjectByProperty("id", id);
    }
    getObjectByName(name) {
      return this.getObjectByProperty("name", name);
    }
    getObjectByProperty(name, value) {
      if (this[name] === value)
        return this;
      for (let i = 0, l = this.children.length; i < l; i++) {
        const child = this.children[i];
        const object = child.getObjectByProperty(name, value);
        if (object !== void 0) {
          return object;
        }
      }
      return void 0;
    }
    getObjectsByProperty(name, value, result = []) {
      if (this[name] === value)
        result.push(this);
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].getObjectsByProperty(name, value, result);
      }
      return result;
    }
    getWorldPosition(target) {
      this.updateWorldMatrix(true, false);
      return target.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, target, _scale$2);
      return target;
    }
    getWorldScale(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, _quaternion$2, target);
      return target;
    }
    getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      const e = this.matrixWorld.elements;
      return target.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {
    }
    traverse(callback) {
      callback(this);
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].traverse(callback);
      }
    }
    traverseVisible(callback) {
      if (this.visible === false)
        return;
      callback(this);
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].traverseVisible(callback);
      }
    }
    traverseAncestors(callback) {
      const parent = this.parent;
      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(force) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || force) {
        if (this.matrixWorldAutoUpdate === true) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
        }
        this.matrixWorldNeedsUpdate = false;
        force = true;
      }
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        child.updateMatrixWorld(force);
      }
    }
    updateWorldMatrix(updateParents, updateChildren) {
      const parent = this.parent;
      if (updateParents === true && parent !== null) {
        parent.updateWorldMatrix(true, false);
      }
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.matrixWorldAutoUpdate === true) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
      }
      if (updateChildren === true) {
        const children = this.children;
        for (let i = 0, l = children.length; i < l; i++) {
          const child = children[i];
          child.updateWorldMatrix(false, true);
        }
      }
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      const output = {};
      if (isRootObject) {
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {}
        };
        output.metadata = {
          version: 4.6,
          type: "Object",
          generator: "Object3D.toJSON"
        };
      }
      const object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== "")
        object.name = this.name;
      if (this.castShadow === true)
        object.castShadow = true;
      if (this.receiveShadow === true)
        object.receiveShadow = true;
      if (this.visible === false)
        object.visible = false;
      if (this.frustumCulled === false)
        object.frustumCulled = false;
      if (this.renderOrder !== 0)
        object.renderOrder = this.renderOrder;
      if (Object.keys(this.userData).length > 0)
        object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      object.up = this.up.toArray();
      if (this.matrixAutoUpdate === false)
        object.matrixAutoUpdate = false;
      if (this.isInstancedMesh) {
        object.type = "InstancedMesh";
        object.count = this.count;
        object.instanceMatrix = this.instanceMatrix.toJSON();
        if (this.instanceColor !== null)
          object.instanceColor = this.instanceColor.toJSON();
      }
      if (this.isBatchedMesh) {
        object.type = "BatchedMesh";
        object.perObjectFrustumCulled = this.perObjectFrustumCulled;
        object.sortObjects = this.sortObjects;
        object.drawRanges = this._drawRanges;
        object.reservedRanges = this._reservedRanges;
        object.visibility = this._visibility;
        object.active = this._active;
        object.bounds = this._bounds.map((bound) => ({
          boxInitialized: bound.boxInitialized,
          boxMin: bound.box.min.toArray(),
          boxMax: bound.box.max.toArray(),
          sphereInitialized: bound.sphereInitialized,
          sphereRadius: bound.sphere.radius,
          sphereCenter: bound.sphere.center.toArray()
        }));
        object.maxInstanceCount = this._maxInstanceCount;
        object.maxVertexCount = this._maxVertexCount;
        object.maxIndexCount = this._maxIndexCount;
        object.geometryInitialized = this._geometryInitialized;
        object.geometryCount = this._geometryCount;
        object.matricesTexture = this._matricesTexture.toJSON(meta);
        if (this._colorsTexture !== null)
          object.colorsTexture = this._colorsTexture.toJSON(meta);
        if (this.boundingSphere !== null) {
          object.boundingSphere = {
            center: object.boundingSphere.center.toArray(),
            radius: object.boundingSphere.radius
          };
        }
        if (this.boundingBox !== null) {
          object.boundingBox = {
            min: object.boundingBox.min.toArray(),
            max: object.boundingBox.max.toArray()
          };
        }
      }
      function serialize(library, element) {
        if (library[element.uuid] === void 0) {
          library[element.uuid] = element.toJSON(meta);
        }
        return element.uuid;
      }
      if (this.isScene) {
        if (this.background) {
          if (this.background.isColor) {
            object.background = this.background.toJSON();
          } else if (this.background.isTexture) {
            object.background = this.background.toJSON(meta).uuid;
          }
        }
        if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
          object.environment = this.environment.toJSON(meta).uuid;
        }
      } else if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        const parameters = this.geometry.parameters;
        if (parameters !== void 0 && parameters.shapes !== void 0) {
          const shapes = parameters.shapes;
          if (Array.isArray(shapes)) {
            for (let i = 0, l = shapes.length; i < l; i++) {
              const shape = shapes[i];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }
      if (this.isSkinnedMesh) {
        object.bindMode = this.bindMode;
        object.bindMatrix = this.bindMatrix.toArray();
        if (this.skeleton !== void 0) {
          serialize(meta.skeletons, this.skeleton);
          object.skeleton = this.skeleton.uuid;
        }
      }
      if (this.material !== void 0) {
        if (Array.isArray(this.material)) {
          const uuids = [];
          for (let i = 0, l = this.material.length; i < l; i++) {
            uuids.push(serialize(meta.materials, this.material[i]));
          }
          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      }
      if (this.children.length > 0) {
        object.children = [];
        for (let i = 0; i < this.children.length; i++) {
          object.children.push(this.children[i].toJSON(meta).object);
        }
      }
      if (this.animations.length > 0) {
        object.animations = [];
        for (let i = 0; i < this.animations.length; i++) {
          const animation = this.animations[i];
          object.animations.push(serialize(meta.animations, animation));
        }
      }
      if (isRootObject) {
        const geometries = extractFromCache(meta.geometries);
        const materials = extractFromCache(meta.materials);
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        const shapes = extractFromCache(meta.shapes);
        const skeletons = extractFromCache(meta.skeletons);
        const animations = extractFromCache(meta.animations);
        const nodes = extractFromCache(meta.nodes);
        if (geometries.length > 0)
          output.geometries = geometries;
        if (materials.length > 0)
          output.materials = materials;
        if (textures.length > 0)
          output.textures = textures;
        if (images.length > 0)
          output.images = images;
        if (shapes.length > 0)
          output.shapes = shapes;
        if (skeletons.length > 0)
          output.skeletons = skeletons;
        if (animations.length > 0)
          output.animations = animations;
        if (nodes.length > 0)
          output.nodes = nodes;
      }
      output.object = object;
      return output;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data = cache[key];
          delete data.metadata;
          values.push(data);
        }
        return values;
      }
    }
    clone(recursive) {
      return new this.constructor().copy(this, recursive);
    }
    copy(source, recursive = true) {
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.rotation.order = source.rotation.order;
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.animations = source.animations.slice();
      this.userData = JSON.parse(JSON.stringify(source.userData));
      if (recursive === true) {
        for (let i = 0; i < source.children.length; i++) {
          const child = source.children[i];
          this.add(child.clone());
        }
      }
      return this;
    }
  };
  Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
  var _v0$1 = /* @__PURE__ */ new Vector3();
  var _v1$3 = /* @__PURE__ */ new Vector3();
  var _v2$2 = /* @__PURE__ */ new Vector3();
  var _v3$2 = /* @__PURE__ */ new Vector3();
  var _vab = /* @__PURE__ */ new Vector3();
  var _vac = /* @__PURE__ */ new Vector3();
  var _vbc = /* @__PURE__ */ new Vector3();
  var _vap = /* @__PURE__ */ new Vector3();
  var _vbp = /* @__PURE__ */ new Vector3();
  var _vcp = /* @__PURE__ */ new Vector3();
  var _v40 = /* @__PURE__ */ new Vector4();
  var _v41 = /* @__PURE__ */ new Vector4();
  var _v42 = /* @__PURE__ */ new Vector4();
  var Triangle = class {
    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
      this.a = a;
      this.b = b;
      this.c = c;
    }
    static getNormal(a, b, c, target) {
      target.subVectors(c, b);
      _v0$1.subVectors(a, b);
      target.cross(_v0$1);
      const targetLengthSq = target.lengthSq();
      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }
      return target.set(0, 0, 0);
    }
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    static getBarycoord(point, a, b, c, target) {
      _v0$1.subVectors(c, a);
      _v1$3.subVectors(b, a);
      _v2$2.subVectors(point, a);
      const dot00 = _v0$1.dot(_v0$1);
      const dot01 = _v0$1.dot(_v1$3);
      const dot02 = _v0$1.dot(_v2$2);
      const dot11 = _v1$3.dot(_v1$3);
      const dot12 = _v1$3.dot(_v2$2);
      const denom = dot00 * dot11 - dot01 * dot01;
      if (denom === 0) {
        target.set(0, 0, 0);
        return null;
      }
      const invDenom = 1 / denom;
      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return target.set(1 - u - v, v, u);
    }
    static containsPoint(point, a, b, c) {
      if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
        return false;
      }
      return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
    }
    static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
      if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
        target.x = 0;
        target.y = 0;
        if ("z" in target)
          target.z = 0;
        if ("w" in target)
          target.w = 0;
        return null;
      }
      target.setScalar(0);
      target.addScaledVector(v1, _v3$2.x);
      target.addScaledVector(v2, _v3$2.y);
      target.addScaledVector(v3, _v3$2.z);
      return target;
    }
    static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {
      _v40.setScalar(0);
      _v41.setScalar(0);
      _v42.setScalar(0);
      _v40.fromBufferAttribute(attr, i1);
      _v41.fromBufferAttribute(attr, i2);
      _v42.fromBufferAttribute(attr, i3);
      target.setScalar(0);
      target.addScaledVector(_v40, barycoord.x);
      target.addScaledVector(_v41, barycoord.y);
      target.addScaledVector(_v42, barycoord.z);
      return target;
    }
    static isFrontFacing(a, b, c, direction) {
      _v0$1.subVectors(c, b);
      _v1$3.subVectors(a, b);
      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
    set(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    }
    setFromAttributeAndIndices(attribute, i0, i1, i2) {
      this.a.fromBufferAttribute(attribute, i0);
      this.b.fromBufferAttribute(attribute, i1);
      this.c.fromBufferAttribute(attribute, i2);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    }
    getArea() {
      _v0$1.subVectors(this.c, this.b);
      _v1$3.subVectors(this.a, this.b);
      return _v0$1.cross(_v1$3).length() * 0.5;
    }
    getMidpoint(target) {
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
      return Triangle.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getInterpolation(point, v1, v2, v3, target) {
      return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
    }
    containsPoint(point) {
      return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
      return box.intersectsTriangle(this);
    }
    closestPointToPoint(p, target) {
      const a = this.a, b = this.b, c = this.c;
      let v, w;
      _vab.subVectors(b, a);
      _vac.subVectors(c, a);
      _vap.subVectors(p, a);
      const d1 = _vab.dot(_vap);
      const d2 = _vac.dot(_vap);
      if (d1 <= 0 && d2 <= 0) {
        return target.copy(a);
      }
      _vbp.subVectors(p, b);
      const d3 = _vab.dot(_vbp);
      const d4 = _vac.dot(_vbp);
      if (d3 >= 0 && d4 <= d3) {
        return target.copy(b);
      }
      const vc = d1 * d4 - d3 * d2;
      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3);
        return target.copy(a).addScaledVector(_vab, v);
      }
      _vcp.subVectors(p, c);
      const d5 = _vab.dot(_vcp);
      const d6 = _vac.dot(_vcp);
      if (d6 >= 0 && d5 <= d6) {
        return target.copy(c);
      }
      const vb = d5 * d2 - d1 * d6;
      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6);
        return target.copy(a).addScaledVector(_vac, w);
      }
      const va = d3 * d6 - d5 * d4;
      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        _vbc.subVectors(c, b);
        w = (d4 - d3) / (d4 - d3 + (d5 - d6));
        return target.copy(b).addScaledVector(_vbc, w);
      }
      const denom = 1 / (va + vb + vc);
      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    }
    equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  };
  var _colorKeywords = {
    "aliceblue": 15792383,
    "antiquewhite": 16444375,
    "aqua": 65535,
    "aquamarine": 8388564,
    "azure": 15794175,
    "beige": 16119260,
    "bisque": 16770244,
    "black": 0,
    "blanchedalmond": 16772045,
    "blue": 255,
    "blueviolet": 9055202,
    "brown": 10824234,
    "burlywood": 14596231,
    "cadetblue": 6266528,
    "chartreuse": 8388352,
    "chocolate": 13789470,
    "coral": 16744272,
    "cornflowerblue": 6591981,
    "cornsilk": 16775388,
    "crimson": 14423100,
    "cyan": 65535,
    "darkblue": 139,
    "darkcyan": 35723,
    "darkgoldenrod": 12092939,
    "darkgray": 11119017,
    "darkgreen": 25600,
    "darkgrey": 11119017,
    "darkkhaki": 12433259,
    "darkmagenta": 9109643,
    "darkolivegreen": 5597999,
    "darkorange": 16747520,
    "darkorchid": 10040012,
    "darkred": 9109504,
    "darksalmon": 15308410,
    "darkseagreen": 9419919,
    "darkslateblue": 4734347,
    "darkslategray": 3100495,
    "darkslategrey": 3100495,
    "darkturquoise": 52945,
    "darkviolet": 9699539,
    "deeppink": 16716947,
    "deepskyblue": 49151,
    "dimgray": 6908265,
    "dimgrey": 6908265,
    "dodgerblue": 2003199,
    "firebrick": 11674146,
    "floralwhite": 16775920,
    "forestgreen": 2263842,
    "fuchsia": 16711935,
    "gainsboro": 14474460,
    "ghostwhite": 16316671,
    "gold": 16766720,
    "goldenrod": 14329120,
    "gray": 8421504,
    "green": 32768,
    "greenyellow": 11403055,
    "grey": 8421504,
    "honeydew": 15794160,
    "hotpink": 16738740,
    "indianred": 13458524,
    "indigo": 4915330,
    "ivory": 16777200,
    "khaki": 15787660,
    "lavender": 15132410,
    "lavenderblush": 16773365,
    "lawngreen": 8190976,
    "lemonchiffon": 16775885,
    "lightblue": 11393254,
    "lightcoral": 15761536,
    "lightcyan": 14745599,
    "lightgoldenrodyellow": 16448210,
    "lightgray": 13882323,
    "lightgreen": 9498256,
    "lightgrey": 13882323,
    "lightpink": 16758465,
    "lightsalmon": 16752762,
    "lightseagreen": 2142890,
    "lightskyblue": 8900346,
    "lightslategray": 7833753,
    "lightslategrey": 7833753,
    "lightsteelblue": 11584734,
    "lightyellow": 16777184,
    "lime": 65280,
    "limegreen": 3329330,
    "linen": 16445670,
    "magenta": 16711935,
    "maroon": 8388608,
    "mediumaquamarine": 6737322,
    "mediumblue": 205,
    "mediumorchid": 12211667,
    "mediumpurple": 9662683,
    "mediumseagreen": 3978097,
    "mediumslateblue": 8087790,
    "mediumspringgreen": 64154,
    "mediumturquoise": 4772300,
    "mediumvioletred": 13047173,
    "midnightblue": 1644912,
    "mintcream": 16121850,
    "mistyrose": 16770273,
    "moccasin": 16770229,
    "navajowhite": 16768685,
    "navy": 128,
    "oldlace": 16643558,
    "olive": 8421376,
    "olivedrab": 7048739,
    "orange": 16753920,
    "orangered": 16729344,
    "orchid": 14315734,
    "palegoldenrod": 15657130,
    "palegreen": 10025880,
    "paleturquoise": 11529966,
    "palevioletred": 14381203,
    "papayawhip": 16773077,
    "peachpuff": 16767673,
    "peru": 13468991,
    "pink": 16761035,
    "plum": 14524637,
    "powderblue": 11591910,
    "purple": 8388736,
    "rebeccapurple": 6697881,
    "red": 16711680,
    "rosybrown": 12357519,
    "royalblue": 4286945,
    "saddlebrown": 9127187,
    "salmon": 16416882,
    "sandybrown": 16032864,
    "seagreen": 3050327,
    "seashell": 16774638,
    "sienna": 10506797,
    "silver": 12632256,
    "skyblue": 8900331,
    "slateblue": 6970061,
    "slategray": 7372944,
    "slategrey": 7372944,
    "snow": 16775930,
    "springgreen": 65407,
    "steelblue": 4620980,
    "tan": 13808780,
    "teal": 32896,
    "thistle": 14204888,
    "tomato": 16737095,
    "turquoise": 4251856,
    "violet": 15631086,
    "wheat": 16113331,
    "white": 16777215,
    "whitesmoke": 16119285,
    "yellow": 16776960,
    "yellowgreen": 10145074
  };
  var _hslA = { h: 0, s: 0, l: 0 };
  var _hslB = { h: 0, s: 0, l: 0 };
  function hue2rgb(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * 6 * (2 / 3 - t);
    return p;
  }
  var Color = class {
    constructor(r, g, b) {
      this.isColor = true;
      this.r = 1;
      this.g = 1;
      this.b = 1;
      return this.set(r, g, b);
    }
    set(r, g, b) {
      if (g === void 0 && b === void 0) {
        const value = r;
        if (value && value.isColor) {
          this.copy(value);
        } else if (typeof value === "number") {
          this.setHex(value);
        } else if (typeof value === "string") {
          this.setStyle(value);
        }
      } else {
        this.setRGB(r, g, b);
      }
      return this;
    }
    setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
    setHex(hex, colorSpace = SRGBColorSpace) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
      this.r = r;
      this.g = g;
      this.b = b;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
      h = euclideanModulo(h, 1);
      s = clamp(s, 0, 1);
      l = clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        const q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setStyle(style, colorSpace = SRGBColorSpace) {
      function handleAlpha(string) {
        if (string === void 0)
          return;
        if (parseFloat(string) < 1) {
          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
      }
      let m;
      if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
        let color;
        const name = m[1];
        const components = m[2];
        switch (name) {
          case "rgb":
          case "rgba":
            if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setRGB(
                Math.min(255, parseInt(color[1], 10)) / 255,
                Math.min(255, parseInt(color[2], 10)) / 255,
                Math.min(255, parseInt(color[3], 10)) / 255,
                colorSpace
              );
            }
            if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setRGB(
                Math.min(100, parseInt(color[1], 10)) / 100,
                Math.min(100, parseInt(color[2], 10)) / 100,
                Math.min(100, parseInt(color[3], 10)) / 100,
                colorSpace
              );
            }
            break;
          case "hsl":
          case "hsla":
            if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setHSL(
                parseFloat(color[1]) / 360,
                parseFloat(color[2]) / 100,
                parseFloat(color[3]) / 100,
                colorSpace
              );
            }
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + style);
        }
      } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
        const hex = m[1];
        const size = hex.length;
        if (size === 3) {
          return this.setRGB(
            parseInt(hex.charAt(0), 16) / 15,
            parseInt(hex.charAt(1), 16) / 15,
            parseInt(hex.charAt(2), 16) / 15,
            colorSpace
          );
        } else if (size === 6) {
          return this.setHex(parseInt(hex, 16), colorSpace);
        } else {
          console.warn("THREE.Color: Invalid hex color " + style);
        }
      } else if (style && style.length > 0) {
        return this.setColorName(style, colorSpace);
      }
      return this;
    }
    setColorName(style, colorSpace = SRGBColorSpace) {
      const hex = _colorKeywords[style.toLowerCase()];
      if (hex !== void 0) {
        this.setHex(hex, colorSpace);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
      return this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
    copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
    copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
    convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
    convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
    getHex(colorSpace = SRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
    }
    getHexString(colorSpace = SRGBColorSpace) {
      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
    }
    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      const r = _color.r, g = _color.g, b = _color.b;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let hue, saturation;
      const lightness = (min + max) / 2;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        const delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      target.r = _color.r;
      target.g = _color.g;
      target.b = _color.b;
      return target;
    }
    getStyle(colorSpace = SRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      const r = _color.r, g = _color.g, b = _color.b;
      if (colorSpace !== SRGBColorSpace) {
        return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
      }
      return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
    }
    offsetHSL(h, s, l) {
      this.getHSL(_hslA);
      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
    }
    add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
    addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
    addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    }
    sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
    multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
    multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    }
    lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
    lerpColors(color1, color2, alpha) {
      this.r = color1.r + (color2.r - color1.r) * alpha;
      this.g = color1.g + (color2.g - color1.g) * alpha;
      this.b = color1.b + (color2.b - color1.b) * alpha;
      return this;
    }
    lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      const h = lerp(_hslA.h, _hslB.h, alpha);
      const s = lerp(_hslA.s, _hslB.s, alpha);
      const l = lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h, s, l);
      return this;
    }
    setFromVector3(v) {
      this.r = v.x;
      this.g = v.y;
      this.b = v.z;
      return this;
    }
    applyMatrix3(m) {
      const r = this.r, g = this.g, b = this.b;
      const e = m.elements;
      this.r = e[0] * r + e[3] * g + e[6] * b;
      this.g = e[1] * r + e[4] * g + e[7] * b;
      this.b = e[2] * r + e[5] * g + e[8] * b;
      return this;
    }
    equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    fromArray(array, offset = 0) {
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.r = attribute.getX(index);
      this.g = attribute.getY(index);
      this.b = attribute.getZ(index);
      return this;
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r;
      yield this.g;
      yield this.b;
    }
  };
  var _color = /* @__PURE__ */ new Color();
  Color.NAMES = _colorKeywords;
  var _materialId = 0;
  var Material = class extends EventDispatcher {
    constructor() {
      super();
      this.isMaterial = true;
      Object.defineProperty(this, "id", { value: _materialId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "Material";
      this.blending = NormalBlending;
      this.side = FrontSide;
      this.vertexColors = false;
      this.opacity = 1;
      this.transparent = false;
      this.alphaHash = false;
      this.blendSrc = SrcAlphaFactor;
      this.blendDst = OneMinusSrcAlphaFactor;
      this.blendEquation = AddEquation;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;
      this.blendColor = new Color(0, 0, 0);
      this.blendAlpha = 0;
      this.depthFunc = LessEqualDepth;
      this.depthTest = true;
      this.depthWrite = true;
      this.stencilWriteMask = 255;
      this.stencilFunc = AlwaysStencilFunc;
      this.stencilRef = 0;
      this.stencilFuncMask = 255;
      this.stencilFail = KeepStencilOp;
      this.stencilZFail = KeepStencilOp;
      this.stencilZPass = KeepStencilOp;
      this.stencilWrite = false;
      this.clippingPlanes = null;
      this.clipIntersection = false;
      this.clipShadows = false;
      this.shadowSide = null;
      this.colorWrite = true;
      this.precision = null;
      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;
      this.dithering = false;
      this.alphaToCoverage = false;
      this.premultipliedAlpha = false;
      this.forceSinglePass = false;
      this.visible = true;
      this.toneMapped = true;
      this.userData = {};
      this.version = 0;
      this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(value) {
      if (this._alphaTest > 0 !== value > 0) {
        this.version++;
      }
      this._alphaTest = value;
    }
    // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(values) {
      if (values === void 0)
        return;
      for (const key in values) {
        const newValue = values[key];
        if (newValue === void 0) {
          console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
          continue;
        }
        const currentValue = this[key];
        if (currentValue === void 0) {
          console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
          continue;
        }
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (isRootObject) {
        meta = {
          textures: {},
          images: {}
        };
      }
      const data = {
        metadata: {
          version: 4.6,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (this.color && this.color.isColor)
        data.color = this.color.getHex();
      if (this.roughness !== void 0)
        data.roughness = this.roughness;
      if (this.metalness !== void 0)
        data.metalness = this.metalness;
      if (this.sheen !== void 0)
        data.sheen = this.sheen;
      if (this.sheenColor && this.sheenColor.isColor)
        data.sheenColor = this.sheenColor.getHex();
      if (this.sheenRoughness !== void 0)
        data.sheenRoughness = this.sheenRoughness;
      if (this.emissive && this.emissive.isColor)
        data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1)
        data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor)
        data.specular = this.specular.getHex();
      if (this.specularIntensity !== void 0)
        data.specularIntensity = this.specularIntensity;
      if (this.specularColor && this.specularColor.isColor)
        data.specularColor = this.specularColor.getHex();
      if (this.shininess !== void 0)
        data.shininess = this.shininess;
      if (this.clearcoat !== void 0)
        data.clearcoat = this.clearcoat;
      if (this.clearcoatRoughness !== void 0)
        data.clearcoatRoughness = this.clearcoatRoughness;
      if (this.clearcoatMap && this.clearcoatMap.isTexture) {
        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
      }
      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
      }
      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
      }
      if (this.dispersion !== void 0)
        data.dispersion = this.dispersion;
      if (this.iridescence !== void 0)
        data.iridescence = this.iridescence;
      if (this.iridescenceIOR !== void 0)
        data.iridescenceIOR = this.iridescenceIOR;
      if (this.iridescenceThicknessRange !== void 0)
        data.iridescenceThicknessRange = this.iridescenceThicknessRange;
      if (this.iridescenceMap && this.iridescenceMap.isTexture) {
        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
      }
      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
      }
      if (this.anisotropy !== void 0)
        data.anisotropy = this.anisotropy;
      if (this.anisotropyRotation !== void 0)
        data.anisotropyRotation = this.anisotropyRotation;
      if (this.anisotropyMap && this.anisotropyMap.isTexture) {
        data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
      }
      if (this.map && this.map.isTexture)
        data.map = this.map.toJSON(meta).uuid;
      if (this.matcap && this.matcap.isTexture)
        data.matcap = this.matcap.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture)
        data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap && this.lightMap.isTexture) {
        data.lightMap = this.lightMap.toJSON(meta).uuid;
        data.lightMapIntensity = this.lightMapIntensity;
      }
      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }
      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }
      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }
      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }
      if (this.roughnessMap && this.roughnessMap.isTexture)
        data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture)
        data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture)
        data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture)
        data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
        data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
      if (this.specularColorMap && this.specularColorMap.isTexture)
        data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        if (this.combine !== void 0)
          data.combine = this.combine;
      }
      if (this.envMapRotation !== void 0)
        data.envMapRotation = this.envMapRotation.toArray();
      if (this.envMapIntensity !== void 0)
        data.envMapIntensity = this.envMapIntensity;
      if (this.reflectivity !== void 0)
        data.reflectivity = this.reflectivity;
      if (this.refractionRatio !== void 0)
        data.refractionRatio = this.refractionRatio;
      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }
      if (this.transmission !== void 0)
        data.transmission = this.transmission;
      if (this.transmissionMap && this.transmissionMap.isTexture)
        data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
      if (this.thickness !== void 0)
        data.thickness = this.thickness;
      if (this.thicknessMap && this.thicknessMap.isTexture)
        data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
      if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity)
        data.attenuationDistance = this.attenuationDistance;
      if (this.attenuationColor !== void 0)
        data.attenuationColor = this.attenuationColor.getHex();
      if (this.size !== void 0)
        data.size = this.size;
      if (this.shadowSide !== null)
        data.shadowSide = this.shadowSide;
      if (this.sizeAttenuation !== void 0)
        data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending)
        data.blending = this.blending;
      if (this.side !== FrontSide)
        data.side = this.side;
      if (this.vertexColors === true)
        data.vertexColors = true;
      if (this.opacity < 1)
        data.opacity = this.opacity;
      if (this.transparent === true)
        data.transparent = true;
      if (this.blendSrc !== SrcAlphaFactor)
        data.blendSrc = this.blendSrc;
      if (this.blendDst !== OneMinusSrcAlphaFactor)
        data.blendDst = this.blendDst;
      if (this.blendEquation !== AddEquation)
        data.blendEquation = this.blendEquation;
      if (this.blendSrcAlpha !== null)
        data.blendSrcAlpha = this.blendSrcAlpha;
      if (this.blendDstAlpha !== null)
        data.blendDstAlpha = this.blendDstAlpha;
      if (this.blendEquationAlpha !== null)
        data.blendEquationAlpha = this.blendEquationAlpha;
      if (this.blendColor && this.blendColor.isColor)
        data.blendColor = this.blendColor.getHex();
      if (this.blendAlpha !== 0)
        data.blendAlpha = this.blendAlpha;
      if (this.depthFunc !== LessEqualDepth)
        data.depthFunc = this.depthFunc;
      if (this.depthTest === false)
        data.depthTest = this.depthTest;
      if (this.depthWrite === false)
        data.depthWrite = this.depthWrite;
      if (this.colorWrite === false)
        data.colorWrite = this.colorWrite;
      if (this.stencilWriteMask !== 255)
        data.stencilWriteMask = this.stencilWriteMask;
      if (this.stencilFunc !== AlwaysStencilFunc)
        data.stencilFunc = this.stencilFunc;
      if (this.stencilRef !== 0)
        data.stencilRef = this.stencilRef;
      if (this.stencilFuncMask !== 255)
        data.stencilFuncMask = this.stencilFuncMask;
      if (this.stencilFail !== KeepStencilOp)
        data.stencilFail = this.stencilFail;
      if (this.stencilZFail !== KeepStencilOp)
        data.stencilZFail = this.stencilZFail;
      if (this.stencilZPass !== KeepStencilOp)
        data.stencilZPass = this.stencilZPass;
      if (this.stencilWrite === true)
        data.stencilWrite = this.stencilWrite;
      if (this.rotation !== void 0 && this.rotation !== 0)
        data.rotation = this.rotation;
      if (this.polygonOffset === true)
        data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0)
        data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0)
        data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth !== void 0 && this.linewidth !== 1)
        data.linewidth = this.linewidth;
      if (this.dashSize !== void 0)
        data.dashSize = this.dashSize;
      if (this.gapSize !== void 0)
        data.gapSize = this.gapSize;
      if (this.scale !== void 0)
        data.scale = this.scale;
      if (this.dithering === true)
        data.dithering = true;
      if (this.alphaTest > 0)
        data.alphaTest = this.alphaTest;
      if (this.alphaHash === true)
        data.alphaHash = true;
      if (this.alphaToCoverage === true)
        data.alphaToCoverage = true;
      if (this.premultipliedAlpha === true)
        data.premultipliedAlpha = true;
      if (this.forceSinglePass === true)
        data.forceSinglePass = true;
      if (this.wireframe === true)
        data.wireframe = true;
      if (this.wireframeLinewidth > 1)
        data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== "round")
        data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== "round")
        data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.flatShading === true)
        data.flatShading = true;
      if (this.visible === false)
        data.visible = false;
      if (this.toneMapped === false)
        data.toneMapped = false;
      if (this.fog === false)
        data.fog = false;
      if (Object.keys(this.userData).length > 0)
        data.userData = this.userData;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data2 = cache[key];
          delete data2.metadata;
          values.push(data2);
        }
        return values;
      }
      if (isRootObject) {
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        if (textures.length > 0)
          data.textures = textures;
        if (images.length > 0)
          data.images = images;
      }
      return data;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.blending = source.blending;
      this.side = source.side;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.blendColor.copy(source.blendColor);
      this.blendAlpha = source.blendAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.stencilWriteMask = source.stencilWriteMask;
      this.stencilFunc = source.stencilFunc;
      this.stencilRef = source.stencilRef;
      this.stencilFuncMask = source.stencilFuncMask;
      this.stencilFail = source.stencilFail;
      this.stencilZFail = source.stencilZFail;
      this.stencilZPass = source.stencilZPass;
      this.stencilWrite = source.stencilWrite;
      const srcPlanes = source.clippingPlanes;
      let dstPlanes = null;
      if (srcPlanes !== null) {
        const n = srcPlanes.length;
        dstPlanes = new Array(n);
        for (let i = 0; i !== n; ++i) {
          dstPlanes[i] = srcPlanes[i].clone();
        }
      }
      this.clippingPlanes = dstPlanes;
      this.clipIntersection = source.clipIntersection;
      this.clipShadows = source.clipShadows;
      this.shadowSide = source.shadowSide;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.alphaHash = source.alphaHash;
      this.alphaToCoverage = source.alphaToCoverage;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.forceSinglePass = source.forceSinglePass;
      this.visible = source.visible;
      this.toneMapped = source.toneMapped;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    onBuild() {
      console.warn("Material: onBuild() has been removed.");
    }
  };
  var MeshBasicMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshBasicMaterial = true;
      this.type = "MeshBasicMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.envMapRotation = new Euler();
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapRotation.copy(source.envMapRotation);
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.fog = source.fog;
      return this;
    }
  };
  var _vector$9 = /* @__PURE__ */ new Vector3();
  var _vector2$1 = /* @__PURE__ */ new Vector2();
  var _id$2 = 0;
  var BufferAttribute = class {
    constructor(array, itemSize, normalized = false) {
      if (Array.isArray(array)) {
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      }
      this.isBufferAttribute = true;
      Object.defineProperty(this, "id", { value: _id$2++ });
      this.name = "";
      this.array = array;
      this.itemSize = itemSize;
      this.count = array !== void 0 ? array.length / itemSize : 0;
      this.normalized = normalized;
      this.usage = StaticDrawUsage;
      this.updateRanges = [];
      this.gpuType = FloatType;
      this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    setUsage(value) {
      this.usage = value;
      return this;
    }
    addUpdateRange(start, count) {
      this.updateRanges.push({ start, count });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.usage = source.usage;
      this.gpuType = source.gpuType;
      return this;
    }
    copyAt(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;
      for (let i = 0, l = this.itemSize; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    }
    copyArray(array) {
      this.array.set(array);
      return this;
    }
    applyMatrix3(m) {
      if (this.itemSize === 2) {
        for (let i = 0, l = this.count; i < l; i++) {
          _vector2$1.fromBufferAttribute(this, i);
          _vector2$1.applyMatrix3(m);
          this.setXY(i, _vector2$1.x, _vector2$1.y);
        }
      } else if (this.itemSize === 3) {
        for (let i = 0, l = this.count; i < l; i++) {
          _vector$9.fromBufferAttribute(this, i);
          _vector$9.applyMatrix3(m);
          this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
        }
      }
      return this;
    }
    applyMatrix4(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix4(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    applyNormalMatrix(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyNormalMatrix(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    transformDirection(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.transformDirection(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    set(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    }
    getComponent(index, component) {
      let value = this.array[index * this.itemSize + component];
      if (this.normalized)
        value = denormalize(value, this.array);
      return value;
    }
    setComponent(index, component, value) {
      if (this.normalized)
        value = normalize(value, this.array);
      this.array[index * this.itemSize + component] = value;
      return this;
    }
    getX(index) {
      let x = this.array[index * this.itemSize];
      if (this.normalized)
        x = denormalize(x, this.array);
      return x;
    }
    setX(index, x) {
      if (this.normalized)
        x = normalize(x, this.array);
      this.array[index * this.itemSize] = x;
      return this;
    }
    getY(index) {
      let y = this.array[index * this.itemSize + 1];
      if (this.normalized)
        y = denormalize(y, this.array);
      return y;
    }
    setY(index, y) {
      if (this.normalized)
        y = normalize(y, this.array);
      this.array[index * this.itemSize + 1] = y;
      return this;
    }
    getZ(index) {
      let z = this.array[index * this.itemSize + 2];
      if (this.normalized)
        z = denormalize(z, this.array);
      return z;
    }
    setZ(index, z) {
      if (this.normalized)
        z = normalize(z, this.array);
      this.array[index * this.itemSize + 2] = z;
      return this;
    }
    getW(index) {
      let w = this.array[index * this.itemSize + 3];
      if (this.normalized)
        w = denormalize(w, this.array);
      return w;
    }
    setW(index, w) {
      if (this.normalized)
        w = normalize(w, this.array);
      this.array[index * this.itemSize + 3] = w;
      return this;
    }
    setXY(index, x, y) {
      index *= this.itemSize;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
      }
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      return this;
    }
    setXYZ(index, x, y, z) {
      index *= this.itemSize;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
        z = normalize(z, this.array);
      }
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    }
    setXYZW(index, x, y, z, w) {
      index *= this.itemSize;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
        z = normalize(z, this.array);
        w = normalize(w, this.array);
      }
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    }
    onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const data = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized
      };
      if (this.name !== "")
        data.name = this.name;
      if (this.usage !== StaticDrawUsage)
        data.usage = this.usage;
      return data;
    }
  };
  var Uint16BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint16Array(array), itemSize, normalized);
    }
  };
  var Uint32BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint32Array(array), itemSize, normalized);
    }
  };
  var Float32BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Float32Array(array), itemSize, normalized);
    }
  };
  var _id$1 = 0;
  var _m1 = /* @__PURE__ */ new Matrix4();
  var _obj = /* @__PURE__ */ new Object3D();
  var _offset = /* @__PURE__ */ new Vector3();
  var _box$2 = /* @__PURE__ */ new Box3();
  var _boxMorphTargets = /* @__PURE__ */ new Box3();
  var _vector$8 = /* @__PURE__ */ new Vector3();
  var BufferGeometry = class extends EventDispatcher {
    constructor() {
      super();
      this.isBufferGeometry = true;
      Object.defineProperty(this, "id", { value: _id$1++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "BufferGeometry";
      this.index = null;
      this.indirect = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.morphTargetsRelative = false;
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.drawRange = { start: 0, count: Infinity };
      this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(index) {
      if (Array.isArray(index)) {
        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
      } else {
        this.index = index;
      }
      return this;
    }
    setIndirect(indirect) {
      this.indirect = indirect;
      return this;
    }
    getIndirect() {
      return this.indirect;
    }
    getAttribute(name) {
      return this.attributes[name];
    }
    setAttribute(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    }
    deleteAttribute(name) {
      delete this.attributes[name];
      return this;
    }
    hasAttribute(name) {
      return this.attributes[name] !== void 0;
    }
    addGroup(start, count, materialIndex = 0) {
      this.groups.push({
        start,
        count,
        materialIndex
      });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    }
    applyMatrix4(matrix) {
      const position = this.attributes.position;
      if (position !== void 0) {
        position.applyMatrix4(matrix);
        position.needsUpdate = true;
      }
      const normal = this.attributes.normal;
      if (normal !== void 0) {
        const normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normal.applyNormalMatrix(normalMatrix);
        normal.needsUpdate = true;
      }
      const tangent = this.attributes.tangent;
      if (tangent !== void 0) {
        tangent.transformDirection(matrix);
        tangent.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      return this;
    }
    applyQuaternion(q) {
      _m1.makeRotationFromQuaternion(q);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateX(angle) {
      _m1.makeRotationX(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateY(angle) {
      _m1.makeRotationY(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateZ(angle) {
      _m1.makeRotationZ(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    translate(x, y, z) {
      _m1.makeTranslation(x, y, z);
      this.applyMatrix4(_m1);
      return this;
    }
    scale(x, y, z) {
      _m1.makeScale(x, y, z);
      this.applyMatrix4(_m1);
      return this;
    }
    lookAt(vector) {
      _obj.lookAt(vector);
      _obj.updateMatrix();
      this.applyMatrix4(_obj.matrix);
      return this;
    }
    center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset).negate();
      this.translate(_offset.x, _offset.y, _offset.z);
      return this;
    }
    setFromPoints(points) {
      const positionAttribute = this.getAttribute("position");
      if (positionAttribute === void 0) {
        const position = [];
        for (let i = 0, l = points.length; i < l; i++) {
          const point = points[i];
          position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute("position", new Float32BufferAttribute(position, 3));
      } else {
        const l = Math.min(points.length, positionAttribute.count);
        for (let i = 0; i < l; i++) {
          const point = points[i];
          positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);
        }
        if (points.length > positionAttribute.count) {
          console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");
        }
        positionAttribute.needsUpdate = true;
      }
      return this;
    }
    computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);
        this.boundingBox.set(
          new Vector3(-Infinity, -Infinity, -Infinity),
          new Vector3(Infinity, Infinity, Infinity)
        );
        return;
      }
      if (position !== void 0) {
        this.boundingBox.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            _box$2.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(this.boundingBox.min, _box$2.min);
              this.boundingBox.expandByPoint(_vector$8);
              _vector$8.addVectors(this.boundingBox.max, _box$2.max);
              this.boundingBox.expandByPoint(_vector$8);
            } else {
              this.boundingBox.expandByPoint(_box$2.min);
              this.boundingBox.expandByPoint(_box$2.max);
            }
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }
      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);
        this.boundingSphere.set(new Vector3(), Infinity);
        return;
      }
      if (position) {
        const center = this.boundingSphere.center;
        _box$2.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            _boxMorphTargets.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
              _box$2.expandByPoint(_vector$8);
              _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
              _box$2.expandByPoint(_vector$8);
            } else {
              _box$2.expandByPoint(_boxMorphTargets.min);
              _box$2.expandByPoint(_boxMorphTargets.max);
            }
          }
        }
        _box$2.getCenter(center);
        let maxRadiusSq = 0;
        for (let i = 0, il = position.count; i < il; i++) {
          _vector$8.fromBufferAttribute(position, i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
        }
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            const morphTargetsRelative = this.morphTargetsRelative;
            for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
              _vector$8.fromBufferAttribute(morphAttribute, j);
              if (morphTargetsRelative) {
                _offset.fromBufferAttribute(position, j);
                _vector$8.add(_offset);
              }
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
          }
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    }
    computeTangents() {
      const index = this.index;
      const attributes = this.attributes;
      if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        return;
      }
      const positionAttribute = attributes.position;
      const normalAttribute = attributes.normal;
      const uvAttribute = attributes.uv;
      if (this.hasAttribute("tangent") === false) {
        this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
      }
      const tangentAttribute = this.getAttribute("tangent");
      const tan1 = [], tan2 = [];
      for (let i = 0; i < positionAttribute.count; i++) {
        tan1[i] = new Vector3();
        tan2[i] = new Vector3();
      }
      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
      function handleTriangle(a, b, c) {
        vA.fromBufferAttribute(positionAttribute, a);
        vB.fromBufferAttribute(positionAttribute, b);
        vC.fromBufferAttribute(positionAttribute, c);
        uvA.fromBufferAttribute(uvAttribute, a);
        uvB.fromBufferAttribute(uvAttribute, b);
        uvC.fromBufferAttribute(uvAttribute, c);
        vB.sub(vA);
        vC.sub(vA);
        uvB.sub(uvA);
        uvC.sub(uvA);
        const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
        if (!isFinite(r))
          return;
        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
        tan1[a].add(sdir);
        tan1[b].add(sdir);
        tan1[c].add(sdir);
        tan2[a].add(tdir);
        tan2[b].add(tdir);
        tan2[c].add(tdir);
      }
      let groups = this.groups;
      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: index.count
        }];
      }
      for (let i = 0, il = groups.length; i < il; ++i) {
        const group = groups[i];
        const start = group.start;
        const count = group.count;
        for (let j = start, jl = start + count; j < jl; j += 3) {
          handleTriangle(
            index.getX(j + 0),
            index.getX(j + 1),
            index.getX(j + 2)
          );
        }
      }
      const tmp = new Vector3(), tmp2 = new Vector3();
      const n = new Vector3(), n2 = new Vector3();
      function handleVertex(v) {
        n.fromBufferAttribute(normalAttribute, v);
        n2.copy(n);
        const t = tan1[v];
        tmp.copy(t);
        tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
        tmp2.crossVectors(n2, t);
        const test = tmp2.dot(tan2[v]);
        const w = test < 0 ? -1 : 1;
        tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);
      }
      for (let i = 0, il = groups.length; i < il; ++i) {
        const group = groups[i];
        const start = group.start;
        const count = group.count;
        for (let j = start, jl = start + count; j < jl; j += 3) {
          handleVertex(index.getX(j + 0));
          handleVertex(index.getX(j + 1));
          handleVertex(index.getX(j + 2));
        }
      }
    }
    computeVertexNormals() {
      const index = this.index;
      const positionAttribute = this.getAttribute("position");
      if (positionAttribute !== void 0) {
        let normalAttribute = this.getAttribute("normal");
        if (normalAttribute === void 0) {
          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
          this.setAttribute("normal", normalAttribute);
        } else {
          for (let i = 0, il = normalAttribute.count; i < il; i++) {
            normalAttribute.setXYZ(i, 0, 0, 0);
          }
        }
        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
        const cb = new Vector3(), ab = new Vector3();
        if (index) {
          for (let i = 0, il = index.count; i < il; i += 3) {
            const vA = index.getX(i + 0);
            const vB = index.getX(i + 1);
            const vC = index.getX(i + 2);
            pA.fromBufferAttribute(positionAttribute, vA);
            pB.fromBufferAttribute(positionAttribute, vB);
            pC.fromBufferAttribute(positionAttribute, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            nA.fromBufferAttribute(normalAttribute, vA);
            nB.fromBufferAttribute(normalAttribute, vB);
            nC.fromBufferAttribute(normalAttribute, vC);
            nA.add(cb);
            nB.add(cb);
            nC.add(cb);
            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
          }
        } else {
          for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
            pA.fromBufferAttribute(positionAttribute, i + 0);
            pB.fromBufferAttribute(positionAttribute, i + 1);
            pC.fromBufferAttribute(positionAttribute, i + 2);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
          }
        }
        this.normalizeNormals();
        normalAttribute.needsUpdate = true;
      }
    }
    normalizeNormals() {
      const normals = this.attributes.normal;
      for (let i = 0, il = normals.count; i < il; i++) {
        _vector$8.fromBufferAttribute(normals, i);
        _vector$8.normalize();
        normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
    toNonIndexed() {
      function convertBufferAttribute(attribute, indices2) {
        const array = attribute.array;
        const itemSize = attribute.itemSize;
        const normalized = attribute.normalized;
        const array2 = new array.constructor(indices2.length * itemSize);
        let index = 0, index2 = 0;
        for (let i = 0, l = indices2.length; i < l; i++) {
          if (attribute.isInterleavedBufferAttribute) {
            index = indices2[i] * attribute.data.stride + attribute.offset;
          } else {
            index = indices2[i] * itemSize;
          }
          for (let j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
          }
        }
        return new BufferAttribute(array2, itemSize, normalized);
      }
      if (this.index === null) {
        console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
        return this;
      }
      const geometry2 = new BufferGeometry();
      const indices = this.index.array;
      const attributes = this.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        const newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.setAttribute(name, newAttribute);
      }
      const morphAttributes = this.morphAttributes;
      for (const name in morphAttributes) {
        const morphArray = [];
        const morphAttribute = morphAttributes[name];
        for (let i = 0, il = morphAttribute.length; i < il; i++) {
          const attribute = morphAttribute[i];
          const newAttribute = convertBufferAttribute(attribute, indices);
          morphArray.push(newAttribute);
        }
        geometry2.morphAttributes[name] = morphArray;
      }
      geometry2.morphTargetsRelative = this.morphTargetsRelative;
      const groups = this.groups;
      for (let i = 0, l = groups.length; i < l; i++) {
        const group = groups[i];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }
      return geometry2;
    }
    toJSON() {
      const data = {
        metadata: {
          version: 4.6,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (Object.keys(this.userData).length > 0)
        data.userData = this.userData;
      if (this.parameters !== void 0) {
        const parameters = this.parameters;
        for (const key in parameters) {
          if (parameters[key] !== void 0)
            data[key] = parameters[key];
        }
        return data;
      }
      data.data = { attributes: {} };
      const index = this.index;
      if (index !== null) {
        data.data.index = {
          type: index.array.constructor.name,
          array: Array.prototype.slice.call(index.array)
        };
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        const attribute = attributes[key];
        data.data.attributes[key] = attribute.toJSON(data.data);
      }
      const morphAttributes = {};
      let hasMorphAttributes = false;
      for (const key in this.morphAttributes) {
        const attributeArray = this.morphAttributes[key];
        const array = [];
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          array.push(attribute.toJSON(data.data));
        }
        if (array.length > 0) {
          morphAttributes[key] = array;
          hasMorphAttributes = true;
        }
      }
      if (hasMorphAttributes) {
        data.data.morphAttributes = morphAttributes;
        data.data.morphTargetsRelative = this.morphTargetsRelative;
      }
      const groups = this.groups;
      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }
      const boundingSphere = this.boundingSphere;
      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }
      return data;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      const data = {};
      this.name = source.name;
      const index = source.index;
      if (index !== null) {
        this.setIndex(index.clone(data));
      }
      const attributes = source.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        this.setAttribute(name, attribute.clone(data));
      }
      const morphAttributes = source.morphAttributes;
      for (const name in morphAttributes) {
        const array = [];
        const morphAttribute = morphAttributes[name];
        for (let i = 0, l = morphAttribute.length; i < l; i++) {
          array.push(morphAttribute[i].clone(data));
        }
        this.morphAttributes[name] = array;
      }
      this.morphTargetsRelative = source.morphTargetsRelative;
      const groups = source.groups;
      for (let i = 0, l = groups.length; i < l; i++) {
        const group = groups[i];
        this.addGroup(group.start, group.count, group.materialIndex);
      }
      const boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }
      const boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }
      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;
      this.userData = source.userData;
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  var _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
  var _ray$3 = /* @__PURE__ */ new Ray();
  var _sphere$6 = /* @__PURE__ */ new Sphere();
  var _sphereHitAt = /* @__PURE__ */ new Vector3();
  var _vA$1 = /* @__PURE__ */ new Vector3();
  var _vB$1 = /* @__PURE__ */ new Vector3();
  var _vC$1 = /* @__PURE__ */ new Vector3();
  var _tempA = /* @__PURE__ */ new Vector3();
  var _morphA = /* @__PURE__ */ new Vector3();
  var _intersectionPoint = /* @__PURE__ */ new Vector3();
  var _intersectionPointWorld = /* @__PURE__ */ new Vector3();
  var Mesh = class extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
      super();
      this.isMesh = true;
      this.type = "Mesh";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      if (source.morphTargetInfluences !== void 0) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }
      if (source.morphTargetDictionary !== void 0) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }
      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
      this.geometry = source.geometry;
      return this;
    }
    updateMorphTargets() {
      const geometry = this.geometry;
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    }
    getVertexPosition(index, target) {
      const geometry = this.geometry;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      target.fromBufferAttribute(position, index);
      const morphInfluences = this.morphTargetInfluences;
      if (morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        for (let i = 0, il = morphPosition.length; i < il; i++) {
          const influence = morphInfluences[i];
          const morphAttribute = morphPosition[i];
          if (influence === 0)
            continue;
          _tempA.fromBufferAttribute(morphAttribute, index);
          if (morphTargetsRelative) {
            _morphA.addScaledVector(_tempA, influence);
          } else {
            _morphA.addScaledVector(_tempA.sub(target), influence);
          }
        }
        target.add(_morphA);
      }
      return target;
    }
    raycast(raycaster, intersects) {
      const geometry = this.geometry;
      const material = this.material;
      const matrixWorld = this.matrixWorld;
      if (material === void 0)
        return;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$6.copy(geometry.boundingSphere);
      _sphere$6.applyMatrix4(matrixWorld);
      _ray$3.copy(raycaster.ray).recast(raycaster.near);
      if (_sphere$6.containsPoint(_ray$3.origin) === false) {
        if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null)
          return;
        if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2)
          return;
      }
      _inverseMatrix$3.copy(matrixWorld).invert();
      _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
      if (geometry.boundingBox !== null) {
        if (_ray$3.intersectsBox(geometry.boundingBox) === false)
          return;
      }
      this._computeIntersections(raycaster, intersects, _ray$3);
    }
    _computeIntersections(raycaster, intersects, rayLocalSpace) {
      let intersection;
      const geometry = this.geometry;
      const material = this.material;
      const index = geometry.index;
      const position = geometry.attributes.position;
      const uv = geometry.attributes.uv;
      const uv1 = geometry.attributes.uv1;
      const normal = geometry.attributes.normal;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index !== null) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j = start, jl = end; j < jl; j += 3) {
              const a = index.getX(j);
              const b = index.getX(j + 1);
              const c = index.getX(j + 2);
              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i += 3) {
            const a = index.getX(i);
            const b = index.getX(i + 1);
            const c = index.getX(i + 2);
            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j = start, jl = end; j < jl; j += 3) {
              const a = j;
              const b = j + 1;
              const c = j + 2;
              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i += 3) {
            const a = i;
            const b = i + 1;
            const c = i + 2;
            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects.push(intersection);
            }
          }
        }
      }
    }
  };
  function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
    }
    if (intersect === null)
      return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far)
      return null;
    return {
      distance,
      point: _intersectionPointWorld.clone(),
      object
    };
  }
  function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
    object.getVertexPosition(a, _vA$1);
    object.getVertexPosition(b, _vB$1);
    object.getVertexPosition(c, _vC$1);
    const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (intersection) {
      const barycoord = new Vector3();
      Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);
      if (uv) {
        intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());
      }
      if (uv1) {
        intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());
      }
      if (normal) {
        intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());
        if (intersection.normal.dot(ray.direction) > 0) {
          intersection.normal.multiplyScalar(-1);
        }
      }
      const face = {
        a,
        b,
        c,
        normal: new Vector3(),
        materialIndex: 0
      };
      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
      intersection.face = face;
      intersection.barycoord = barycoord;
    }
    return intersection;
  }
  var BoxGeometry = class extends BufferGeometry {
    constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
      super();
      this.type = "BoxGeometry";
      this.parameters = {
        width,
        height,
        depth,
        widthSegments,
        heightSegments,
        depthSegments
      };
      const scope = this;
      widthSegments = Math.floor(widthSegments);
      heightSegments = Math.floor(heightSegments);
      depthSegments = Math.floor(depthSegments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let numberOfVertices = 0;
      let groupStart = 0;
      buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
      buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
      buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
      buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
      buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
      buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
        const segmentWidth = width2 / gridX;
        const segmentHeight = height2 / gridY;
        const widthHalf = width2 / 2;
        const heightHalf = height2 / 2;
        const depthHalf = depth2 / 2;
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        let vertexCounter = 0;
        let groupCount = 0;
        const vector = new Vector3();
        for (let iy = 0; iy < gridY1; iy++) {
          const y = iy * segmentHeight - heightHalf;
          for (let ix = 0; ix < gridX1; ix++) {
            const x = ix * segmentWidth - widthHalf;
            vector[u] = x * udir;
            vector[v] = y * vdir;
            vector[w] = depthHalf;
            vertices.push(vector.x, vector.y, vector.z);
            vector[u] = 0;
            vector[v] = 0;
            vector[w] = depth2 > 0 ? 1 : -1;
            normals.push(vector.x, vector.y, vector.z);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
            vertexCounter += 1;
          }
        }
        for (let iy = 0; iy < gridY; iy++) {
          for (let ix = 0; ix < gridX; ix++) {
            const a = numberOfVertices + ix + gridX1 * iy;
            const b = numberOfVertices + ix + gridX1 * (iy + 1);
            const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
            const d = numberOfVertices + (ix + 1) + gridX1 * iy;
            indices.push(a, b, d);
            indices.push(b, c, d);
            groupCount += 6;
          }
        }
        scope.addGroup(groupStart, groupCount, materialIndex);
        groupStart += groupCount;
        numberOfVertices += vertexCounter;
      }
    }
    copy(source) {
      super.copy(source);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
    static fromJSON(data) {
      return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
    }
  };
  function cloneUniforms(src) {
    const dst = {};
    for (const u in src) {
      dst[u] = {};
      for (const p in src[u]) {
        const property = src[u][p];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          if (property.isRenderTargetTexture) {
            console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
            dst[u][p] = null;
          } else {
            dst[u][p] = property.clone();
          }
        } else if (Array.isArray(property)) {
          dst[u][p] = property.slice();
        } else {
          dst[u][p] = property;
        }
      }
    }
    return dst;
  }
  function mergeUniforms(uniforms) {
    const merged = {};
    for (let u = 0; u < uniforms.length; u++) {
      const tmp = cloneUniforms(uniforms[u]);
      for (const p in tmp) {
        merged[p] = tmp[p];
      }
    }
    return merged;
  }
  function cloneUniformsGroups(src) {
    const dst = [];
    for (let u = 0; u < src.length; u++) {
      dst.push(src[u].clone());
    }
    return dst;
  }
  function getUnlitUniformColorSpace(renderer) {
    const currentRenderTarget = renderer.getRenderTarget();
    if (currentRenderTarget === null) {
      return renderer.outputColorSpace;
    }
    if (currentRenderTarget.isXRRenderTarget === true) {
      return currentRenderTarget.texture.colorSpace;
    }
    return ColorManagement.workingColorSpace;
  }
  var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
  var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  var ShaderMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isShaderMaterial = true;
      this.type = "ShaderMaterial";
      this.defines = {};
      this.uniforms = {};
      this.uniformsGroups = [];
      this.vertexShader = default_vertex;
      this.fragmentShader = default_fragment;
      this.linewidth = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.lights = false;
      this.clipping = false;
      this.forceSinglePass = true;
      this.extensions = {
        clipCullDistance: false,
        // set to use vertex shader clipping
        multiDraw: false
        // set to use vertex shader multi_draw / enable gl_DrawID
      };
      this.defaultAttributeValues = {
        "color": [1, 1, 1],
        "uv": [0, 0],
        "uv1": [0, 0]
      };
      this.index0AttributeName = void 0;
      this.uniformsNeedUpdate = false;
      this.glslVersion = null;
      if (parameters !== void 0) {
        this.setValues(parameters);
      }
    }
    copy(source) {
      super.copy(source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = cloneUniforms(source.uniforms);
      this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
      this.defines = Object.assign({}, source.defines);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.fog = source.fog;
      this.lights = source.lights;
      this.clipping = source.clipping;
      this.extensions = Object.assign({}, source.extensions);
      this.glslVersion = source.glslVersion;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.glslVersion = this.glslVersion;
      data.uniforms = {};
      for (const name in this.uniforms) {
        const uniform = this.uniforms[name];
        const value = uniform.value;
        if (value && value.isTexture) {
          data.uniforms[name] = {
            type: "t",
            value: value.toJSON(meta).uuid
          };
        } else if (value && value.isColor) {
          data.uniforms[name] = {
            type: "c",
            value: value.getHex()
          };
        } else if (value && value.isVector2) {
          data.uniforms[name] = {
            type: "v2",
            value: value.toArray()
          };
        } else if (value && value.isVector3) {
          data.uniforms[name] = {
            type: "v3",
            value: value.toArray()
          };
        } else if (value && value.isVector4) {
          data.uniforms[name] = {
            type: "v4",
            value: value.toArray()
          };
        } else if (value && value.isMatrix3) {
          data.uniforms[name] = {
            type: "m3",
            value: value.toArray()
          };
        } else if (value && value.isMatrix4) {
          data.uniforms[name] = {
            type: "m4",
            value: value.toArray()
          };
        } else {
          data.uniforms[name] = {
            value
          };
        }
      }
      if (Object.keys(this.defines).length > 0)
        data.defines = this.defines;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      data.lights = this.lights;
      data.clipping = this.clipping;
      const extensions = {};
      for (const key in this.extensions) {
        if (this.extensions[key] === true)
          extensions[key] = true;
      }
      if (Object.keys(extensions).length > 0)
        data.extensions = extensions;
      return data;
    }
  };
  var Camera = class extends Object3D {
    constructor() {
      super();
      this.isCamera = true;
      this.type = "Camera";
      this.matrixWorldInverse = new Matrix4();
      this.projectionMatrix = new Matrix4();
      this.projectionMatrixInverse = new Matrix4();
      this.coordinateSystem = WebGLCoordinateSystem;
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      this.coordinateSystem = source.coordinateSystem;
      return this;
    }
    getWorldDirection(target) {
      return super.getWorldDirection(target).negate();
    }
    updateMatrixWorld(force) {
      super.updateMatrixWorld(force);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(updateParents, updateChildren) {
      super.updateWorldMatrix(updateParents, updateChildren);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _v3$1 = /* @__PURE__ */ new Vector3();
  var _minTarget = /* @__PURE__ */ new Vector2();
  var _maxTarget = /* @__PURE__ */ new Vector2();
  var PerspectiveCamera = class extends Camera {
    constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
      super();
      this.isPerspectiveCamera = true;
      this.type = "PerspectiveCamera";
      this.fov = fov2;
      this.zoom = 1;
      this.near = near;
      this.far = far;
      this.focus = 10;
      this.aspect = aspect2;
      this.view = null;
      this.filmGauge = 35;
      this.filmOffset = 0;
      this.updateProjectionMatrix();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    }
    /**
     * Sets the FOV by focal length in respect to the current .filmGauge.
     *
     * The default film gauge is 35, so that the focal length can be specified for
     * a 35mm (full frame) camera.
     *
     * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
     */
    setFocalLength(focalLength) {
      const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
      this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
      this.updateProjectionMatrix();
    }
    /**
     * Calculates the focal length from the current .fov and .filmGauge.
     *
     * @returns {number}
     */
    getFocalLength() {
      const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / vExtentSlope;
    }
    getEffectiveFOV() {
      return RAD2DEG * 2 * Math.atan(
        Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
      );
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    /**
     * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
     * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
     *
     * @param {number} distance
     * @param {Vector2} minTarget
     * @param {Vector2} maxTarget
     */
    getViewBounds(distance, minTarget, maxTarget) {
      _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
      minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
      _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
      maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
    }
    /**
     * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
     *
     * @param {number} distance
     * @param {Vector2} target - Vector2 target used to store result where x is width and y is height.
     * @returns {Vector2}
     */
    getViewSize(distance, target) {
      this.getViewBounds(distance, _minTarget, _maxTarget);
      return target.subVectors(_maxTarget, _minTarget);
    }
    /**
     * Sets an offset in a larger frustum. This is useful for multi-window or
     * multi-monitor/multi-machine setups.
     *
     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
     * the monitors are in grid like this
     *
     *   +---+---+---+
     *   | A | B | C |
     *   +---+---+---+
     *   | D | E | F |
     *   +---+---+---+
     *
     * then for each monitor you would call it like this
     *
     *   const w = 1920;
     *   const h = 1080;
     *   const fullWidth = w * 3;
     *   const fullHeight = h * 2;
     *
     *   --A--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
     *   --B--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
     *   --C--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
     *   --D--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
     *   --E--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
     *   --F--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
     *
     *   Note there is no reason monitors have to be the same size or in a grid.
     *
     * @param {number} fullWidth
     * @param {number} fullHeight
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */
    setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
    clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const near = this.near;
      let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
      let height = 2 * top;
      let width = this.aspect * height;
      let left = -0.5 * width;
      const view = this.view;
      if (this.view !== null && this.view.enabled) {
        const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
        left += view.offsetX * width / fullWidth;
        top -= view.offsetY * height / fullHeight;
        width *= view.width / fullWidth;
        height *= view.height / fullHeight;
      }
      const skew = this.filmOffset;
      if (skew !== 0)
        left += near * skew / this.getFilmWidth();
      this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.fov = this.fov;
      data.object.zoom = this.zoom;
      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;
      data.object.aspect = this.aspect;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;
      return data;
    }
  };
  var fov = -90;
  var aspect = 1;
  var CubeCamera = class extends Object3D {
    constructor(near, far, renderTarget) {
      super();
      this.type = "CubeCamera";
      this.renderTarget = renderTarget;
      this.coordinateSystem = null;
      this.activeMipmapLevel = 0;
      const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
      cameraPX.layers = this.layers;
      this.add(cameraPX);
      const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
      cameraNX.layers = this.layers;
      this.add(cameraNX);
      const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
      cameraPY.layers = this.layers;
      this.add(cameraPY);
      const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
      cameraNY.layers = this.layers;
      this.add(cameraNY);
      const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.layers = this.layers;
      this.add(cameraPZ);
      const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.layers = this.layers;
      this.add(cameraNZ);
    }
    updateCoordinateSystem() {
      const coordinateSystem = this.coordinateSystem;
      const cameras = this.children.concat();
      const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
      for (const camera of cameras)
        this.remove(camera);
      if (coordinateSystem === WebGLCoordinateSystem) {
        cameraPX.up.set(0, 1, 0);
        cameraPX.lookAt(1, 0, 0);
        cameraNX.up.set(0, 1, 0);
        cameraNX.lookAt(-1, 0, 0);
        cameraPY.up.set(0, 0, -1);
        cameraPY.lookAt(0, 1, 0);
        cameraNY.up.set(0, 0, 1);
        cameraNY.lookAt(0, -1, 0);
        cameraPZ.up.set(0, 1, 0);
        cameraPZ.lookAt(0, 0, 1);
        cameraNZ.up.set(0, 1, 0);
        cameraNZ.lookAt(0, 0, -1);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(-1, 0, 0);
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(1, 0, 0);
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(0, 1, 0);
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(0, -1, 0);
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(0, 0, 1);
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(0, 0, -1);
      } else {
        throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
      }
      for (const camera of cameras) {
        this.add(camera);
        camera.updateMatrixWorld();
      }
    }
    update(renderer, scene) {
      if (this.parent === null)
        this.updateMatrixWorld();
      const { renderTarget, activeMipmapLevel } = this;
      if (this.coordinateSystem !== renderer.coordinateSystem) {
        this.coordinateSystem = renderer.coordinateSystem;
        this.updateCoordinateSystem();
      }
      const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentActiveCubeFace = renderer.getActiveCubeFace();
      const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
      const currentXrEnabled = renderer.xr.enabled;
      renderer.xr.enabled = false;
      const generateMipmaps = renderTarget.texture.generateMipmaps;
      renderTarget.texture.generateMipmaps = false;
      renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
      renderer.render(scene, cameraPX);
      renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
      renderer.render(scene, cameraNX);
      renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
      renderer.render(scene, cameraPY);
      renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
      renderer.render(scene, cameraNY);
      renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
      renderer.render(scene, cameraPZ);
      renderTarget.texture.generateMipmaps = generateMipmaps;
      renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
      renderer.render(scene, cameraNZ);
      renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
      renderer.xr.enabled = currentXrEnabled;
      renderTarget.texture.needsPMREMUpdate = true;
    }
  };
  var CubeTexture = class extends Texture {
    constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
      images = images !== void 0 ? images : [];
      mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
      super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
      this.isCubeTexture = true;
      this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(value) {
      this.image = value;
    }
  };
  var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
    constructor(size = 1, options = {}) {
      super(size, size, options);
      this.isWebGLCubeRenderTarget = true;
      const image = { width: size, height: size, depth: 1 };
      const images = [image, image, image, image, image, image];
      this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
      this.texture.isRenderTargetTexture = true;
      this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
      this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    }
    fromEquirectangularTexture(renderer, texture) {
      this.texture.type = texture.type;
      this.texture.colorSpace = texture.colorSpace;
      this.texture.generateMipmaps = texture.generateMipmaps;
      this.texture.minFilter = texture.minFilter;
      this.texture.magFilter = texture.magFilter;
      const shader = {
        uniforms: {
          tEquirect: { value: null }
        },
        vertexShader: (
          /* glsl */
          `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
        ),
        fragmentShader: (
          /* glsl */
          `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        )
      };
      const geometry = new BoxGeometry(5, 5, 5);
      const material = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
      });
      material.uniforms.tEquirect.value = texture;
      const mesh = new Mesh(geometry, material);
      const currentMinFilter = texture.minFilter;
      if (texture.minFilter === LinearMipmapLinearFilter)
        texture.minFilter = LinearFilter;
      const camera = new CubeCamera(1, 10, this);
      camera.update(renderer, mesh);
      texture.minFilter = currentMinFilter;
      mesh.geometry.dispose();
      mesh.material.dispose();
      return this;
    }
    clear(renderer, color, depth, stencil) {
      const currentRenderTarget = renderer.getRenderTarget();
      for (let i = 0; i < 6; i++) {
        renderer.setRenderTarget(this, i);
        renderer.clear(color, depth, stencil);
      }
      renderer.setRenderTarget(currentRenderTarget);
    }
  };
  var Group = class extends Object3D {
    constructor() {
      super();
      this.isGroup = true;
      this.type = "Group";
    }
  };
  var _moveEvent = { type: "move" };
  var WebXRController = class {
    constructor() {
      this._targetRay = null;
      this._grip = null;
      this._hand = null;
    }
    getHandSpace() {
      if (this._hand === null) {
        this._hand = new Group();
        this._hand.matrixAutoUpdate = false;
        this._hand.visible = false;
        this._hand.joints = {};
        this._hand.inputState = { pinching: false };
      }
      return this._hand;
    }
    getTargetRaySpace() {
      if (this._targetRay === null) {
        this._targetRay = new Group();
        this._targetRay.matrixAutoUpdate = false;
        this._targetRay.visible = false;
        this._targetRay.hasLinearVelocity = false;
        this._targetRay.linearVelocity = new Vector3();
        this._targetRay.hasAngularVelocity = false;
        this._targetRay.angularVelocity = new Vector3();
      }
      return this._targetRay;
    }
    getGripSpace() {
      if (this._grip === null) {
        this._grip = new Group();
        this._grip.matrixAutoUpdate = false;
        this._grip.visible = false;
        this._grip.hasLinearVelocity = false;
        this._grip.linearVelocity = new Vector3();
        this._grip.hasAngularVelocity = false;
        this._grip.angularVelocity = new Vector3();
      }
      return this._grip;
    }
    dispatchEvent(event) {
      if (this._targetRay !== null) {
        this._targetRay.dispatchEvent(event);
      }
      if (this._grip !== null) {
        this._grip.dispatchEvent(event);
      }
      if (this._hand !== null) {
        this._hand.dispatchEvent(event);
      }
      return this;
    }
    connect(inputSource) {
      if (inputSource && inputSource.hand) {
        const hand = this._hand;
        if (hand) {
          for (const inputjoint of inputSource.hand.values()) {
            this._getHandJoint(hand, inputjoint);
          }
        }
      }
      this.dispatchEvent({ type: "connected", data: inputSource });
      return this;
    }
    disconnect(inputSource) {
      this.dispatchEvent({ type: "disconnected", data: inputSource });
      if (this._targetRay !== null) {
        this._targetRay.visible = false;
      }
      if (this._grip !== null) {
        this._grip.visible = false;
      }
      if (this._hand !== null) {
        this._hand.visible = false;
      }
      return this;
    }
    update(inputSource, frame, referenceSpace) {
      let inputPose = null;
      let gripPose = null;
      let handPose = null;
      const targetRay = this._targetRay;
      const grip = this._grip;
      const hand = this._hand;
      if (inputSource && frame.session.visibilityState !== "visible-blurred") {
        if (hand && inputSource.hand) {
          handPose = true;
          for (const inputjoint of inputSource.hand.values()) {
            const jointPose = frame.getJointPose(inputjoint, referenceSpace);
            const joint = this._getHandJoint(hand, inputjoint);
            if (jointPose !== null) {
              joint.matrix.fromArray(jointPose.transform.matrix);
              joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
              joint.matrixWorldNeedsUpdate = true;
              joint.jointRadius = jointPose.radius;
            }
            joint.visible = jointPose !== null;
          }
          const indexTip = hand.joints["index-finger-tip"];
          const thumbTip = hand.joints["thumb-tip"];
          const distance = indexTip.position.distanceTo(thumbTip.position);
          const distanceToPinch = 0.02;
          const threshold = 5e-3;
          if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
            hand.inputState.pinching = false;
            this.dispatchEvent({
              type: "pinchend",
              handedness: inputSource.handedness,
              target: this
            });
          } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
            hand.inputState.pinching = true;
            this.dispatchEvent({
              type: "pinchstart",
              handedness: inputSource.handedness,
              target: this
            });
          }
        } else {
          if (grip !== null && inputSource.gripSpace) {
            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
            if (gripPose !== null) {
              grip.matrix.fromArray(gripPose.transform.matrix);
              grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
              grip.matrixWorldNeedsUpdate = true;
              if (gripPose.linearVelocity) {
                grip.hasLinearVelocity = true;
                grip.linearVelocity.copy(gripPose.linearVelocity);
              } else {
                grip.hasLinearVelocity = false;
              }
              if (gripPose.angularVelocity) {
                grip.hasAngularVelocity = true;
                grip.angularVelocity.copy(gripPose.angularVelocity);
              } else {
                grip.hasAngularVelocity = false;
              }
            }
          }
        }
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
          if (inputPose === null && gripPose !== null) {
            inputPose = gripPose;
          }
          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
            targetRay.matrixWorldNeedsUpdate = true;
            if (inputPose.linearVelocity) {
              targetRay.hasLinearVelocity = true;
              targetRay.linearVelocity.copy(inputPose.linearVelocity);
            } else {
              targetRay.hasLinearVelocity = false;
            }
            if (inputPose.angularVelocity) {
              targetRay.hasAngularVelocity = true;
              targetRay.angularVelocity.copy(inputPose.angularVelocity);
            } else {
              targetRay.hasAngularVelocity = false;
            }
            this.dispatchEvent(_moveEvent);
          }
        }
      }
      if (targetRay !== null) {
        targetRay.visible = inputPose !== null;
      }
      if (grip !== null) {
        grip.visible = gripPose !== null;
      }
      if (hand !== null) {
        hand.visible = handPose !== null;
      }
      return this;
    }
    // private method
    _getHandJoint(hand, inputjoint) {
      if (hand.joints[inputjoint.jointName] === void 0) {
        const joint = new Group();
        joint.matrixAutoUpdate = false;
        joint.visible = false;
        hand.joints[inputjoint.jointName] = joint;
        hand.add(joint);
      }
      return hand.joints[inputjoint.jointName];
    }
  };
  var Scene = class extends Object3D {
    constructor() {
      super();
      this.isScene = true;
      this.type = "Scene";
      this.background = null;
      this.environment = null;
      this.fog = null;
      this.backgroundBlurriness = 0;
      this.backgroundIntensity = 1;
      this.backgroundRotation = new Euler();
      this.environmentIntensity = 1;
      this.environmentRotation = new Euler();
      this.overrideMaterial = null;
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      if (source.background !== null)
        this.background = source.background.clone();
      if (source.environment !== null)
        this.environment = source.environment.clone();
      if (source.fog !== null)
        this.fog = source.fog.clone();
      this.backgroundBlurriness = source.backgroundBlurriness;
      this.backgroundIntensity = source.backgroundIntensity;
      this.backgroundRotation.copy(source.backgroundRotation);
      this.environmentIntensity = source.environmentIntensity;
      this.environmentRotation.copy(source.environmentRotation);
      if (source.overrideMaterial !== null)
        this.overrideMaterial = source.overrideMaterial.clone();
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      if (this.fog !== null)
        data.object.fog = this.fog.toJSON();
      if (this.backgroundBlurriness > 0)
        data.object.backgroundBlurriness = this.backgroundBlurriness;
      if (this.backgroundIntensity !== 1)
        data.object.backgroundIntensity = this.backgroundIntensity;
      data.object.backgroundRotation = this.backgroundRotation.toArray();
      if (this.environmentIntensity !== 1)
        data.object.environmentIntensity = this.environmentIntensity;
      data.object.environmentRotation = this.environmentRotation.toArray();
      return data;
    }
  };
  var _vector1 = /* @__PURE__ */ new Vector3();
  var _vector2 = /* @__PURE__ */ new Vector3();
  var _normalMatrix = /* @__PURE__ */ new Matrix3();
  var Plane = class {
    constructor(normal = new Vector3(1, 0, 0), constant = 0) {
      this.isPlane = true;
      this.normal = normal;
      this.constant = constant;
    }
    set(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    }
    setComponents(x, y, z, w) {
      this.normal.set(x, y, z);
      this.constant = w;
      return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    }
    setFromCoplanarPoints(a, b, c) {
      const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    }
    copy(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    }
    normalize() {
      const inverseNormalLength = 1 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    }
    negate() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    }
    distanceToPoint(point) {
      return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
      return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
    }
    intersectLine(line, target) {
      const direction = line.delta(_vector1);
      const denominator = this.normal.dot(direction);
      if (denominator === 0) {
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        }
        return null;
      }
      const t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return null;
      }
      return target.copy(line.start).addScaledVector(direction, t);
    }
    intersectsLine(line) {
      const startSign = this.distanceToPoint(line.start);
      const endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
      return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
      return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
      return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
      const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
      const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
      const normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    }
    translate(offset) {
      this.constant -= offset.dot(this.normal);
      return this;
    }
    equals(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _sphere$3 = /* @__PURE__ */ new Sphere();
  var _vector$6 = /* @__PURE__ */ new Vector3();
  var Frustum = class {
    constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
      this.planes = [p0, p1, p2, p3, p4, p5];
    }
    set(p0, p1, p2, p3, p4, p5) {
      const planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    }
    copy(frustum) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        planes[i].copy(frustum.planes[i]);
      }
      return this;
    }
    setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem) {
      const planes = this.planes;
      const me = m.elements;
      const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
      const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
      const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
      const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
      if (coordinateSystem === WebGLCoordinateSystem) {
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        planes[5].setComponents(me2, me6, me10, me14).normalize();
      } else {
        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
      }
      return this;
    }
    intersectsObject(object) {
      if (object.boundingSphere !== void 0) {
        if (object.boundingSphere === null)
          object.computeBoundingSphere();
        _sphere$3.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
      } else {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      }
      return this.intersectsSphere(_sphere$3);
    }
    intersectsSprite(sprite) {
      _sphere$3.center.set(0, 0, 0);
      _sphere$3.radius = 0.7071067811865476;
      _sphere$3.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(_sphere$3);
    }
    intersectsSphere(sphere) {
      const planes = this.planes;
      const center = sphere.center;
      const negRadius = -sphere.radius;
      for (let i = 0; i < 6; i++) {
        const distance = planes[i].distanceToPoint(center);
        if (distance < negRadius) {
          return false;
        }
      }
      return true;
    }
    intersectsBox(box) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        const plane = planes[i];
        _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        if (plane.distanceToPoint(_vector$6) < 0) {
          return false;
        }
      }
      return true;
    }
    containsPoint(point) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        if (planes[i].distanceToPoint(point) < 0) {
          return false;
        }
      }
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var DepthTexture = class extends Texture {
    constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat) {
      if (format !== DepthFormat && format !== DepthStencilFormat) {
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      }
      if (type === void 0 && format === DepthFormat)
        type = UnsignedIntType;
      if (type === void 0 && format === DepthStencilFormat)
        type = UnsignedInt248Type;
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.isDepthTexture = true;
      this.image = { width, height };
      this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
      this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
      this.flipY = false;
      this.generateMipmaps = false;
      this.compareFunction = null;
    }
    copy(source) {
      super.copy(source);
      this.compareFunction = source.compareFunction;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      if (this.compareFunction !== null)
        data.compareFunction = this.compareFunction;
      return data;
    }
  };
  var PlaneGeometry = class extends BufferGeometry {
    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
      super();
      this.type = "PlaneGeometry";
      this.parameters = {
        width,
        height,
        widthSegments,
        heightSegments
      };
      const width_half = width / 2;
      const height_half = height / 2;
      const gridX = Math.floor(widthSegments);
      const gridY = Math.floor(heightSegments);
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      const segment_width = width / gridX;
      const segment_height = height / gridY;
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segment_height - height_half;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segment_width - width_half;
          vertices.push(x, -y, 0);
          normals.push(0, 0, 1);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = ix + gridX1 * iy;
          const b = ix + gridX1 * (iy + 1);
          const c = ix + 1 + gridX1 * (iy + 1);
          const d = ix + 1 + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    copy(source) {
      super.copy(source);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
    static fromJSON(data) {
      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
    }
  };
  var MeshDepthMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshDepthMaterial = true;
      this.type = "MeshDepthMaterial";
      this.depthPacking = BasicDepthPacking;
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.depthPacking = source.depthPacking;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    }
  };
  var MeshDistanceMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshDistanceMaterial = true;
      this.type = "MeshDistanceMaterial";
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      return this;
    }
  };
  function convertArray(array, type, forceClone) {
    if (!array || // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  }
  function isTypedArray(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  }
  var Interpolant = class {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      this.parameterPositions = parameterPositions;
      this._cachedIndex = 0;
      this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
      this.sampleValues = sampleValues;
      this.valueSize = sampleSize;
      this.settings = null;
      this.DefaultSettings_ = {};
    }
    evaluate(t) {
      const pp = this.parameterPositions;
      let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
      validate_interval: {
        seek: {
          let right;
          linear_scan: {
            forward_scan:
              if (!(t < t1)) {
                for (let giveUpAt = i1 + 2; ; ) {
                  if (t1 === void 0) {
                    if (t < t0)
                      break forward_scan;
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.copySampleValue_(i1 - 1);
                  }
                  if (i1 === giveUpAt)
                    break;
                  t0 = t1;
                  t1 = pp[++i1];
                  if (t < t1) {
                    break seek;
                  }
                }
                right = pp.length;
                break linear_scan;
              }
            if (!(t >= t0)) {
              const t1global = pp[1];
              if (t < t1global) {
                i1 = 2;
                t0 = t1global;
              }
              for (let giveUpAt = i1 - 2; ; ) {
                if (t0 === void 0) {
                  this._cachedIndex = 0;
                  return this.copySampleValue_(0);
                }
                if (i1 === giveUpAt)
                  break;
                t1 = t0;
                t0 = pp[--i1 - 1];
                if (t >= t0) {
                  break seek;
                }
              }
              right = i1;
              i1 = 0;
              break linear_scan;
            }
            break validate_interval;
          }
          while (i1 < right) {
            const mid = i1 + right >>> 1;
            if (t < pp[mid]) {
              right = mid;
            } else {
              i1 = mid + 1;
            }
          }
          t1 = pp[i1];
          t0 = pp[i1 - 1];
          if (t0 === void 0) {
            this._cachedIndex = 0;
            return this.copySampleValue_(0);
          }
          if (t1 === void 0) {
            i1 = pp.length;
            this._cachedIndex = i1;
            return this.copySampleValue_(i1 - 1);
          }
        }
        this._cachedIndex = i1;
        this.intervalChanged_(i1, t0, t1);
      }
      return this.interpolate_(i1, t0, t, t1);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(index) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
      for (let i = 0; i !== stride; ++i) {
        result[i] = values[offset + i];
      }
      return result;
    }
    // Template methods for derived classes:
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  };
  var CubicInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      this._weightPrev = -0;
      this._offsetPrev = -0;
      this._weightNext = -0;
      this._offsetNext = -0;
      this.DefaultSettings_ = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
    }
    intervalChanged_(i1, t0, t1) {
      const pp = this.parameterPositions;
      let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
      if (tPrev === void 0) {
        switch (this.getSettings_().endingStart) {
          case ZeroSlopeEnding:
            iPrev = i1;
            tPrev = 2 * t0 - t1;
            break;
          case WrapAroundEnding:
            iPrev = pp.length - 2;
            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
            break;
          default:
            iPrev = i1;
            tPrev = t1;
        }
      }
      if (tNext === void 0) {
        switch (this.getSettings_().endingEnd) {
          case ZeroSlopeEnding:
            iNext = i1;
            tNext = 2 * t1 - t0;
            break;
          case WrapAroundEnding:
            iNext = 1;
            tNext = t1 + pp[1] - pp[0];
            break;
          default:
            iNext = i1 - 1;
            tNext = t0;
        }
      }
      const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
      this._weightPrev = halfDt / (t0 - tPrev);
      this._weightNext = halfDt / (tNext - t1);
      this._offsetPrev = iPrev * stride;
      this._offsetNext = iNext * stride;
    }
    interpolate_(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
      const sP = -wP * ppp + 2 * wP * pp - wP * p;
      const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
      const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
      const sN = wN * ppp - wN * pp;
      for (let i = 0; i !== stride; ++i) {
        result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
      }
      return result;
    }
  };
  var LinearInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
      for (let i = 0; i !== stride; ++i) {
        result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
      }
      return result;
    }
  };
  var DiscreteInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1) {
      return this.copySampleValue_(i1 - 1);
    }
  };
  var KeyframeTrack = class {
    constructor(name, times, values, interpolation) {
      if (name === void 0)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (times === void 0 || times.length === 0)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
      this.name = name;
      this.times = convertArray(times, this.TimeBufferType);
      this.values = convertArray(values, this.ValueBufferType);
      this.setInterpolation(interpolation || this.DefaultInterpolation);
    }
    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):
    static toJSON(track) {
      const trackType = track.constructor;
      let json;
      if (trackType.toJSON !== this.toJSON) {
        json = trackType.toJSON(track);
      } else {
        json = {
          "name": track.name,
          "times": convertArray(track.times, Array),
          "values": convertArray(track.values, Array)
        };
        const interpolation = track.getInterpolation();
        if (interpolation !== track.DefaultInterpolation) {
          json.interpolation = interpolation;
        }
      }
      json.type = track.ValueTypeName;
      return json;
    }
    InterpolantFactoryMethodDiscrete(result) {
      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodLinear(result) {
      return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodSmooth(result) {
      return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    setInterpolation(interpolation) {
      let factoryMethod;
      switch (interpolation) {
        case InterpolateDiscrete:
          factoryMethod = this.InterpolantFactoryMethodDiscrete;
          break;
        case InterpolateLinear:
          factoryMethod = this.InterpolantFactoryMethodLinear;
          break;
        case InterpolateSmooth:
          factoryMethod = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (factoryMethod === void 0) {
        const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) {
          if (interpolation !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
          } else {
            throw new Error(message);
          }
        }
        console.warn("THREE.KeyframeTrack:", message);
        return this;
      }
      this.createInterpolant = factoryMethod;
      return this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
          return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
          return InterpolateSmooth;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    // move all keyframes either forwards or backwards in time
    shift(timeOffset) {
      if (timeOffset !== 0) {
        const times = this.times;
        for (let i = 0, n = times.length; i !== n; ++i) {
          times[i] += timeOffset;
        }
      }
      return this;
    }
    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale(timeScale) {
      if (timeScale !== 1) {
        const times = this.times;
        for (let i = 0, n = times.length; i !== n; ++i) {
          times[i] *= timeScale;
        }
      }
      return this;
    }
    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim(startTime, endTime) {
      const times = this.times, nKeys = times.length;
      let from = 0, to = nKeys - 1;
      while (from !== nKeys && times[from] < startTime) {
        ++from;
      }
      while (to !== -1 && times[to] > endTime) {
        --to;
      }
      ++to;
      if (from !== 0 || to !== nKeys) {
        if (from >= to) {
          to = Math.max(to, 1);
          from = to - 1;
        }
        const stride = this.getValueSize();
        this.times = times.slice(from, to);
        this.values = this.values.slice(from * stride, to * stride);
      }
      return this;
    }
    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    validate() {
      let valid = true;
      const valueSize = this.getValueSize();
      if (valueSize - Math.floor(valueSize) !== 0) {
        console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
        valid = false;
      }
      const times = this.times, values = this.values, nKeys = times.length;
      if (nKeys === 0) {
        console.error("THREE.KeyframeTrack: Track is empty.", this);
        valid = false;
      }
      let prevTime = null;
      for (let i = 0; i !== nKeys; i++) {
        const currTime = times[i];
        if (typeof currTime === "number" && isNaN(currTime)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
          valid = false;
          break;
        }
        if (prevTime !== null && prevTime > currTime) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
          valid = false;
          break;
        }
        prevTime = currTime;
      }
      if (values !== void 0) {
        if (isTypedArray(values)) {
          for (let i = 0, n = values.length; i !== n; ++i) {
            const value = values[i];
            if (isNaN(value)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
              valid = false;
              break;
            }
          }
        }
      }
      return valid;
    }
    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    optimize() {
      const times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
      let writeIndex = 1;
      for (let i = 1; i < lastIndex; ++i) {
        let keep = false;
        const time = times[i];
        const timeNext = times[i + 1];
        if (time !== timeNext && (i !== 1 || time !== times[0])) {
          if (!smoothInterpolation) {
            const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
            for (let j = 0; j !== stride; ++j) {
              const value = values[offset + j];
              if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                keep = true;
                break;
              }
            }
          } else {
            keep = true;
          }
        }
        if (keep) {
          if (i !== writeIndex) {
            times[writeIndex] = times[i];
            const readOffset = i * stride, writeOffset = writeIndex * stride;
            for (let j = 0; j !== stride; ++j) {
              values[writeOffset + j] = values[readOffset + j];
            }
          }
          ++writeIndex;
        }
      }
      if (lastIndex > 0) {
        times[writeIndex] = times[lastIndex];
        for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
          values[writeOffset + j] = values[readOffset + j];
        }
        ++writeIndex;
      }
      if (writeIndex !== times.length) {
        this.times = times.slice(0, writeIndex);
        this.values = values.slice(0, writeIndex * stride);
      } else {
        this.times = times;
        this.values = values;
      }
      return this;
    }
    clone() {
      const times = this.times.slice();
      const values = this.values.slice();
      const TypedKeyframeTrack = this.constructor;
      const track = new TypedKeyframeTrack(this.name, times, values);
      track.createInterpolant = this.createInterpolant;
      return track;
    }
  };
  KeyframeTrack.prototype.TimeBufferType = Float32Array;
  KeyframeTrack.prototype.ValueBufferType = Float32Array;
  KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
  var BooleanKeyframeTrack = class extends KeyframeTrack {
    // No interpolation parameter because only InterpolateDiscrete is valid.
    constructor(name, times, values) {
      super(name, times, values);
    }
  };
  BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
  BooleanKeyframeTrack.prototype.ValueBufferType = Array;
  BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var ColorKeyframeTrack = class extends KeyframeTrack {
  };
  ColorKeyframeTrack.prototype.ValueTypeName = "color";
  var NumberKeyframeTrack = class extends KeyframeTrack {
  };
  NumberKeyframeTrack.prototype.ValueTypeName = "number";
  var QuaternionLinearInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
      let offset = i1 * stride;
      for (let end = offset + stride; offset !== end; offset += 4) {
        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
      }
      return result;
    }
  };
  var QuaternionKeyframeTrack = class extends KeyframeTrack {
    InterpolantFactoryMethodLinear(result) {
      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  };
  QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
  QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var StringKeyframeTrack = class extends KeyframeTrack {
    // No interpolation parameter because only InterpolateDiscrete is valid.
    constructor(name, times, values) {
      super(name, times, values);
    }
  };
  StringKeyframeTrack.prototype.ValueTypeName = "string";
  StringKeyframeTrack.prototype.ValueBufferType = Array;
  StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var VectorKeyframeTrack = class extends KeyframeTrack {
  };
  VectorKeyframeTrack.prototype.ValueTypeName = "vector";
  var Cache = {
    enabled: false,
    files: {},
    add: function(key, file) {
      if (this.enabled === false)
        return;
      this.files[key] = file;
    },
    get: function(key) {
      if (this.enabled === false)
        return;
      return this.files[key];
    },
    remove: function(key) {
      delete this.files[key];
    },
    clear: function() {
      this.files = {};
    }
  };
  var LoadingManager = class {
    constructor(onLoad, onProgress, onError) {
      const scope = this;
      let isLoading = false;
      let itemsLoaded = 0;
      let itemsTotal = 0;
      let urlModifier = void 0;
      const handlers = [];
      this.onStart = void 0;
      this.onLoad = onLoad;
      this.onProgress = onProgress;
      this.onError = onError;
      this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
          if (scope.onStart !== void 0) {
            scope.onStart(url, itemsLoaded, itemsTotal);
          }
        }
        isLoading = true;
      };
      this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope.onProgress !== void 0) {
          scope.onProgress(url, itemsLoaded, itemsTotal);
        }
        if (itemsLoaded === itemsTotal) {
          isLoading = false;
          if (scope.onLoad !== void 0) {
            scope.onLoad();
          }
        }
      };
      this.itemError = function(url) {
        if (scope.onError !== void 0) {
          scope.onError(url);
        }
      };
      this.resolveURL = function(url) {
        if (urlModifier) {
          return urlModifier(url);
        }
        return url;
      };
      this.setURLModifier = function(transform) {
        urlModifier = transform;
        return this;
      };
      this.addHandler = function(regex, loader) {
        handlers.push(regex, loader);
        return this;
      };
      this.removeHandler = function(regex) {
        const index = handlers.indexOf(regex);
        if (index !== -1) {
          handlers.splice(index, 2);
        }
        return this;
      };
      this.getHandler = function(file) {
        for (let i = 0, l = handlers.length; i < l; i += 2) {
          const regex = handlers[i];
          const loader = handlers[i + 1];
          if (regex.global)
            regex.lastIndex = 0;
          if (regex.test(file)) {
            return loader;
          }
        }
        return null;
      };
    }
  };
  var DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
  var Loader = class {
    constructor(manager) {
      this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
      this.crossOrigin = "anonymous";
      this.withCredentials = false;
      this.path = "";
      this.resourcePath = "";
      this.requestHeader = {};
    }
    load() {
    }
    loadAsync(url, onProgress) {
      const scope = this;
      return new Promise(function(resolve, reject) {
        scope.load(url, resolve, onProgress, reject);
      });
    }
    parse() {
    }
    setCrossOrigin(crossOrigin) {
      this.crossOrigin = crossOrigin;
      return this;
    }
    setWithCredentials(value) {
      this.withCredentials = value;
      return this;
    }
    setPath(path) {
      this.path = path;
      return this;
    }
    setResourcePath(resourcePath) {
      this.resourcePath = resourcePath;
      return this;
    }
    setRequestHeader(requestHeader) {
      this.requestHeader = requestHeader;
      return this;
    }
  };
  Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
  var ImageLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      const image = createElementNS("img");
      function onImageLoad() {
        removeEventListeners();
        Cache.add(url, this);
        if (onLoad)
          onLoad(this);
        scope.manager.itemEnd(url);
      }
      function onImageError(event) {
        removeEventListeners();
        if (onError)
          onError(event);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }
      function removeEventListeners() {
        image.removeEventListener("load", onImageLoad, false);
        image.removeEventListener("error", onImageError, false);
      }
      image.addEventListener("load", onImageLoad, false);
      image.addEventListener("error", onImageError, false);
      if (url.slice(0, 5) !== "data:") {
        if (this.crossOrigin !== void 0)
          image.crossOrigin = this.crossOrigin;
      }
      scope.manager.itemStart(url);
      image.src = url;
      return image;
    }
  };
  var TextureLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      const texture = new Texture();
      const loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      loader.load(url, function(image) {
        texture.image = image;
        texture.needsUpdate = true;
        if (onLoad !== void 0) {
          onLoad(texture);
        }
      }, onProgress, onError);
      return texture;
    }
  };
  var OrthographicCamera = class extends Camera {
    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
      super();
      this.isOrthographicCamera = true;
      this.type = "OrthographicCamera";
      this.zoom = 1;
      this.view = null;
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
      this.near = near;
      this.far = far;
      this.updateProjectionMatrix();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      return this;
    }
    setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
    clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const dx = (this.right - this.left) / (2 * this.zoom);
      const dy = (this.top - this.bottom) / (2 * this.zoom);
      const cx = (this.right + this.left) / 2;
      const cy = (this.top + this.bottom) / 2;
      let left = cx - dx;
      let right = cx + dx;
      let top = cy + dy;
      let bottom = cy - dy;
      if (this.view !== null && this.view.enabled) {
        const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
        const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      return data;
    }
  };
  var ArrayCamera = class extends PerspectiveCamera {
    constructor(array = []) {
      super();
      this.isArrayCamera = true;
      this.cameras = array;
      this.index = 0;
    }
  };
  var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
  var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
  var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
  var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
  var _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
  var _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
  var _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
  var _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
  var _trackRe = new RegExp(
    "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
  );
  var _supportedObjectNames = ["material", "materials", "bones", "map"];
  var Composite = class {
    constructor(targetGroup, path, optionalParsedPath) {
      const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
      this._targetGroup = targetGroup;
      this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    getValue(array, offset) {
      this.bind();
      const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
      if (binding !== void 0)
        binding.getValue(array, offset);
    }
    setValue(array, offset) {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].setValue(array, offset);
      }
    }
    bind() {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].bind();
      }
    }
    unbind() {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].unbind();
      }
    }
  };
  var PropertyBinding = class {
    constructor(rootNode, path, parsedPath) {
      this.path = path;
      this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
      this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
      this.rootNode = rootNode;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
    static create(root, path, parsedPath) {
      if (!(root && root.isAnimationObjectGroup)) {
        return new PropertyBinding(root, path, parsedPath);
      } else {
        return new PropertyBinding.Composite(root, path, parsedPath);
      }
    }
    /**
     * Replaces spaces with underscores and removes unsupported characters from
     * node names, to ensure compatibility with parseTrackName().
     *
     * @param {string} name Node name to be sanitized.
     * @return {string}
     */
    static sanitizeNodeName(name) {
      return name.replace(/\s/g, "_").replace(_reservedRe, "");
    }
    static parseTrackName(trackName) {
      const matches = _trackRe.exec(trackName);
      if (matches === null) {
        throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
      }
      const results = {
        // directoryName: matches[ 1 ], // (tschw) currently unused
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        // required
        propertyIndex: matches[6]
      };
      const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
      if (lastDot !== void 0 && lastDot !== -1) {
        const objectName = results.nodeName.substring(lastDot + 1);
        if (_supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
      }
      return results;
    }
    static findNode(root, nodeName) {
      if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      }
      if (root.skeleton) {
        const bone = root.skeleton.getBoneByName(nodeName);
        if (bone !== void 0) {
          return bone;
        }
      }
      if (root.children) {
        const searchNodeSubtree = function(children) {
          for (let i = 0; i < children.length; i++) {
            const childNode = children[i];
            if (childNode.name === nodeName || childNode.uuid === nodeName) {
              return childNode;
            }
            const result = searchNodeSubtree(childNode.children);
            if (result)
              return result;
          }
          return null;
        };
        const subTreeNode = searchNodeSubtree(root.children);
        if (subTreeNode) {
          return subTreeNode;
        }
      }
      return null;
    }
    // these are used to "bind" a nonexistent property
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    // Getters
    _getValue_direct(buffer, offset) {
      buffer[offset] = this.targetObject[this.propertyName];
    }
    _getValue_array(buffer, offset) {
      const source = this.resolvedProperty;
      for (let i = 0, n = source.length; i !== n; ++i) {
        buffer[offset++] = source[i];
      }
    }
    _getValue_arrayElement(buffer, offset) {
      buffer[offset] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(buffer, offset) {
      this.resolvedProperty.toArray(buffer, offset);
    }
    // Direct
    _setValue_direct(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
    }
    _setValue_direct_setNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // EntireArray
    _setValue_array(buffer, offset) {
      const dest = this.resolvedProperty;
      for (let i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
    }
    _setValue_array_setNeedsUpdate(buffer, offset) {
      const dest = this.resolvedProperty;
      for (let i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
      const dest = this.resolvedProperty;
      for (let i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // ArrayElement
    _setValue_arrayElement(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
    }
    _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // HasToFromArray
    _setValue_fromArray(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
    }
    _setValue_fromArray_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(targetArray, offset) {
      this.bind();
      this.getValue(targetArray, offset);
    }
    _setValue_unbound(sourceArray, offset) {
      this.bind();
      this.setValue(sourceArray, offset);
    }
    // create getter / setter pair for a property in the scene graph
    bind() {
      let targetObject = this.node;
      const parsedPath = this.parsedPath;
      const objectName = parsedPath.objectName;
      const propertyName = parsedPath.propertyName;
      let propertyIndex = parsedPath.propertyIndex;
      if (!targetObject) {
        targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
        this.node = targetObject;
      }
      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable;
      if (!targetObject) {
        console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
        return;
      }
      if (objectName) {
        let objectIndex = parsedPath.objectIndex;
        switch (objectName) {
          case "materials":
            if (!targetObject.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!targetObject.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            targetObject = targetObject.material.materials;
            break;
          case "bones":
            if (!targetObject.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            targetObject = targetObject.skeleton.bones;
            for (let i = 0; i < targetObject.length; i++) {
              if (targetObject[i].name === objectIndex) {
                objectIndex = i;
                break;
              }
            }
            break;
          case "map":
            if ("map" in targetObject) {
              targetObject = targetObject.map;
              break;
            }
            if (!targetObject.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!targetObject.material.map) {
              console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
              return;
            }
            targetObject = targetObject.material.map;
            break;
          default:
            if (targetObject[objectName] === void 0) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            targetObject = targetObject[objectName];
        }
        if (objectIndex !== void 0) {
          if (targetObject[objectIndex] === void 0) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
            return;
          }
          targetObject = targetObject[objectIndex];
        }
      }
      const nodeProperty = targetObject[propertyName];
      if (nodeProperty === void 0) {
        const nodeName = parsedPath.nodeName;
        console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
        return;
      }
      let versioning = this.Versioning.None;
      this.targetObject = targetObject;
      if (targetObject.isMaterial === true) {
        versioning = this.Versioning.NeedsUpdate;
      } else if (targetObject.isObject3D === true) {
        versioning = this.Versioning.MatrixWorldNeedsUpdate;
      }
      let bindingType = this.BindingType.Direct;
      if (propertyIndex !== void 0) {
        if (propertyName === "morphTargetInfluences") {
          if (!targetObject.geometry) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            return;
          }
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        }
        bindingType = this.BindingType.ArrayElement;
        this.resolvedProperty = nodeProperty;
        this.propertyIndex = propertyIndex;
      } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
        bindingType = this.BindingType.HasFromToArray;
        this.resolvedProperty = nodeProperty;
      } else if (Array.isArray(nodeProperty)) {
        bindingType = this.BindingType.EntireArray;
        this.resolvedProperty = nodeProperty;
      } else {
        this.propertyName = propertyName;
      }
      this.getValue = this.GetterByBindingType[bindingType];
      this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    }
    unbind() {
      this.node = null;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
  };
  PropertyBinding.Composite = Composite;
  PropertyBinding.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  };
  PropertyBinding.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  };
  PropertyBinding.prototype.GetterByBindingType = [
    PropertyBinding.prototype._getValue_direct,
    PropertyBinding.prototype._getValue_array,
    PropertyBinding.prototype._getValue_arrayElement,
    PropertyBinding.prototype._getValue_toArray
  ];
  PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
    [
      // Direct
      PropertyBinding.prototype._setValue_direct,
      PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
      PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
      // EntireArray
      PropertyBinding.prototype._setValue_array,
      PropertyBinding.prototype._setValue_array_setNeedsUpdate,
      PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
      // ArrayElement
      PropertyBinding.prototype._setValue_arrayElement,
      PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
      PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
      // HasToFromArray
      PropertyBinding.prototype._setValue_fromArray,
      PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
      PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
  ];
  var _controlInterpolantsResultBuffer = new Float32Array(1);
  function getByteLength(width, height, format, type) {
    const typeByteLength = getTextureTypeByteLength(type);
    switch (format) {
      case AlphaFormat:
        return width * height;
      case LuminanceFormat:
        return width * height;
      case LuminanceAlphaFormat:
        return width * height * 2;
      case RedFormat:
        return width * height / typeByteLength.components * typeByteLength.byteLength;
      case RedIntegerFormat:
        return width * height / typeByteLength.components * typeByteLength.byteLength;
      case RGFormat:
        return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
      case RGIntegerFormat:
        return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
      case RGBFormat:
        return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;
      case RGBAFormat:
        return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
      case RGBAIntegerFormat:
        return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
      case RGB_S3TC_DXT1_Format:
      case RGBA_S3TC_DXT1_Format:
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
      case RGBA_S3TC_DXT3_Format:
      case RGBA_S3TC_DXT5_Format:
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
      case RGB_PVRTC_2BPPV1_Format:
      case RGBA_PVRTC_2BPPV1_Format:
        return Math.max(width, 16) * Math.max(height, 8) / 4;
      case RGB_PVRTC_4BPPV1_Format:
      case RGBA_PVRTC_4BPPV1_Format:
        return Math.max(width, 8) * Math.max(height, 8) / 2;
      case RGB_ETC1_Format:
      case RGB_ETC2_Format:
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
      case RGBA_ETC2_EAC_Format:
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
      case RGBA_ASTC_4x4_Format:
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
      case RGBA_ASTC_5x4_Format:
        return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
      case RGBA_ASTC_5x5_Format:
        return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
      case RGBA_ASTC_6x5_Format:
        return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
      case RGBA_ASTC_6x6_Format:
        return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
      case RGBA_ASTC_8x5_Format:
        return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
      case RGBA_ASTC_8x6_Format:
        return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
      case RGBA_ASTC_8x8_Format:
        return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
      case RGBA_ASTC_10x5_Format:
        return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
      case RGBA_ASTC_10x6_Format:
        return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
      case RGBA_ASTC_10x8_Format:
        return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
      case RGBA_ASTC_10x10_Format:
        return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
      case RGBA_ASTC_12x10_Format:
        return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
      case RGBA_ASTC_12x12_Format:
        return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
      case RGBA_BPTC_Format:
      case RGB_BPTC_SIGNED_Format:
      case RGB_BPTC_UNSIGNED_Format:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
      case RED_RGTC1_Format:
      case SIGNED_RED_RGTC1_Format:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
      case RED_GREEN_RGTC2_Format:
      case SIGNED_RED_GREEN_RGTC2_Format:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
    }
    throw new Error(
      `Unable to determine texture byte length for ${format} format.`
    );
  }
  function getTextureTypeByteLength(type) {
    switch (type) {
      case UnsignedByteType:
      case ByteType:
        return { byteLength: 1, components: 1 };
      case UnsignedShortType:
      case ShortType:
      case HalfFloatType:
        return { byteLength: 2, components: 1 };
      case UnsignedShort4444Type:
      case UnsignedShort5551Type:
        return { byteLength: 2, components: 4 };
      case UnsignedIntType:
      case IntType:
      case FloatType:
        return { byteLength: 4, components: 1 };
      case UnsignedInt5999Type:
        return { byteLength: 4, components: 3 };
    }
    throw new Error(`Unknown texture type ${type}.`);
  }
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
      revision: REVISION
    } }));
  }
  if (typeof window !== "undefined") {
    if (window.__THREE__) {
      console.warn("WARNING: Multiple instances of Three.js being imported.");
    } else {
      window.__THREE__ = REVISION;
    }
  }

  // node_modules/.pnpm/three@0.173.0/node_modules/three/build/three.module.js
  function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
      animationLoop(time, frame);
      requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
      start: function() {
        if (isAnimating === true)
          return;
        if (animationLoop === null)
          return;
        requestId = context.requestAnimationFrame(onAnimationFrame);
        isAnimating = true;
      },
      stop: function() {
        context.cancelAnimationFrame(requestId);
        isAnimating = false;
      },
      setAnimationLoop: function(callback) {
        animationLoop = callback;
      },
      setContext: function(value) {
        context = value;
      }
    };
  }
  function WebGLAttributes(gl) {
    const buffers = /* @__PURE__ */ new WeakMap();
    function createBuffer(attribute, bufferType) {
      const array = attribute.array;
      const usage = attribute.usage;
      const size = array.byteLength;
      const buffer = gl.createBuffer();
      gl.bindBuffer(bufferType, buffer);
      gl.bufferData(bufferType, array, usage);
      attribute.onUploadCallback();
      let type;
      if (array instanceof Float32Array) {
        type = gl.FLOAT;
      } else if (array instanceof Uint16Array) {
        if (attribute.isFloat16BufferAttribute) {
          type = gl.HALF_FLOAT;
        } else {
          type = gl.UNSIGNED_SHORT;
        }
      } else if (array instanceof Int16Array) {
        type = gl.SHORT;
      } else if (array instanceof Uint32Array) {
        type = gl.UNSIGNED_INT;
      } else if (array instanceof Int32Array) {
        type = gl.INT;
      } else if (array instanceof Int8Array) {
        type = gl.BYTE;
      } else if (array instanceof Uint8Array) {
        type = gl.UNSIGNED_BYTE;
      } else if (array instanceof Uint8ClampedArray) {
        type = gl.UNSIGNED_BYTE;
      } else {
        throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
      }
      return {
        buffer,
        type,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version,
        size
      };
    }
    function updateBuffer(buffer, attribute, bufferType) {
      const array = attribute.array;
      const updateRanges = attribute.updateRanges;
      gl.bindBuffer(bufferType, buffer);
      if (updateRanges.length === 0) {
        gl.bufferSubData(bufferType, 0, array);
      } else {
        updateRanges.sort((a, b) => a.start - b.start);
        let mergeIndex = 0;
        for (let i = 1; i < updateRanges.length; i++) {
          const previousRange = updateRanges[mergeIndex];
          const range = updateRanges[i];
          if (range.start <= previousRange.start + previousRange.count + 1) {
            previousRange.count = Math.max(
              previousRange.count,
              range.start + range.count - previousRange.start
            );
          } else {
            ++mergeIndex;
            updateRanges[mergeIndex] = range;
          }
        }
        updateRanges.length = mergeIndex + 1;
        for (let i = 0, l = updateRanges.length; i < l; i++) {
          const range = updateRanges[i];
          gl.bufferSubData(
            bufferType,
            range.start * array.BYTES_PER_ELEMENT,
            array,
            range.start,
            range.count
          );
        }
        attribute.clearUpdateRanges();
      }
      attribute.onUploadCallback();
    }
    function get(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      return buffers.get(attribute);
    }
    function remove(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data) {
        gl.deleteBuffer(data.buffer);
        buffers.delete(attribute);
      }
    }
    function update(attribute, bufferType) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      if (attribute.isGLBufferAttribute) {
        const cached = buffers.get(attribute);
        if (!cached || cached.version < attribute.version) {
          buffers.set(attribute, {
            buffer: attribute.buffer,
            type: attribute.type,
            bytesPerElement: attribute.elementSize,
            version: attribute.version
          });
        }
        return;
      }
      const data = buffers.get(attribute);
      if (data === void 0) {
        buffers.set(attribute, createBuffer(attribute, bufferType));
      } else if (data.version < attribute.version) {
        if (data.size !== attribute.array.byteLength) {
          throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
        }
        updateBuffer(data.buffer, attribute, bufferType);
        data.version = attribute.version;
      }
    }
    return {
      get,
      remove,
      update
    };
  }
  var alphahash_fragment = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
  var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var alphatest_fragment = "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif";
  var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
  var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
  var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
  var batching_pars_vertex = "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif";
  var batching_vertex = "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";
  var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
  var bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
  var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif";
  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
  var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
  var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif";
  var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
  var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n		emissiveColor = sRGBTransferEOTF( emissiveColor );\n	#endif\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
  var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
  var colorspace_pars_fragment = "vec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
  var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
  var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
  var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
  var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
  var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
  var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
  var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
  var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
  var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
  var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
  var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
  var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
  var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
  var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
  var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
  var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
  var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";
  var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
  var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
  var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
  var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
  var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif";
  var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif";
  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
  var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
  var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
  var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
  var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
  var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
  var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
  var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
  var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
  var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
  var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
  var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
  var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
  var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
  var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif";
  var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
  var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
  var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
  var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
  var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif";
  var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
  var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
  var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
  var transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
  var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		#else\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
  var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
  var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
  var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
  var vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
  var fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
  var vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
  var fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
  var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
  var fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
  var vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
  var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}";
  var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
  var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
  var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
  var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
  var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
  var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
  var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
  var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
  var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
  var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
  var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
  var ShaderChunk = {
    alphahash_fragment,
    alphahash_pars_fragment,
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    batching_pars_vertex,
    batching_vertex,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    iridescence_fragment,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    colorspace_fragment,
    colorspace_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_pars_fragment,
    lights_lambert_fragment,
    lights_lambert_pars_fragment,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphinstance_vertex,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    iridescence_pars_fragment,
    opaque_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    worldpos_vertex,
    background_vert: vertex$h,
    background_frag: fragment$h,
    backgroundCube_vert: vertex$g,
    backgroundCube_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1
  };
  var UniformsLib = {
    common: {
      diffuse: { value: /* @__PURE__ */ new Color(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: /* @__PURE__ */ new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      alphaTest: { value: 0 }
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: /* @__PURE__ */ new Matrix3() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      // basic, lambert, phong
      ior: { value: 1.5 },
      // physical
      refractionRatio: { value: 0.98 }
      // basic, lambert, phong
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      bumpScale: { value: 1 }
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    gradientmap: {
      gradientMap: { value: null }
    },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: /* @__PURE__ */ new Color(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: { value: [], properties: {
        direction: {},
        color: {}
      } },
      directionalLightShadows: { value: [], properties: {
        shadowIntensity: 1,
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: { value: [], properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      } },
      spotLightShadows: { value: [], properties: {
        shadowIntensity: 1,
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: { value: [], properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      } },
      pointLightShadows: { value: [], properties: {
        shadowIntensity: 1,
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      } },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: { value: [], properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      } },
      // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
      rectAreaLights: { value: [], properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      } },
      ltc_1: { value: null },
      ltc_2: { value: null }
    },
    points: {
      diffuse: { value: /* @__PURE__ */ new Color(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      alphaTest: { value: 0 },
      uvTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    sprite: {
      diffuse: { value: /* @__PURE__ */ new Color(16777215) },
      opacity: { value: 1 },
      center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: /* @__PURE__ */ new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      alphaTest: { value: 0 }
    }
  };
  var ShaderLib = {
    basic: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: /* @__PURE__ */ new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: /* @__PURE__ */ new Color(0) },
          specular: { value: /* @__PURE__ */ new Color(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: /* @__PURE__ */ new Color(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: /* @__PURE__ */ new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        {
          matcap: { value: null }
        }
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.points,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 }
        }
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        {
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.meshnormal_vert,
      fragmentShader: ShaderChunk.meshnormal_frag
    },
    sprite: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.sprite,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: { value: /* @__PURE__ */ new Matrix3() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 }
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: /* @__PURE__ */ new Matrix3() }
      },
      vertexShader: ShaderChunk.backgroundCube_vert,
      fragmentShader: ShaderChunk.backgroundCube_frag
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 }
      },
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: { value: /* @__PURE__ */ new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        {
          color: { value: /* @__PURE__ */ new Color(0) },
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag
    }
  };
  ShaderLib.physical = {
    uniforms: /* @__PURE__ */ mergeUniforms([
      ShaderLib.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        clearcoatNormalMap: { value: null },
        clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        dispersion: { value: 0 },
        iridescence: { value: 0 },
        iridescenceMap: { value: null },
        iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        iridescenceIOR: { value: 1.3 },
        iridescenceThicknessMinimum: { value: 100 },
        iridescenceThicknessMaximum: { value: 400 },
        iridescenceThicknessMap: { value: null },
        iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        sheen: { value: 0 },
        sheenColor: { value: /* @__PURE__ */ new Color(0) },
        sheenColorMap: { value: null },
        sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        sheenRoughness: { value: 1 },
        sheenRoughnessMap: { value: null },
        sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        transmission: { value: 0 },
        transmissionMap: { value: null },
        transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
        transmissionSamplerMap: { value: null },
        thickness: { value: 0 },
        thicknessMap: { value: null },
        thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        attenuationDistance: { value: 0 },
        attenuationColor: { value: /* @__PURE__ */ new Color(0) },
        specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
        specularColorMap: { value: null },
        specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        specularIntensity: { value: 1 },
        specularIntensityMap: { value: null },
        specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        anisotropyVector: { value: /* @__PURE__ */ new Vector2() },
        anisotropyMap: { value: null },
        anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  };
  var _rgb = { r: 0, b: 0, g: 0 };
  var _e1$1 = /* @__PURE__ */ new Euler();
  var _m1$12 = /* @__PURE__ */ new Matrix4();
  function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = alpha === true ? 0 : 1;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function getBackground(scene) {
      let background = scene.isScene === true ? scene.background : null;
      if (background && background.isTexture) {
        const usePMREM = scene.backgroundBlurriness > 0;
        background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
      }
      return background;
    }
    function render(scene) {
      let forceClear = false;
      const background = getBackground(scene);
      if (background === null) {
        setClear(clearColor, clearAlpha);
      } else if (background && background.isColor) {
        setClear(background, 1);
        forceClear = true;
      }
      const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
      if (environmentBlendMode === "additive") {
        state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
      } else if (environmentBlendMode === "alpha-blend") {
        state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
      }
      if (renderer.autoClear || forceClear) {
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      }
    }
    function addToRenderList(renderList, scene) {
      const background = getBackground(scene);
      if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
        if (boxMesh === void 0) {
          boxMesh = new Mesh(
            new BoxGeometry(1, 1, 1),
            new ShaderMaterial({
              name: "BackgroundCubeMaterial",
              uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
              vertexShader: ShaderLib.backgroundCube.vertexShader,
              fragmentShader: ShaderLib.backgroundCube.fragmentShader,
              side: BackSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            })
          );
          boxMesh.geometry.deleteAttribute("normal");
          boxMesh.geometry.deleteAttribute("uv");
          boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
            this.matrixWorld.copyPosition(camera.matrixWorld);
          };
          Object.defineProperty(boxMesh.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          });
          objects.update(boxMesh);
        }
        _e1$1.copy(scene.backgroundRotation);
        _e1$1.x *= -1;
        _e1$1.y *= -1;
        _e1$1.z *= -1;
        if (background.isCubeTexture && background.isRenderTargetTexture === false) {
          _e1$1.y *= -1;
          _e1$1.z *= -1;
        }
        boxMesh.material.uniforms.envMap.value = background;
        boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
        boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
        boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
        boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$12.makeRotationFromEuler(_e1$1));
        boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          boxMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        boxMesh.layers.enableAll();
        renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
      } else if (background && background.isTexture) {
        if (planeMesh === void 0) {
          planeMesh = new Mesh(
            new PlaneGeometry(2, 2),
            new ShaderMaterial({
              name: "BackgroundMaterial",
              uniforms: cloneUniforms(ShaderLib.background.uniforms),
              vertexShader: ShaderLib.background.vertexShader,
              fragmentShader: ShaderLib.background.fragmentShader,
              side: FrontSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            })
          );
          planeMesh.geometry.deleteAttribute("normal");
          Object.defineProperty(planeMesh.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          });
          objects.update(planeMesh);
        }
        planeMesh.material.uniforms.t2D.value = background;
        planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
        planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
        if (background.matrixAutoUpdate === true) {
          background.updateMatrix();
        }
        planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          planeMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        planeMesh.layers.enableAll();
        renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
      }
    }
    function setClear(color, alpha2) {
      color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
      state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
    }
    function dispose() {
      if (boxMesh !== void 0) {
        boxMesh.geometry.dispose();
        boxMesh.material.dispose();
        boxMesh = void 0;
      }
      if (planeMesh !== void 0) {
        planeMesh.geometry.dispose();
        planeMesh.material.dispose();
        planeMesh = void 0;
      }
    }
    return {
      getClearColor: function() {
        return clearColor;
      },
      setClearColor: function(color, alpha2 = 1) {
        clearColor.set(color);
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      getClearAlpha: function() {
        return clearAlpha;
      },
      setClearAlpha: function(alpha2) {
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      render,
      addToRenderList,
      dispose
    };
  }
  function WebGLBindingStates(gl, attributes) {
    const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    let forceUpdate = false;
    function setup(object, material, program, geometry, index) {
      let updateBuffers = false;
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(object, geometry, program, index);
      if (updateBuffers)
        saveCache(object, geometry, program, index);
      if (index !== null) {
        attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
      }
      if (updateBuffers || forceUpdate) {
        forceUpdate = false;
        setupVertexAttributes(object, material, program, geometry);
        if (index !== null) {
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
        }
      }
    }
    function createVertexArrayObject() {
      return gl.createVertexArray();
    }
    function bindVertexArrayObject(vao) {
      return gl.bindVertexArray(vao);
    }
    function deleteVertexArrayObject(vao) {
      return gl.deleteVertexArray(vao);
    }
    function getBindingState(geometry, program, material) {
      const wireframe = material.wireframe === true;
      let programMap = bindingStates[geometry.id];
      if (programMap === void 0) {
        programMap = {};
        bindingStates[geometry.id] = programMap;
      }
      let stateMap = programMap[program.id];
      if (stateMap === void 0) {
        stateMap = {};
        programMap[program.id] = stateMap;
      }
      let state = stateMap[wireframe];
      if (state === void 0) {
        state = createBindingState(createVertexArrayObject());
        stateMap[wireframe] = state;
      }
      return state;
    }
    function createBindingState(vao) {
      const newAttributes = [];
      const enabledAttributes = [];
      const attributeDivisors = [];
      for (let i = 0; i < maxVertexAttributes; i++) {
        newAttributes[i] = 0;
        enabledAttributes[i] = 0;
        attributeDivisors[i] = 0;
      }
      return {
        // for backward compatibility on non-VAO support browser
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes,
        enabledAttributes,
        attributeDivisors,
        object: vao,
        attributes: {},
        index: null
      };
    }
    function needsUpdate(object, geometry, program, index) {
      const cachedAttributes = currentState.attributes;
      const geometryAttributes = geometry.attributes;
      let attributesNum = 0;
      const programAttributes = program.getAttributes();
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          const cachedAttribute = cachedAttributes[name];
          let geometryAttribute = geometryAttributes[name];
          if (geometryAttribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix)
              geometryAttribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor)
              geometryAttribute = object.instanceColor;
          }
          if (cachedAttribute === void 0)
            return true;
          if (cachedAttribute.attribute !== geometryAttribute)
            return true;
          if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data)
            return true;
          attributesNum++;
        }
      }
      if (currentState.attributesNum !== attributesNum)
        return true;
      if (currentState.index !== index)
        return true;
      return false;
    }
    function saveCache(object, geometry, program, index) {
      const cache = {};
      const attributes2 = geometry.attributes;
      let attributesNum = 0;
      const programAttributes = program.getAttributes();
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          let attribute = attributes2[name];
          if (attribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix)
              attribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor)
              attribute = object.instanceColor;
          }
          const data = {};
          data.attribute = attribute;
          if (attribute && attribute.data) {
            data.data = attribute.data;
          }
          cache[name] = data;
          attributesNum++;
        }
      }
      currentState.attributes = cache;
      currentState.attributesNum = attributesNum;
      currentState.index = index;
    }
    function initAttributes() {
      const newAttributes = currentState.newAttributes;
      for (let i = 0, il = newAttributes.length; i < il; i++) {
        newAttributes[i] = 0;
      }
    }
    function enableAttribute(attribute) {
      enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      const attributeDivisors = currentState.attributeDivisors;
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== meshPerAttribute) {
        gl.vertexAttribDivisor(attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    }
    function disableUnusedAttributes() {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      for (let i = 0, il = enabledAttributes.length; i < il; i++) {
        if (enabledAttributes[i] !== newAttributes[i]) {
          gl.disableVertexAttribArray(i);
          enabledAttributes[i] = 0;
        }
      }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
      if (integer === true) {
        gl.vertexAttribIPointer(index, size, type, stride, offset);
      } else {
        gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
      }
    }
    function setupVertexAttributes(object, material, program, geometry) {
      initAttributes();
      const geometryAttributes = geometry.attributes;
      const programAttributes = program.getAttributes();
      const materialDefaultAttributeValues = material.defaultAttributeValues;
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          let geometryAttribute = geometryAttributes[name];
          if (geometryAttribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix)
              geometryAttribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor)
              geometryAttribute = object.instanceColor;
          }
          if (geometryAttribute !== void 0) {
            const normalized = geometryAttribute.normalized;
            const size = geometryAttribute.itemSize;
            const attribute = attributes.get(geometryAttribute);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            const bytesPerElement = attribute.bytesPerElement;
            const integer = type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType;
            if (geometryAttribute.isInterleavedBufferAttribute) {
              const data = geometryAttribute.data;
              const stride = data.stride;
              const offset = geometryAttribute.offset;
              if (data.isInstancedInterleavedBuffer) {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                }
              } else {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttribute(programAttribute.location + i);
                }
              }
              gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
              for (let i = 0; i < programAttribute.locationSize; i++) {
                vertexAttribPointer(
                  programAttribute.location + i,
                  size / programAttribute.locationSize,
                  type,
                  normalized,
                  stride * bytesPerElement,
                  (offset + size / programAttribute.locationSize * i) * bytesPerElement,
                  integer
                );
              }
            } else {
              if (geometryAttribute.isInstancedBufferAttribute) {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttribute(programAttribute.location + i);
                }
              }
              gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
              for (let i = 0; i < programAttribute.locationSize; i++) {
                vertexAttribPointer(
                  programAttribute.location + i,
                  size / programAttribute.locationSize,
                  type,
                  normalized,
                  size * bytesPerElement,
                  size / programAttribute.locationSize * i * bytesPerElement,
                  integer
                );
              }
            }
          } else if (materialDefaultAttributeValues !== void 0) {
            const value = materialDefaultAttributeValues[name];
            if (value !== void 0) {
              switch (value.length) {
                case 2:
                  gl.vertexAttrib2fv(programAttribute.location, value);
                  break;
                case 3:
                  gl.vertexAttrib3fv(programAttribute.location, value);
                  break;
                case 4:
                  gl.vertexAttrib4fv(programAttribute.location, value);
                  break;
                default:
                  gl.vertexAttrib1fv(programAttribute.location, value);
              }
            }
          }
        }
      }
      disableUnusedAttributes();
    }
    function dispose() {
      reset();
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        for (const programId in programMap) {
          const stateMap = programMap[programId];
          for (const wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[programId];
        }
        delete bindingStates[geometryId];
      }
    }
    function releaseStatesOfGeometry(geometry) {
      if (bindingStates[geometry.id] === void 0)
        return;
      const programMap = bindingStates[geometry.id];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        if (programMap[program.id] === void 0)
          continue;
        const stateMap = programMap[program.id];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[program.id];
      }
    }
    function reset() {
      resetDefaultState();
      forceUpdate = true;
      if (currentState === defaultState)
        return;
      currentState = defaultState;
      bindVertexArrayObject(currentState.object);
    }
    function resetDefaultState() {
      defaultState.geometry = null;
      defaultState.program = null;
      defaultState.wireframe = false;
    }
    return {
      setup,
      reset,
      resetDefaultState,
      dispose,
      releaseStatesOfGeometry,
      releaseStatesOfProgram,
      initAttributes,
      enableAttribute,
      disableUnusedAttributes
    };
  }
  function WebGLBufferRenderer(gl, extensions, info) {
    let mode;
    function setMode(value) {
      mode = value;
    }
    function render(start, count) {
      gl.drawArrays(mode, start, count);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      gl.drawArraysInstanced(mode, start, count, primcount);
      info.update(count, mode, primcount);
    }
    function renderMultiDraw(starts, counts, drawCount) {
      if (drawCount === 0)
        return;
      const extension = extensions.get("WEBGL_multi_draw");
      extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i];
      }
      info.update(elementCount, mode, 1);
    }
    function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
      if (drawCount === 0)
        return;
      const extension = extensions.get("WEBGL_multi_draw");
      if (extension === null) {
        for (let i = 0; i < starts.length; i++) {
          renderInstances(starts[i], counts[i], primcount[i]);
        }
      } else {
        extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
        let elementCount = 0;
        for (let i = 0; i < drawCount; i++) {
          elementCount += counts[i] * primcount[i];
        }
        info.update(elementCount, mode, 1);
      }
    }
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
    this.renderMultiDraw = renderMultiDraw;
    this.renderMultiDrawInstances = renderMultiDrawInstances;
  }
  function WebGLCapabilities(gl, extensions, parameters, utils) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
      if (maxAnisotropy !== void 0)
        return maxAnisotropy;
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        maxAnisotropy = 0;
      }
      return maxAnisotropy;
    }
    function textureFormatReadable(textureFormat) {
      if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
        return false;
      }
      return true;
    }
    function textureTypeReadable(textureType) {
      const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float"));
      if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
      textureType !== FloatType && !halfFloatSupportedByExt) {
        return false;
      }
      return true;
    }
    function getMaxPrecision(precision2) {
      if (precision2 === "highp") {
        if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
          return "highp";
        }
        precision2 = "mediump";
      }
      if (precision2 === "mediump") {
        if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
          return "mediump";
        }
      }
      return "lowp";
    }
    let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
      console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
      precision = maxPrecision;
    }
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const reverseDepthBuffer = parameters.reverseDepthBuffer === true && extensions.has("EXT_clip_control");
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
    const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    const vertexTextures = maxVertexTextures > 0;
    const maxSamples = gl.getParameter(gl.MAX_SAMPLES);
    return {
      isWebGL2: true,
      // keeping this for backwards compatibility
      getMaxAnisotropy,
      getMaxPrecision,
      textureFormatReadable,
      textureTypeReadable,
      precision,
      logarithmicDepthBuffer,
      reverseDepthBuffer,
      maxTextures,
      maxVertexTextures,
      maxTextureSize,
      maxCubemapSize,
      maxAttributes,
      maxVertexUniforms,
      maxVaryings,
      maxFragmentUniforms,
      vertexTextures,
      maxSamples
    };
  }
  function WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping) {
      const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
      // run another frame in order to reset the state:
      numGlobalPlanes !== 0 || localClippingEnabled;
      localClippingEnabled = enableLocalClipping;
      numGlobalPlanes = planes.length;
      return enabled;
    };
    this.beginShadows = function() {
      renderingShadows = true;
      projectPlanes(null);
    };
    this.endShadows = function() {
      renderingShadows = false;
    };
    this.setGlobalState = function(planes, camera) {
      globalState = projectPlanes(planes, camera, 0);
    };
    this.setState = function(material, camera, useCache) {
      const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
      const materialProperties = properties.get(material);
      if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
          projectPlanes(null);
        } else {
          resetGlobalState();
        }
      } else {
        const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
        let dstArray = materialProperties.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera, lGlobal, useCache);
        for (let i = 0; i !== lGlobal; ++i) {
          dstArray[i] = globalState[i];
        }
        materialProperties.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;
      }
    };
    function resetGlobalState() {
      if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
      }
      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
      const nPlanes = planes !== null ? planes.length : 0;
      let dstArray = null;
      if (nPlanes !== 0) {
        dstArray = uniform.value;
        if (skipTransform !== true || dstArray === null) {
          const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
          viewNormalMatrix.getNormalMatrix(viewMatrix);
          if (dstArray === null || dstArray.length < flatSize) {
            dstArray = new Float32Array(flatSize);
          }
          for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
            plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
            plane.normal.toArray(dstArray, i4);
            dstArray[i4 + 3] = plane.constant;
          }
        }
        uniform.value = dstArray;
        uniform.needsUpdate = true;
      }
      scope.numPlanes = nPlanes;
      scope.numIntersection = 0;
      return dstArray;
    }
  }
  function WebGLCubeMaps(renderer) {
    let cubemaps = /* @__PURE__ */ new WeakMap();
    function mapTextureMapping(texture, mapping) {
      if (mapping === EquirectangularReflectionMapping) {
        texture.mapping = CubeReflectionMapping;
      } else if (mapping === EquirectangularRefractionMapping) {
        texture.mapping = CubeRefractionMapping;
      }
      return texture;
    }
    function get(texture) {
      if (texture && texture.isTexture) {
        const mapping = texture.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (cubemaps.has(texture)) {
            const cubemap = cubemaps.get(texture).texture;
            return mapTextureMapping(cubemap, texture.mapping);
          } else {
            const image = texture.image;
            if (image && image.height > 0) {
              const renderTarget = new WebGLCubeRenderTarget(image.height);
              renderTarget.fromEquirectangularTexture(renderer, texture);
              cubemaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return mapTextureMapping(renderTarget.texture, texture.mapping);
            } else {
              return null;
            }
          }
        }
      }
      return texture;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemap = cubemaps.get(texture);
      if (cubemap !== void 0) {
        cubemaps.delete(texture);
        cubemap.dispose();
      }
    }
    function dispose() {
      cubemaps = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  var LOD_MIN = 4;
  var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
  var MAX_SAMPLES = 20;
  var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
  var _clearColor = /* @__PURE__ */ new Color();
  var _oldTarget = null;
  var _oldActiveCubeFace = 0;
  var _oldActiveMipmapLevel = 0;
  var _oldXrEnabled = false;
  var PHI = (1 + Math.sqrt(5)) / 2;
  var INV_PHI = 1 / PHI;
  var _axisDirections = [
    /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0),
    /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
    /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
    /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
    /* @__PURE__ */ new Vector3(-1, 1, -1),
    /* @__PURE__ */ new Vector3(1, 1, -1),
    /* @__PURE__ */ new Vector3(-1, 1, 1),
    /* @__PURE__ */ new Vector3(1, 1, 1)
  ];
  var PMREMGenerator = class {
    constructor(renderer) {
      this._renderer = renderer;
      this._pingPongRenderTarget = null;
      this._lodMax = 0;
      this._cubeSize = 0;
      this._lodPlanes = [];
      this._sizeLods = [];
      this._sigmas = [];
      this._blurMaterial = null;
      this._cubemapMaterial = null;
      this._equirectMaterial = null;
      this._compileMaterial(this._blurMaterial);
    }
    /**
     * Generates a PMREM from a supplied Scene, which can be faster than using an
     * image if networking bandwidth is low. Optional sigma specifies a blur radius
     * in radians to be applied to the scene before PMREM generation. Optional near
     * and far planes ensure the scene is rendered in its entirety (the cubeCamera
     * is placed at the origin).
     *
     * @param {Scene} scene
     * @param {number} sigma
     * @param {number} near
     * @param {number} far
     * @return {WebGLRenderTarget}
     */
    fromScene(scene, sigma = 0, near = 0.1, far = 100) {
      _oldTarget = this._renderer.getRenderTarget();
      _oldActiveCubeFace = this._renderer.getActiveCubeFace();
      _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
      _oldXrEnabled = this._renderer.xr.enabled;
      this._renderer.xr.enabled = false;
      this._setSize(256);
      const cubeUVRenderTarget = this._allocateTargets();
      cubeUVRenderTarget.depthBuffer = true;
      this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
      if (sigma > 0) {
        this._blur(cubeUVRenderTarget, 0, 0, sigma);
      }
      this._applyPMREM(cubeUVRenderTarget);
      this._cleanup(cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    /**
     * Generates a PMREM from an equirectangular texture, which can be either LDR
     * or HDR. The ideal input image size is 1k (1024 x 512),
     * as this matches best with the 256 x 256 cubemap output.
     * The smallest supported equirectangular image size is 64 x 32.
     *
     * @param {Texture} equirectangular
     * @param {WebGLRenderTarget} [renderTarget=null] - Optional render target.
     * @return {WebGLRenderTarget}
     */
    fromEquirectangular(equirectangular, renderTarget = null) {
      return this._fromTexture(equirectangular, renderTarget);
    }
    /**
     * Generates a PMREM from an cubemap texture, which can be either LDR
     * or HDR. The ideal input cube size is 256 x 256,
     * as this matches best with the 256 x 256 cubemap output.
     * The smallest supported cube size is 16 x 16.
     *
     * @param {Texture} cubemap
     * @param {null} [renderTarget=null] - Optional render target.
     * @return {WebGLRenderTarget}
     */
    fromCubemap(cubemap, renderTarget = null) {
      return this._fromTexture(cubemap, renderTarget);
    }
    /**
     * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */
    compileCubemapShader() {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
        this._compileMaterial(this._cubemapMaterial);
      }
    }
    /**
     * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */
    compileEquirectangularShader() {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
        this._compileMaterial(this._equirectMaterial);
      }
    }
    /**
     * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
     * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
     * one of them will cause any others to also become unusable.
     */
    dispose() {
      this._dispose();
      if (this._cubemapMaterial !== null)
        this._cubemapMaterial.dispose();
      if (this._equirectMaterial !== null)
        this._equirectMaterial.dispose();
    }
    // private interface
    _setSize(cubeSize) {
      this._lodMax = Math.floor(Math.log2(cubeSize));
      this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
      if (this._blurMaterial !== null)
        this._blurMaterial.dispose();
      if (this._pingPongRenderTarget !== null)
        this._pingPongRenderTarget.dispose();
      for (let i = 0; i < this._lodPlanes.length; i++) {
        this._lodPlanes[i].dispose();
      }
    }
    _cleanup(outputTarget) {
      this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
      this._renderer.xr.enabled = _oldXrEnabled;
      outputTarget.scissorTest = false;
      _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    }
    _fromTexture(texture, renderTarget) {
      if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
        this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
      } else {
        this._setSize(texture.image.width / 4);
      }
      _oldTarget = this._renderer.getRenderTarget();
      _oldActiveCubeFace = this._renderer.getActiveCubeFace();
      _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
      _oldXrEnabled = this._renderer.xr.enabled;
      this._renderer.xr.enabled = false;
      const cubeUVRenderTarget = renderTarget || this._allocateTargets();
      this._textureToCubeUV(texture, cubeUVRenderTarget);
      this._applyPMREM(cubeUVRenderTarget);
      this._cleanup(cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    _allocateTargets() {
      const width = 3 * Math.max(this._cubeSize, 16 * 7);
      const height = 4 * this._cubeSize;
      const params = {
        magFilter: LinearFilter,
        minFilter: LinearFilter,
        generateMipmaps: false,
        type: HalfFloatType,
        format: RGBAFormat,
        colorSpace: LinearSRGBColorSpace,
        depthBuffer: false
      };
      const cubeUVRenderTarget = _createRenderTarget(width, height, params);
      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
        if (this._pingPongRenderTarget !== null) {
          this._dispose();
        }
        this._pingPongRenderTarget = _createRenderTarget(width, height, params);
        const { _lodMax } = this;
        ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
        this._blurMaterial = _getBlurShader(_lodMax, width, height);
      }
      return cubeUVRenderTarget;
    }
    _compileMaterial(material) {
      const tmpMesh = new Mesh(this._lodPlanes[0], material);
      this._renderer.compile(tmpMesh, _flatCamera);
    }
    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
      const fov2 = 90;
      const aspect2 = 1;
      const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
      const upSign = [1, -1, 1, 1, 1, 1];
      const forwardSign = [1, 1, 1, -1, -1, -1];
      const renderer = this._renderer;
      const originalAutoClear = renderer.autoClear;
      const toneMapping = renderer.toneMapping;
      renderer.getClearColor(_clearColor);
      renderer.toneMapping = NoToneMapping;
      renderer.autoClear = false;
      const backgroundMaterial = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: false,
        depthTest: false
      });
      const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
      let useSolidColor = false;
      const background = scene.background;
      if (background) {
        if (background.isColor) {
          backgroundMaterial.color.copy(background);
          scene.background = null;
          useSolidColor = true;
        }
      } else {
        backgroundMaterial.color.copy(_clearColor);
        useSolidColor = true;
      }
      for (let i = 0; i < 6; i++) {
        const col = i % 3;
        if (col === 0) {
          cubeCamera.up.set(0, upSign[i], 0);
          cubeCamera.lookAt(forwardSign[i], 0, 0);
        } else if (col === 1) {
          cubeCamera.up.set(0, 0, upSign[i]);
          cubeCamera.lookAt(0, forwardSign[i], 0);
        } else {
          cubeCamera.up.set(0, upSign[i], 0);
          cubeCamera.lookAt(0, 0, forwardSign[i]);
        }
        const size = this._cubeSize;
        _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
        renderer.setRenderTarget(cubeUVRenderTarget);
        if (useSolidColor) {
          renderer.render(backgroundBox, cubeCamera);
        }
        renderer.render(scene, cubeCamera);
      }
      backgroundBox.geometry.dispose();
      backgroundBox.material.dispose();
      renderer.toneMapping = toneMapping;
      renderer.autoClear = originalAutoClear;
      scene.background = background;
    }
    _textureToCubeUV(texture, cubeUVRenderTarget) {
      const renderer = this._renderer;
      const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
      if (isCubeTexture) {
        if (this._cubemapMaterial === null) {
          this._cubemapMaterial = _getCubemapMaterial();
        }
        this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
      } else {
        if (this._equirectMaterial === null) {
          this._equirectMaterial = _getEquirectMaterial();
        }
      }
      const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
      const mesh = new Mesh(this._lodPlanes[0], material);
      const uniforms = material.uniforms;
      uniforms["envMap"].value = texture;
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      renderer.render(mesh, _flatCamera);
    }
    _applyPMREM(cubeUVRenderTarget) {
      const renderer = this._renderer;
      const autoClear = renderer.autoClear;
      renderer.autoClear = false;
      const n = this._lodPlanes.length;
      for (let i = 1; i < n; i++) {
        const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
        const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
        this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
      }
      renderer.autoClear = autoClear;
    }
    /**
     * This is a two-pass Gaussian blur for a cubemap. Normally this is done
     * vertically and horizontally, but this breaks down on a cube. Here we apply
     * the blur latitudinally (around the poles), and then longitudinally (towards
     * the poles) to approximate the orthogonally-separable blur. It is least
     * accurate at the poles, but still does a decent job.
     *
     * @param {WebGLRenderTarget} cubeUVRenderTarget
     * @param {number} lodIn
     * @param {number} lodOut
     * @param {number} sigma
     * @param {Vector3} [poleAxis]
     */
    _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
      const pingPongRenderTarget = this._pingPongRenderTarget;
      this._halfBlur(
        cubeUVRenderTarget,
        pingPongRenderTarget,
        lodIn,
        lodOut,
        sigma,
        "latitudinal",
        poleAxis
      );
      this._halfBlur(
        pingPongRenderTarget,
        cubeUVRenderTarget,
        lodOut,
        lodOut,
        sigma,
        "longitudinal",
        poleAxis
      );
    }
    _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
      const renderer = this._renderer;
      const blurMaterial = this._blurMaterial;
      if (direction !== "latitudinal" && direction !== "longitudinal") {
        console.error(
          "blur direction must be either latitudinal or longitudinal!"
        );
      }
      const STANDARD_DEVIATIONS = 3;
      const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
      const blurUniforms = blurMaterial.uniforms;
      const pixels = this._sizeLods[lodIn] - 1;
      const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
      const sigmaPixels = sigmaRadians / radiansPerPixel;
      const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
      if (samples > MAX_SAMPLES) {
        console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
      }
      const weights = [];
      let sum = 0;
      for (let i = 0; i < MAX_SAMPLES; ++i) {
        const x2 = i / sigmaPixels;
        const weight = Math.exp(-x2 * x2 / 2);
        weights.push(weight);
        if (i === 0) {
          sum += weight;
        } else if (i < samples) {
          sum += 2 * weight;
        }
      }
      for (let i = 0; i < weights.length; i++) {
        weights[i] = weights[i] / sum;
      }
      blurUniforms["envMap"].value = targetIn.texture;
      blurUniforms["samples"].value = samples;
      blurUniforms["weights"].value = weights;
      blurUniforms["latitudinal"].value = direction === "latitudinal";
      if (poleAxis) {
        blurUniforms["poleAxis"].value = poleAxis;
      }
      const { _lodMax } = this;
      blurUniforms["dTheta"].value = radiansPerPixel;
      blurUniforms["mipInt"].value = _lodMax - lodIn;
      const outputSize = this._sizeLods[lodOut];
      const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
      const y = 4 * (this._cubeSize - outputSize);
      _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
      renderer.setRenderTarget(targetOut);
      renderer.render(blurMesh, _flatCamera);
    }
  };
  function _createPlanes(lodMax) {
    const lodPlanes = [];
    const sizeLods = [];
    const sigmas = [];
    let lod = lodMax;
    const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (let i = 0; i < totalLods; i++) {
      const sizeLod = Math.pow(2, lod);
      sizeLods.push(sizeLod);
      let sigma = 1 / sizeLod;
      if (i > lodMax - LOD_MIN) {
        sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
      } else if (i === 0) {
        sigma = 0;
      }
      sigmas.push(sigma);
      const texelSize = 1 / (sizeLod - 2);
      const min = -texelSize;
      const max = 1 + texelSize;
      const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
      const cubeFaces = 6;
      const vertices = 6;
      const positionSize = 3;
      const uvSize = 2;
      const faceIndexSize = 1;
      const position = new Float32Array(positionSize * vertices * cubeFaces);
      const uv = new Float32Array(uvSize * vertices * cubeFaces);
      const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
      for (let face = 0; face < cubeFaces; face++) {
        const x = face % 3 * 2 / 3 - 1;
        const y = face > 2 ? 0 : -1;
        const coordinates = [
          x,
          y,
          0,
          x + 2 / 3,
          y,
          0,
          x + 2 / 3,
          y + 1,
          0,
          x,
          y,
          0,
          x + 2 / 3,
          y + 1,
          0,
          x,
          y + 1,
          0
        ];
        position.set(coordinates, positionSize * vertices * face);
        uv.set(uv1, uvSize * vertices * face);
        const fill = [face, face, face, face, face, face];
        faceIndex.set(fill, faceIndexSize * vertices * face);
      }
      const planes = new BufferGeometry();
      planes.setAttribute("position", new BufferAttribute(position, positionSize));
      planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
      planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
      lodPlanes.push(planes);
      if (lod > LOD_MIN) {
        lod--;
      }
    }
    return { lodPlanes, sizeLods, sigmas };
  }
  function _createRenderTarget(width, height, params) {
    const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
  }
  function _setViewport(target, x, y, width, height) {
    target.viewport.set(x, y, width, height);
    target.scissor.set(x, y, width, height);
  }
  function _getBlurShader(lodMax, width, height) {
    const weights = new Float32Array(MAX_SAMPLES);
    const poleAxis = new Vector3(0, 1, 0);
    const shaderMaterial = new ShaderMaterial({
      name: "SphericalGaussianBlur",
      defines: {
        "n": MAX_SAMPLES,
        "CUBEUV_TEXEL_WIDTH": 1 / width,
        "CUBEUV_TEXEL_HEIGHT": 1 / height,
        "CUBEUV_MAX_MIP": `${lodMax}.0`
      },
      uniforms: {
        "envMap": { value: null },
        "samples": { value: 1 },
        "weights": { value: weights },
        "latitudinal": { value: false },
        "dTheta": { value: 0 },
        "mipInt": { value: 0 },
        "poleAxis": { value: poleAxis }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: (
        /* glsl */
        `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
      ),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    return shaderMaterial;
  }
  function _getEquirectMaterial() {
    return new ShaderMaterial({
      name: "EquirectangularToCubeUV",
      uniforms: {
        "envMap": { value: null }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: (
        /* glsl */
        `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
      ),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
  function _getCubemapMaterial() {
    return new ShaderMaterial({
      name: "CubemapToCubeUV",
      uniforms: {
        "envMap": { value: null },
        "flipEnvMap": { value: -1 }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: (
        /* glsl */
        `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
      ),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
  function _getCommonVertexShader() {
    return (
      /* glsl */
      `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
    );
  }
  function WebGLCubeUVMaps(renderer) {
    let cubeUVmaps = /* @__PURE__ */ new WeakMap();
    let pmremGenerator = null;
    function get(texture) {
      if (texture && texture.isTexture) {
        const mapping = texture.mapping;
        const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
        const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
        if (isEquirectMap || isCubeMap) {
          let renderTarget = cubeUVmaps.get(texture);
          const currentPMREMVersion = renderTarget !== void 0 ? renderTarget.texture.pmremVersion : 0;
          if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion) {
            if (pmremGenerator === null)
              pmremGenerator = new PMREMGenerator(renderer);
            renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
            renderTarget.texture.pmremVersion = texture.pmremVersion;
            cubeUVmaps.set(texture, renderTarget);
            return renderTarget.texture;
          } else {
            if (renderTarget !== void 0) {
              return renderTarget.texture;
            } else {
              const image = texture.image;
              if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                if (pmremGenerator === null)
                  pmremGenerator = new PMREMGenerator(renderer);
                renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                renderTarget.texture.pmremVersion = texture.pmremVersion;
                cubeUVmaps.set(texture, renderTarget);
                texture.addEventListener("dispose", onTextureDispose);
                return renderTarget.texture;
              } else {
                return null;
              }
            }
          }
        }
      }
      return texture;
    }
    function isCubeTextureComplete(image) {
      let count = 0;
      const length = 6;
      for (let i = 0; i < length; i++) {
        if (image[i] !== void 0)
          count++;
      }
      return count === length;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemapUV = cubeUVmaps.get(texture);
      if (cubemapUV !== void 0) {
        cubeUVmaps.delete(texture);
        cubemapUV.dispose();
      }
    }
    function dispose() {
      cubeUVmaps = /* @__PURE__ */ new WeakMap();
      if (pmremGenerator !== null) {
        pmremGenerator.dispose();
        pmremGenerator = null;
      }
    }
    return {
      get,
      dispose
    };
  }
  function WebGLExtensions(gl) {
    const extensions = {};
    function getExtension(name) {
      if (extensions[name] !== void 0) {
        return extensions[name];
      }
      let extension;
      switch (name) {
        case "WEBGL_depth_texture":
          extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          extension = gl.getExtension(name);
      }
      extensions[name] = extension;
      return extension;
    }
    return {
      has: function(name) {
        return getExtension(name) !== null;
      },
      init: function() {
        getExtension("EXT_color_buffer_float");
        getExtension("WEBGL_clip_cull_distance");
        getExtension("OES_texture_float_linear");
        getExtension("EXT_color_buffer_half_float");
        getExtension("WEBGL_multisampled_render_to_texture");
        getExtension("WEBGL_render_shared_exponent");
      },
      get: function(name) {
        const extension = getExtension(name);
        if (extension === null) {
          warnOnce("THREE.WebGLRenderer: " + name + " extension not supported.");
        }
        return extension;
      }
    };
  }
  function WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = {};
    const wireframeAttributes = /* @__PURE__ */ new WeakMap();
    function onGeometryDispose(event) {
      const geometry = event.target;
      if (geometry.index !== null) {
        attributes.remove(geometry.index);
      }
      for (const name in geometry.attributes) {
        attributes.remove(geometry.attributes[name]);
      }
      geometry.removeEventListener("dispose", onGeometryDispose);
      delete geometries[geometry.id];
      const attribute = wireframeAttributes.get(geometry);
      if (attribute) {
        attributes.remove(attribute);
        wireframeAttributes.delete(geometry);
      }
      bindingStates.releaseStatesOfGeometry(geometry);
      if (geometry.isInstancedBufferGeometry === true) {
        delete geometry._maxInstanceCount;
      }
      info.memory.geometries--;
    }
    function get(object, geometry) {
      if (geometries[geometry.id] === true)
        return geometry;
      geometry.addEventListener("dispose", onGeometryDispose);
      geometries[geometry.id] = true;
      info.memory.geometries++;
      return geometry;
    }
    function update(geometry) {
      const geometryAttributes = geometry.attributes;
      for (const name in geometryAttributes) {
        attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
      }
    }
    function updateWireframeAttribute(geometry) {
      const indices = [];
      const geometryIndex = geometry.index;
      const geometryPosition = geometry.attributes.position;
      let version = 0;
      if (geometryIndex !== null) {
        const array = geometryIndex.array;
        version = geometryIndex.version;
        for (let i = 0, l = array.length; i < l; i += 3) {
          const a = array[i + 0];
          const b = array[i + 1];
          const c = array[i + 2];
          indices.push(a, b, b, c, c, a);
        }
      } else if (geometryPosition !== void 0) {
        const array = geometryPosition.array;
        version = geometryPosition.version;
        for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
          const a = i + 0;
          const b = i + 1;
          const c = i + 2;
          indices.push(a, b, b, c, c, a);
        }
      } else {
        return;
      }
      const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
      attribute.version = version;
      const previousAttribute = wireframeAttributes.get(geometry);
      if (previousAttribute)
        attributes.remove(previousAttribute);
      wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
      const currentAttribute = wireframeAttributes.get(geometry);
      if (currentAttribute) {
        const geometryIndex = geometry.index;
        if (geometryIndex !== null) {
          if (currentAttribute.version < geometryIndex.version) {
            updateWireframeAttribute(geometry);
          }
        }
      } else {
        updateWireframeAttribute(geometry);
      }
      return wireframeAttributes.get(geometry);
    }
    return {
      get,
      update,
      getWireframeAttribute
    };
  }
  function WebGLIndexedBufferRenderer(gl, extensions, info) {
    let mode;
    function setMode(value) {
      mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
      type = value.type;
      bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
      gl.drawElements(mode, count, type, start * bytesPerElement);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      gl.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount);
      info.update(count, mode, primcount);
    }
    function renderMultiDraw(starts, counts, drawCount) {
      if (drawCount === 0)
        return;
      const extension = extensions.get("WEBGL_multi_draw");
      extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i];
      }
      info.update(elementCount, mode, 1);
    }
    function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
      if (drawCount === 0)
        return;
      const extension = extensions.get("WEBGL_multi_draw");
      if (extension === null) {
        for (let i = 0; i < starts.length; i++) {
          renderInstances(starts[i] / bytesPerElement, counts[i], primcount[i]);
        }
      } else {
        extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);
        let elementCount = 0;
        for (let i = 0; i < drawCount; i++) {
          elementCount += counts[i] * primcount[i];
        }
        info.update(elementCount, mode, 1);
      }
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
    this.renderMultiDraw = renderMultiDraw;
    this.renderMultiDrawInstances = renderMultiDrawInstances;
  }
  function WebGLInfo(gl) {
    const memory = {
      geometries: 0,
      textures: 0
    };
    const render = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function update(count, mode, instanceCount) {
      render.calls++;
      switch (mode) {
        case gl.TRIANGLES:
          render.triangles += instanceCount * (count / 3);
          break;
        case gl.LINES:
          render.lines += instanceCount * (count / 2);
          break;
        case gl.LINE_STRIP:
          render.lines += instanceCount * (count - 1);
          break;
        case gl.LINE_LOOP:
          render.lines += instanceCount * count;
          break;
        case gl.POINTS:
          render.points += instanceCount * count;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
          break;
      }
    }
    function reset() {
      render.calls = 0;
      render.triangles = 0;
      render.points = 0;
      render.lines = 0;
    }
    return {
      memory,
      render,
      programs: null,
      autoReset: true,
      reset,
      update
    };
  }
  function WebGLMorphtargets(gl, capabilities, textures) {
    const morphTextures = /* @__PURE__ */ new WeakMap();
    const morph = new Vector4();
    function update(object, geometry, program) {
      const objectInfluences = object.morphTargetInfluences;
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== morphTargetsCount) {
        let disposeTexture = function() {
          texture.dispose();
          morphTextures.delete(geometry);
          geometry.removeEventListener("dispose", disposeTexture);
        };
        if (entry !== void 0)
          entry.texture.dispose();
        const hasMorphPosition = geometry.morphAttributes.position !== void 0;
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const hasMorphColors = geometry.morphAttributes.color !== void 0;
        const morphTargets = geometry.morphAttributes.position || [];
        const morphNormals = geometry.morphAttributes.normal || [];
        const morphColors = geometry.morphAttributes.color || [];
        let vertexDataCount = 0;
        if (hasMorphPosition === true)
          vertexDataCount = 1;
        if (hasMorphNormals === true)
          vertexDataCount = 2;
        if (hasMorphColors === true)
          vertexDataCount = 3;
        let width = geometry.attributes.position.count * vertexDataCount;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
        const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
        texture.type = FloatType;
        texture.needsUpdate = true;
        const vertexDataStride = vertexDataCount * 4;
        for (let i = 0; i < morphTargetsCount; i++) {
          const morphTarget = morphTargets[i];
          const morphNormal = morphNormals[i];
          const morphColor = morphColors[i];
          const offset = width * height * 4 * i;
          for (let j = 0; j < morphTarget.count; j++) {
            const stride = j * vertexDataStride;
            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j);
              buffer[offset + stride + 0] = morph.x;
              buffer[offset + stride + 1] = morph.y;
              buffer[offset + stride + 2] = morph.z;
              buffer[offset + stride + 3] = 0;
            }
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j);
              buffer[offset + stride + 4] = morph.x;
              buffer[offset + stride + 5] = morph.y;
              buffer[offset + stride + 6] = morph.z;
              buffer[offset + stride + 7] = 0;
            }
            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j);
              buffer[offset + stride + 8] = morph.x;
              buffer[offset + stride + 9] = morph.y;
              buffer[offset + stride + 10] = morph.z;
              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
            }
          }
        }
        entry = {
          count: morphTargetsCount,
          texture,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry, entry);
        geometry.addEventListener("dispose", disposeTexture);
      }
      if (object.isInstancedMesh === true && object.morphTexture !== null) {
        program.getUniforms().setValue(gl, "morphTexture", object.morphTexture, textures);
      } else {
        let morphInfluencesSum = 0;
        for (let i = 0; i < objectInfluences.length; i++) {
          morphInfluencesSum += objectInfluences[i];
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
      }
      program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
    }
    return {
      update
    };
  }
  function WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = /* @__PURE__ */ new WeakMap();
    function update(object) {
      const frame = info.render.frame;
      const geometry = object.geometry;
      const buffergeometry = geometries.get(object, geometry);
      if (updateMap.get(buffergeometry) !== frame) {
        geometries.update(buffergeometry);
        updateMap.set(buffergeometry, frame);
      }
      if (object.isInstancedMesh) {
        if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
          object.addEventListener("dispose", onInstancedMeshDispose);
        }
        if (updateMap.get(object) !== frame) {
          attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
          if (object.instanceColor !== null) {
            attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
          }
          updateMap.set(object, frame);
        }
      }
      if (object.isSkinnedMesh) {
        const skeleton = object.skeleton;
        if (updateMap.get(skeleton) !== frame) {
          skeleton.update();
          updateMap.set(skeleton, frame);
        }
      }
      return buffergeometry;
    }
    function dispose() {
      updateMap = /* @__PURE__ */ new WeakMap();
    }
    function onInstancedMeshDispose(event) {
      const instancedMesh = event.target;
      instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
      attributes.remove(instancedMesh.instanceMatrix);
      if (instancedMesh.instanceColor !== null)
        attributes.remove(instancedMesh.instanceColor);
    }
    return {
      update,
      dispose
    };
  }
  var emptyTexture = /* @__PURE__ */ new Texture();
  var emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);
  var emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
  var empty3dTexture = /* @__PURE__ */ new Data3DTexture();
  var emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
  var arrayCacheF32 = [];
  var arrayCacheI32 = [];
  var mat4array = new Float32Array(16);
  var mat3array = new Float32Array(9);
  var mat2array = new Float32Array(4);
  function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0)
      return array;
    const n = nBlocks * blockSize;
    let r = arrayCacheF32[n];
    if (r === void 0) {
      r = new Float32Array(n);
      arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
      firstElem.toArray(r, 0);
      for (let i = 1, offset = 0; i !== nBlocks; ++i) {
        offset += blockSize;
        array[i].toArray(r, offset);
      }
    }
    return r;
  }
  function arraysEqual(a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0, l = a.length; i < l; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  function copyArray(a, b) {
    for (let i = 0, l = b.length; i < l; i++) {
      a[i] = b[i];
    }
  }
  function allocTexUnits(textures, n) {
    let r = arrayCacheI32[n];
    if (r === void 0) {
      r = new Int32Array(n);
      arrayCacheI32[n] = r;
    }
    for (let i = 0; i !== n; ++i) {
      r[i] = textures.allocateTextureUnit();
    }
    return r;
  }
  function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
  }
  function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2f(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform2fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3f(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else if (v.r !== void 0) {
      if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
        gl.uniform3f(this.addr, v.r, v.g, v.b);
        cache[0] = v.r;
        cache[1] = v.g;
        cache[2] = v.b;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform3fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform4fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix2fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat2array.set(elements);
      gl.uniformMatrix2fv(this.addr, false, mat2array);
      copyArray(cache, elements);
    }
  }
  function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix3fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat3array.set(elements);
      gl.uniformMatrix3fv(this.addr, false, mat3array);
      copyArray(cache, elements);
    }
  }
  function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix4fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat4array.set(elements);
      gl.uniformMatrix4fv(this.addr, false, mat4array);
      copyArray(cache, elements);
    }
  }
  function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
  }
  function setValueV2i(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2i(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform2iv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV3i(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3i(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform3iv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV4i(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform4iv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
  }
  function setValueV2ui(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2ui(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform2uiv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV3ui(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3ui(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform3uiv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV4ui(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform4uiv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    let emptyTexture2D;
    if (this.type === gl.SAMPLER_2D_SHADOW) {
      emptyShadowTexture.compareFunction = LessEqualCompare;
      emptyTexture2D = emptyShadowTexture;
    } else {
      emptyTexture2D = emptyTexture;
    }
    textures.setTexture2D(v || emptyTexture2D, unit);
  }
  function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture3D(v || empty3dTexture, unit);
  }
  function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTextureCube(v || emptyCubeTexture, unit);
  }
  function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyArrayTexture, unit);
  }
  function getSingularSetter(type) {
    switch (type) {
      case 5126:
        return setValueV1f;
      case 35664:
        return setValueV2f;
      case 35665:
        return setValueV3f;
      case 35666:
        return setValueV4f;
      case 35674:
        return setValueM2;
      case 35675:
        return setValueM3;
      case 35676:
        return setValueM4;
      case 5124:
      case 35670:
        return setValueV1i;
      case 35667:
      case 35671:
        return setValueV2i;
      case 35668:
      case 35672:
        return setValueV3i;
      case 35669:
      case 35673:
        return setValueV4i;
      case 5125:
        return setValueV1ui;
      case 36294:
        return setValueV2ui;
      case 36295:
        return setValueV3ui;
      case 36296:
        return setValueV4ui;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3D1;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArray1;
    }
  }
  function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
  }
  function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
  }
  function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
  }
  function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
  }
  function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
  }
  function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
  }
  function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
  }
  function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
  }
  function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
  }
  function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
  }
  function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
  }
  function setValueV1uiArray(gl, v) {
    gl.uniform1uiv(this.addr, v);
  }
  function setValueV2uiArray(gl, v) {
    gl.uniform2uiv(this.addr, v);
  }
  function setValueV3uiArray(gl, v) {
    gl.uniform3uiv(this.addr, v);
  }
  function setValueV4uiArray(gl, v) {
    gl.uniform4uiv(this.addr, v);
  }
  function setValueT1Array(gl, v, textures) {
    const cache = this.cache;
    const n = v.length;
    const units = allocTexUnits(textures, n);
    if (!arraysEqual(cache, units)) {
      gl.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i = 0; i !== n; ++i) {
      textures.setTexture2D(v[i] || emptyTexture, units[i]);
    }
  }
  function setValueT3DArray(gl, v, textures) {
    const cache = this.cache;
    const n = v.length;
    const units = allocTexUnits(textures, n);
    if (!arraysEqual(cache, units)) {
      gl.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i = 0; i !== n; ++i) {
      textures.setTexture3D(v[i] || empty3dTexture, units[i]);
    }
  }
  function setValueT6Array(gl, v, textures) {
    const cache = this.cache;
    const n = v.length;
    const units = allocTexUnits(textures, n);
    if (!arraysEqual(cache, units)) {
      gl.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i = 0; i !== n; ++i) {
      textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
  }
  function setValueT2DArrayArray(gl, v, textures) {
    const cache = this.cache;
    const n = v.length;
    const units = allocTexUnits(textures, n);
    if (!arraysEqual(cache, units)) {
      gl.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i = 0; i !== n; ++i) {
      textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
    }
  }
  function getPureArraySetter(type) {
    switch (type) {
      case 5126:
        return setValueV1fArray;
      case 35664:
        return setValueV2fArray;
      case 35665:
        return setValueV3fArray;
      case 35666:
        return setValueV4fArray;
      case 35674:
        return setValueM2Array;
      case 35675:
        return setValueM3Array;
      case 35676:
        return setValueM4Array;
      case 5124:
      case 35670:
        return setValueV1iArray;
      case 35667:
      case 35671:
        return setValueV2iArray;
      case 35668:
      case 35672:
        return setValueV3iArray;
      case 35669:
      case 35673:
        return setValueV4iArray;
      case 5125:
        return setValueV1uiArray;
      case 36294:
        return setValueV2uiArray;
      case 36295:
        return setValueV3uiArray;
      case 36296:
        return setValueV4uiArray;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1Array;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3DArray;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6Array;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArrayArray;
    }
  }
  var SingleUniform = class {
    constructor(id, activeInfo, addr) {
      this.id = id;
      this.addr = addr;
      this.cache = [];
      this.type = activeInfo.type;
      this.setValue = getSingularSetter(activeInfo.type);
    }
  };
  var PureArrayUniform = class {
    constructor(id, activeInfo, addr) {
      this.id = id;
      this.addr = addr;
      this.cache = [];
      this.type = activeInfo.type;
      this.size = activeInfo.size;
      this.setValue = getPureArraySetter(activeInfo.type);
    }
  };
  var StructuredUniform = class {
    constructor(id) {
      this.id = id;
      this.seq = [];
      this.map = {};
    }
    setValue(gl, value, textures) {
      const seq = this.seq;
      for (let i = 0, n = seq.length; i !== n; ++i) {
        const u = seq[i];
        u.setValue(gl, value[u.id], textures);
      }
    }
  };
  var RePathPart = /(\w+)(\])?(\[|\.)?/g;
  function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
  }
  function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while (true) {
      const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
      let id = match[1];
      const idIsIndex = match[2] === "]", subscript = match[3];
      if (idIsIndex)
        id = id | 0;
      if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
        break;
      } else {
        const map = container.map;
        let next = map[id];
        if (next === void 0) {
          next = new StructuredUniform(id);
          addUniform(container, next);
        }
        container = next;
      }
    }
  }
  var WebGLUniforms = class {
    constructor(gl, program) {
      this.seq = [];
      this.map = {};
      const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      for (let i = 0; i < n; ++i) {
        const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
        parseUniform(info, addr, this);
      }
    }
    setValue(gl, name, value, textures) {
      const u = this.map[name];
      if (u !== void 0)
        u.setValue(gl, value, textures);
    }
    setOptional(gl, object, name) {
      const v = object[name];
      if (v !== void 0)
        this.setValue(gl, name, v);
    }
    static upload(gl, seq, values, textures) {
      for (let i = 0, n = seq.length; i !== n; ++i) {
        const u = seq[i], v = values[u.id];
        if (v.needsUpdate !== false) {
          u.setValue(gl, v.value, textures);
        }
      }
    }
    static seqWithValue(seq, values) {
      const r = [];
      for (let i = 0, n = seq.length; i !== n; ++i) {
        const u = seq[i];
        if (u.id in values)
          r.push(u);
      }
      return r;
    }
  };
  function WebGLShader(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
  }
  var COMPLETION_STATUS_KHR = 37297;
  var programIdCount = 0;
  function handleSource(string, errorLine) {
    const lines = string.split("\n");
    const lines2 = [];
    const from = Math.max(errorLine - 6, 0);
    const to = Math.min(errorLine + 6, lines.length);
    for (let i = from; i < to; i++) {
      const line = i + 1;
      lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
    }
    return lines2.join("\n");
  }
  var _m0 = /* @__PURE__ */ new Matrix3();
  function getEncodingComponents(colorSpace) {
    ColorManagement._getMatrix(_m0, ColorManagement.workingColorSpace, colorSpace);
    const encodingMatrix = `mat3( ${_m0.elements.map((v) => v.toFixed(4))} )`;
    switch (ColorManagement.getTransfer(colorSpace)) {
      case LinearTransfer:
        return [encodingMatrix, "LinearTransferOETF"];
      case SRGBTransfer:
        return [encodingMatrix, "sRGBTransferOETF"];
      default:
        console.warn("THREE.WebGLProgram: Unsupported color space: ", colorSpace);
        return [encodingMatrix, "LinearTransferOETF"];
    }
  }
  function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    const errors = gl.getShaderInfoLog(shader).trim();
    if (status && errors === "")
      return "";
    const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
    if (errorMatches) {
      const errorLine = parseInt(errorMatches[1]);
      return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
    } else {
      return errors;
    }
  }
  function getTexelEncodingFunction(functionName, colorSpace) {
    const components = getEncodingComponents(colorSpace);
    return [
      `vec4 ${functionName}( vec4 value ) {`,
      `	return ${components[1]}( vec4( value.rgb * ${components[0]}, value.a ) );`,
      "}"
    ].join("\n");
  }
  function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch (toneMapping) {
      case LinearToneMapping:
        toneMappingName = "Linear";
        break;
      case ReinhardToneMapping:
        toneMappingName = "Reinhard";
        break;
      case CineonToneMapping:
        toneMappingName = "Cineon";
        break;
      case ACESFilmicToneMapping:
        toneMappingName = "ACESFilmic";
        break;
      case AgXToneMapping:
        toneMappingName = "AgX";
        break;
      case NeutralToneMapping:
        toneMappingName = "Neutral";
        break;
      case CustomToneMapping:
        toneMappingName = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
        toneMappingName = "Linear";
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
  }
  var _v0 = /* @__PURE__ */ new Vector3();
  function getLuminanceFunction() {
    ColorManagement.getLuminanceCoefficients(_v0);
    const r = _v0.x.toFixed(4);
    const g = _v0.y.toFixed(4);
    const b = _v0.z.toFixed(4);
    return [
      "float luminance( const in vec3 rgb ) {",
      `	const vec3 weights = vec3( ${r}, ${g}, ${b} );`,
      "	return dot( weights, rgb );",
      "}"
    ].join("\n");
  }
  function generateVertexExtensions(parameters) {
    const chunks = [
      parameters.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
      parameters.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
    ];
    return chunks.filter(filterEmptyLine).join("\n");
  }
  function generateDefines(defines) {
    const chunks = [];
    for (const name in defines) {
      const value = defines[name];
      if (value === false)
        continue;
      chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
  }
  function fetchAttributeLocations(gl, program) {
    const attributes = {};
    const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < n; i++) {
      const info = gl.getActiveAttrib(program, i);
      const name = info.name;
      let locationSize = 1;
      if (info.type === gl.FLOAT_MAT2)
        locationSize = 2;
      if (info.type === gl.FLOAT_MAT3)
        locationSize = 3;
      if (info.type === gl.FLOAT_MAT4)
        locationSize = 4;
      attributes[name] = {
        type: info.type,
        location: gl.getAttribLocation(program, name),
        locationSize
      };
    }
    return attributes;
  }
  function filterEmptyLine(string) {
    return string !== "";
  }
  function replaceLightNums(string, parameters) {
    const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
  }
  function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
  }
  var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
  }
  var shaderChunkMap = /* @__PURE__ */ new Map();
  function includeReplacer(match, include) {
    let string = ShaderChunk[include];
    if (string === void 0) {
      const newInclude = shaderChunkMap.get(include);
      if (newInclude !== void 0) {
        string = ShaderChunk[newInclude];
        console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
      } else {
        throw new Error("Can not resolve #include <" + include + ">");
      }
    }
    return resolveIncludes(string);
  }
  var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer);
  }
  function loopReplacer(match, start, end, snippet) {
    let string = "";
    for (let i = parseInt(start); i < parseInt(end); i++) {
      string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
    }
    return string;
  }
  function generatePrecision(parameters) {
    let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;
    if (parameters.precision === "highp") {
      precisionstring += "\n#define HIGH_PRECISION";
    } else if (parameters.precision === "mediump") {
      precisionstring += "\n#define MEDIUM_PRECISION";
    } else if (parameters.precision === "lowp") {
      precisionstring += "\n#define LOW_PRECISION";
    }
    return precisionstring;
  }
  function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === PCFShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    } else if (parameters.shadowMapType === VSMShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
    }
    return shadowMapTypeDefine;
  }
  function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE";
          break;
        case CubeUVReflectionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
          break;
      }
    }
    return envMapTypeDefine;
  }
  function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeRefractionMapping:
          envMapModeDefine = "ENVMAP_MODE_REFRACTION";
          break;
      }
    }
    return envMapModeDefine;
  }
  function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
    if (parameters.envMap) {
      switch (parameters.combine) {
        case MultiplyOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case MixOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
          break;
        case AddOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
          break;
      }
    }
    return envMapBlendingDefine;
  }
  function generateCubeUVSize(parameters) {
    const imageHeight = parameters.envMapCubeUVHeight;
    if (imageHeight === null)
      return null;
    const maxMip = Math.log2(imageHeight) - 2;
    const texelHeight = 1 / imageHeight;
    const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
    return { texelWidth, texelHeight, maxMip };
  }
  function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
    const gl = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const envMapCubeUVSize = generateCubeUVSize(parameters);
    const customVertexExtensions = generateVertexExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
    if (parameters.isRawShaderMaterial) {
      prefixVertex = [
        "#define SHADER_TYPE " + parameters.shaderType,
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixVertex.length > 0) {
        prefixVertex += "\n";
      }
      prefixFragment = [
        "#define SHADER_TYPE " + parameters.shaderType,
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixFragment.length > 0) {
        prefixFragment += "\n";
      }
    } else {
      prefixVertex = [
        generatePrecision(parameters),
        "#define SHADER_TYPE " + parameters.shaderType,
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        parameters.batching ? "#define USE_BATCHING" : "",
        parameters.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        parameters.instancing ? "#define USE_INSTANCING" : "",
        parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        parameters.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
        parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        //
        parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
        parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
        parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
        parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
        parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
        parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
        parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
        parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
        parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
        parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
        parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
        parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
        parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
        parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
        parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
        parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
        parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
        parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
        parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
        parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
        parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
        parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
        parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
        //
        parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUv1s ? "#define USE_UV1" : "",
        parameters.vertexUv2s ? "#define USE_UV2" : "",
        parameters.vertexUv3s ? "#define USE_UV3" : "",
        parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.skinning ? "#define USE_SKINNING" : "",
        parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
        parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
        parameters.morphColors ? "#define USE_MORPHCOLORS" : "",
        parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
        parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n"
      ].filter(filterEmptyLine).join("\n");
      prefixFragment = [
        generatePrecision(parameters),
        "#define SHADER_TYPE " + parameters.shaderType,
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.matcap ? "#define USE_MATCAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapTypeDefine : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.envMap ? "#define " + envMapBlendingDefine : "",
        envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
        envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
        envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
        parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.dispersion ? "#define USE_DISPERSION" : "",
        parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
        parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.alphaTest ? "#define USE_ALPHATEST" : "",
        parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
        parameters.sheen ? "#define USE_SHEEN" : "",
        parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
        parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUv1s ? "#define USE_UV1" : "",
        parameters.vertexUv2s ? "#define USE_UV2" : "",
        parameters.vertexUv3s ? "#define USE_UV3" : "",
        parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
        parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        parameters.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
        // this code is required here because it is used by the toneMapping() function defined below
        parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
        parameters.dithering ? "#define DITHERING" : "",
        parameters.opaque ? "#define OPAQUE" : "",
        ShaderChunk["colorspace_pars_fragment"],
        // this code is required here because it is used by the various encoding/decoding function defined below
        getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
        getLuminanceFunction(),
        parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
        "\n"
      ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isRawShaderMaterial !== true) {
      versionString = "#version 300 es\n";
      prefixVertex = [
        customVertexExtensions,
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
      ].join("\n") + "\n" + prefixVertex;
      prefixFragment = [
        "#define varying in",
        parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
        parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
      ].join("\n") + "\n" + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
    const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    if (parameters.index0AttributeName !== void 0) {
      gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      gl.bindAttribLocation(program, 0, "position");
    }
    gl.linkProgram(program);
    function onFirstUse(self2) {
      if (renderer.debug.checkShaderErrors) {
        const programLog = gl.getProgramInfoLog(program).trim();
        const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        let runnable = true;
        let haveDiagnostics = true;
        if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
          runnable = false;
          if (typeof renderer.debug.onShaderError === "function") {
            renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
          } else {
            const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
            const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nMaterial Name: " + self2.name + "\nMaterial Type: " + self2.type + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
            );
          }
        } else if (programLog !== "") {
          console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
        } else if (vertexLog === "" || fragmentLog === "") {
          haveDiagnostics = false;
        }
        if (haveDiagnostics) {
          self2.diagnostics = {
            runnable,
            programLog,
            vertexShader: {
              log: vertexLog,
              prefix: prefixVertex
            },
            fragmentShader: {
              log: fragmentLog,
              prefix: prefixFragment
            }
          };
        }
      }
      gl.deleteShader(glVertexShader);
      gl.deleteShader(glFragmentShader);
      cachedUniforms = new WebGLUniforms(gl, program);
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    let cachedUniforms;
    this.getUniforms = function() {
      if (cachedUniforms === void 0) {
        onFirstUse(this);
      }
      return cachedUniforms;
    };
    let cachedAttributes;
    this.getAttributes = function() {
      if (cachedAttributes === void 0) {
        onFirstUse(this);
      }
      return cachedAttributes;
    };
    let programReady = parameters.rendererExtensionParallelShaderCompile === false;
    this.isReady = function() {
      if (programReady === false) {
        programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR);
      }
      return programReady;
    };
    this.destroy = function() {
      bindingStates.releaseStatesOfProgram(this);
      gl.deleteProgram(program);
      this.program = void 0;
    };
    this.type = parameters.shaderType;
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
  }
  var _id = 0;
  var WebGLShaderCache = class {
    constructor() {
      this.shaderCache = /* @__PURE__ */ new Map();
      this.materialCache = /* @__PURE__ */ new Map();
    }
    update(material) {
      const vertexShader = material.vertexShader;
      const fragmentShader = material.fragmentShader;
      const vertexShaderStage = this._getShaderStage(vertexShader);
      const fragmentShaderStage = this._getShaderStage(fragmentShader);
      const materialShaders = this._getShaderCacheForMaterial(material);
      if (materialShaders.has(vertexShaderStage) === false) {
        materialShaders.add(vertexShaderStage);
        vertexShaderStage.usedTimes++;
      }
      if (materialShaders.has(fragmentShaderStage) === false) {
        materialShaders.add(fragmentShaderStage);
        fragmentShaderStage.usedTimes++;
      }
      return this;
    }
    remove(material) {
      const materialShaders = this.materialCache.get(material);
      for (const shaderStage of materialShaders) {
        shaderStage.usedTimes--;
        if (shaderStage.usedTimes === 0)
          this.shaderCache.delete(shaderStage.code);
      }
      this.materialCache.delete(material);
      return this;
    }
    getVertexShaderID(material) {
      return this._getShaderStage(material.vertexShader).id;
    }
    getFragmentShaderID(material) {
      return this._getShaderStage(material.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear();
      this.materialCache.clear();
    }
    _getShaderCacheForMaterial(material) {
      const cache = this.materialCache;
      let set = cache.get(material);
      if (set === void 0) {
        set = /* @__PURE__ */ new Set();
        cache.set(material, set);
      }
      return set;
    }
    _getShaderStage(code) {
      const cache = this.shaderCache;
      let stage = cache.get(code);
      if (stage === void 0) {
        stage = new WebGLShaderStage(code);
        cache.set(code, stage);
      }
      return stage;
    }
  };
  var WebGLShaderStage = class {
    constructor(code) {
      this.id = _id++;
      this.code = code;
      this.usedTimes = 0;
    }
  };
  function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
    const _programLayers = new Layers();
    const _customShaders = new WebGLShaderCache();
    const _activeChannels = /* @__PURE__ */ new Set();
    const programs = [];
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    function getChannel(value) {
      _activeChannels.add(value);
      if (value === 0)
        return "uv";
      return `uv${value}`;
    }
    function getParameters(material, lights, shadows, scene, object) {
      const fog = scene.fog;
      const geometry = object.geometry;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
      const shaderID = shaderIDs[material.type];
      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
          console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let morphTextureStride = 0;
      if (geometry.morphAttributes.position !== void 0)
        morphTextureStride = 1;
      if (geometry.morphAttributes.normal !== void 0)
        morphTextureStride = 2;
      if (geometry.morphAttributes.color !== void 0)
        morphTextureStride = 3;
      let vertexShader, fragmentShader;
      let customVertexShaderID, customFragmentShaderID;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        vertexShader = shader.vertexShader;
        fragmentShader = shader.fragmentShader;
      } else {
        vertexShader = material.vertexShader;
        fragmentShader = material.fragmentShader;
        _customShaders.update(material);
        customVertexShaderID = _customShaders.getVertexShaderID(material);
        customFragmentShaderID = _customShaders.getFragmentShaderID(material);
      }
      const currentRenderTarget = renderer.getRenderTarget();
      const reverseDepthBuffer = renderer.state.buffers.depth.getReversed();
      const IS_INSTANCEDMESH = object.isInstancedMesh === true;
      const IS_BATCHEDMESH = object.isBatchedMesh === true;
      const HAS_MAP = !!material.map;
      const HAS_MATCAP = !!material.matcap;
      const HAS_ENVMAP = !!envMap;
      const HAS_AOMAP = !!material.aoMap;
      const HAS_LIGHTMAP = !!material.lightMap;
      const HAS_BUMPMAP = !!material.bumpMap;
      const HAS_NORMALMAP = !!material.normalMap;
      const HAS_DISPLACEMENTMAP = !!material.displacementMap;
      const HAS_EMISSIVEMAP = !!material.emissiveMap;
      const HAS_METALNESSMAP = !!material.metalnessMap;
      const HAS_ROUGHNESSMAP = !!material.roughnessMap;
      const HAS_ANISOTROPY = material.anisotropy > 0;
      const HAS_CLEARCOAT = material.clearcoat > 0;
      const HAS_DISPERSION = material.dispersion > 0;
      const HAS_IRIDESCENCE = material.iridescence > 0;
      const HAS_SHEEN = material.sheen > 0;
      const HAS_TRANSMISSION = material.transmission > 0;
      const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
      const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
      const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
      const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
      const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
      const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
      const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
      const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
      const HAS_SPECULARMAP = !!material.specularMap;
      const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
      const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
      const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
      const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
      const HAS_GRADIENTMAP = !!material.gradientMap;
      const HAS_ALPHAMAP = !!material.alphaMap;
      const HAS_ALPHATEST = material.alphaTest > 0;
      const HAS_ALPHAHASH = !!material.alphaHash;
      const HAS_EXTENSIONS = !!material.extensions;
      let toneMapping = NoToneMapping;
      if (material.toneMapped) {
        if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
          toneMapping = renderer.toneMapping;
        }
      }
      const parameters = {
        shaderID,
        shaderType: material.type,
        shaderName: material.name,
        vertexShader,
        fragmentShader,
        defines: material.defines,
        customVertexShaderID,
        customFragmentShaderID,
        isRawShaderMaterial: material.isRawShaderMaterial === true,
        glslVersion: material.glslVersion,
        precision,
        batching: IS_BATCHEDMESH,
        batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
        instancing: IS_INSTANCEDMESH,
        instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
        instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
        supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
        outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
        alphaToCoverage: !!material.alphaToCoverage,
        map: HAS_MAP,
        matcap: HAS_MATCAP,
        envMap: HAS_ENVMAP,
        envMapMode: HAS_ENVMAP && envMap.mapping,
        envMapCubeUVHeight,
        aoMap: HAS_AOMAP,
        lightMap: HAS_LIGHTMAP,
        bumpMap: HAS_BUMPMAP,
        normalMap: HAS_NORMALMAP,
        displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
        emissiveMap: HAS_EMISSIVEMAP,
        normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
        normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
        metalnessMap: HAS_METALNESSMAP,
        roughnessMap: HAS_ROUGHNESSMAP,
        anisotropy: HAS_ANISOTROPY,
        anisotropyMap: HAS_ANISOTROPYMAP,
        clearcoat: HAS_CLEARCOAT,
        clearcoatMap: HAS_CLEARCOATMAP,
        clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
        clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
        dispersion: HAS_DISPERSION,
        iridescence: HAS_IRIDESCENCE,
        iridescenceMap: HAS_IRIDESCENCEMAP,
        iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
        sheen: HAS_SHEEN,
        sheenColorMap: HAS_SHEEN_COLORMAP,
        sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
        specularMap: HAS_SPECULARMAP,
        specularColorMap: HAS_SPECULAR_COLORMAP,
        specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
        transmission: HAS_TRANSMISSION,
        transmissionMap: HAS_TRANSMISSIONMAP,
        thicknessMap: HAS_THICKNESSMAP,
        gradientMap: HAS_GRADIENTMAP,
        opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,
        alphaMap: HAS_ALPHAMAP,
        alphaTest: HAS_ALPHATEST,
        alphaHash: HAS_ALPHAHASH,
        combine: material.combine,
        //
        mapUv: HAS_MAP && getChannel(material.map.channel),
        aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
        lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
        bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
        normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
        displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
        emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
        metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
        roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
        anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
        clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
        clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
        iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
        iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
        sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
        sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
        specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
        specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
        specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
        transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
        thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
        alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
        //
        vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
        vertexColors: material.vertexColors,
        vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
        pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
        fog: !!fog,
        useFog: material.fog === true,
        fogExp2: !!fog && fog.isFogExp2,
        flatShading: material.flatShading === true,
        sizeAttenuation: material.sizeAttenuation === true,
        logarithmicDepthBuffer,
        reverseDepthBuffer,
        skinning: object.isSkinnedMesh === true,
        morphTargets: geometry.morphAttributes.position !== void 0,
        morphNormals: geometry.morphAttributes.normal !== void 0,
        morphColors: geometry.morphAttributes.color !== void 0,
        morphTargetsCount,
        morphTextureStride,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numSpotLightMaps: lights.spotLightMap.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,
        numDirLightShadows: lights.directionalShadowMap.length,
        numPointLightShadows: lights.pointShadowMap.length,
        numSpotLightShadows: lights.spotShadowMap.length,
        numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
        numLightProbes: lights.numLightProbes,
        numClippingPlanes: clipping.numPlanes,
        numClipIntersection: clipping.numIntersection,
        dithering: material.dithering,
        shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
        shadowMapType: renderer.shadowMap.type,
        toneMapping,
        decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
        decodeVideoTextureEmissive: HAS_EMISSIVEMAP && material.emissiveMap.isVideoTexture === true && ColorManagement.getTransfer(material.emissiveMap.colorSpace) === SRGBTransfer,
        premultipliedAlpha: material.premultipliedAlpha,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        useDepthPacking: material.depthPacking >= 0,
        depthPacking: material.depthPacking || 0,
        index0AttributeName: material.index0AttributeName,
        extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has("WEBGL_clip_cull_distance"),
        extensionMultiDraw: (HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH) && extensions.has("WEBGL_multi_draw"),
        rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
        customProgramCacheKey: material.customProgramCacheKey()
      };
      parameters.vertexUv1s = _activeChannels.has(1);
      parameters.vertexUv2s = _activeChannels.has(2);
      parameters.vertexUv3s = _activeChannels.has(3);
      _activeChannels.clear();
      return parameters;
    }
    function getProgramCacheKey(parameters) {
      const array = [];
      if (parameters.shaderID) {
        array.push(parameters.shaderID);
      } else {
        array.push(parameters.customVertexShaderID);
        array.push(parameters.customFragmentShaderID);
      }
      if (parameters.defines !== void 0) {
        for (const name in parameters.defines) {
          array.push(name);
          array.push(parameters.defines[name]);
        }
      }
      if (parameters.isRawShaderMaterial === false) {
        getProgramCacheKeyParameters(array, parameters);
        getProgramCacheKeyBooleans(array, parameters);
        array.push(renderer.outputColorSpace);
      }
      array.push(parameters.customProgramCacheKey);
      return array.join();
    }
    function getProgramCacheKeyParameters(array, parameters) {
      array.push(parameters.precision);
      array.push(parameters.outputColorSpace);
      array.push(parameters.envMapMode);
      array.push(parameters.envMapCubeUVHeight);
      array.push(parameters.mapUv);
      array.push(parameters.alphaMapUv);
      array.push(parameters.lightMapUv);
      array.push(parameters.aoMapUv);
      array.push(parameters.bumpMapUv);
      array.push(parameters.normalMapUv);
      array.push(parameters.displacementMapUv);
      array.push(parameters.emissiveMapUv);
      array.push(parameters.metalnessMapUv);
      array.push(parameters.roughnessMapUv);
      array.push(parameters.anisotropyMapUv);
      array.push(parameters.clearcoatMapUv);
      array.push(parameters.clearcoatNormalMapUv);
      array.push(parameters.clearcoatRoughnessMapUv);
      array.push(parameters.iridescenceMapUv);
      array.push(parameters.iridescenceThicknessMapUv);
      array.push(parameters.sheenColorMapUv);
      array.push(parameters.sheenRoughnessMapUv);
      array.push(parameters.specularMapUv);
      array.push(parameters.specularColorMapUv);
      array.push(parameters.specularIntensityMapUv);
      array.push(parameters.transmissionMapUv);
      array.push(parameters.thicknessMapUv);
      array.push(parameters.combine);
      array.push(parameters.fogExp2);
      array.push(parameters.sizeAttenuation);
      array.push(parameters.morphTargetsCount);
      array.push(parameters.morphAttributeCount);
      array.push(parameters.numDirLights);
      array.push(parameters.numPointLights);
      array.push(parameters.numSpotLights);
      array.push(parameters.numSpotLightMaps);
      array.push(parameters.numHemiLights);
      array.push(parameters.numRectAreaLights);
      array.push(parameters.numDirLightShadows);
      array.push(parameters.numPointLightShadows);
      array.push(parameters.numSpotLightShadows);
      array.push(parameters.numSpotLightShadowsWithMaps);
      array.push(parameters.numLightProbes);
      array.push(parameters.shadowMapType);
      array.push(parameters.toneMapping);
      array.push(parameters.numClippingPlanes);
      array.push(parameters.numClipIntersection);
      array.push(parameters.depthPacking);
    }
    function getProgramCacheKeyBooleans(array, parameters) {
      _programLayers.disableAll();
      if (parameters.supportsVertexTextures)
        _programLayers.enable(0);
      if (parameters.instancing)
        _programLayers.enable(1);
      if (parameters.instancingColor)
        _programLayers.enable(2);
      if (parameters.instancingMorph)
        _programLayers.enable(3);
      if (parameters.matcap)
        _programLayers.enable(4);
      if (parameters.envMap)
        _programLayers.enable(5);
      if (parameters.normalMapObjectSpace)
        _programLayers.enable(6);
      if (parameters.normalMapTangentSpace)
        _programLayers.enable(7);
      if (parameters.clearcoat)
        _programLayers.enable(8);
      if (parameters.iridescence)
        _programLayers.enable(9);
      if (parameters.alphaTest)
        _programLayers.enable(10);
      if (parameters.vertexColors)
        _programLayers.enable(11);
      if (parameters.vertexAlphas)
        _programLayers.enable(12);
      if (parameters.vertexUv1s)
        _programLayers.enable(13);
      if (parameters.vertexUv2s)
        _programLayers.enable(14);
      if (parameters.vertexUv3s)
        _programLayers.enable(15);
      if (parameters.vertexTangents)
        _programLayers.enable(16);
      if (parameters.anisotropy)
        _programLayers.enable(17);
      if (parameters.alphaHash)
        _programLayers.enable(18);
      if (parameters.batching)
        _programLayers.enable(19);
      if (parameters.dispersion)
        _programLayers.enable(20);
      if (parameters.batchingColor)
        _programLayers.enable(21);
      array.push(_programLayers.mask);
      _programLayers.disableAll();
      if (parameters.fog)
        _programLayers.enable(0);
      if (parameters.useFog)
        _programLayers.enable(1);
      if (parameters.flatShading)
        _programLayers.enable(2);
      if (parameters.logarithmicDepthBuffer)
        _programLayers.enable(3);
      if (parameters.reverseDepthBuffer)
        _programLayers.enable(4);
      if (parameters.skinning)
        _programLayers.enable(5);
      if (parameters.morphTargets)
        _programLayers.enable(6);
      if (parameters.morphNormals)
        _programLayers.enable(7);
      if (parameters.morphColors)
        _programLayers.enable(8);
      if (parameters.premultipliedAlpha)
        _programLayers.enable(9);
      if (parameters.shadowMapEnabled)
        _programLayers.enable(10);
      if (parameters.doubleSided)
        _programLayers.enable(11);
      if (parameters.flipSided)
        _programLayers.enable(12);
      if (parameters.useDepthPacking)
        _programLayers.enable(13);
      if (parameters.dithering)
        _programLayers.enable(14);
      if (parameters.transmission)
        _programLayers.enable(15);
      if (parameters.sheen)
        _programLayers.enable(16);
      if (parameters.opaque)
        _programLayers.enable(17);
      if (parameters.pointsUvs)
        _programLayers.enable(18);
      if (parameters.decodeVideoTexture)
        _programLayers.enable(19);
      if (parameters.decodeVideoTextureEmissive)
        _programLayers.enable(20);
      if (parameters.alphaToCoverage)
        _programLayers.enable(21);
      array.push(_programLayers.mask);
    }
    function getUniforms(material) {
      const shaderID = shaderIDs[material.type];
      let uniforms;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        uniforms = UniformsUtils.clone(shader.uniforms);
      } else {
        uniforms = material.uniforms;
      }
      return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
      let program;
      for (let p = 0, pl = programs.length; p < pl; p++) {
        const preexistingProgram = programs[p];
        if (preexistingProgram.cacheKey === cacheKey) {
          program = preexistingProgram;
          ++program.usedTimes;
          break;
        }
      }
      if (program === void 0) {
        program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
        programs.push(program);
      }
      return program;
    }
    function releaseProgram(program) {
      if (--program.usedTimes === 0) {
        const i = programs.indexOf(program);
        programs[i] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    }
    function releaseShaderCache(material) {
      _customShaders.remove(material);
    }
    function dispose() {
      _customShaders.dispose();
    }
    return {
      getParameters,
      getProgramCacheKey,
      getUniforms,
      acquireProgram,
      releaseProgram,
      releaseShaderCache,
      // Exposed for resource monitoring & error feedback via renderer.info:
      programs,
      dispose
    };
  }
  function WebGLProperties() {
    let properties = /* @__PURE__ */ new WeakMap();
    function has(object) {
      return properties.has(object);
    }
    function get(object) {
      let map = properties.get(object);
      if (map === void 0) {
        map = {};
        properties.set(object, map);
      }
      return map;
    }
    function remove(object) {
      properties.delete(object);
    }
    function update(object, key, value) {
      properties.get(object)[key] = value;
    }
    function dispose() {
      properties = /* @__PURE__ */ new WeakMap();
    }
    return {
      has,
      get,
      remove,
      update,
      dispose
    };
  }
  function painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.material.id !== b.material.id) {
      return a.material.id - b.material.id;
    } else if (a.z !== b.z) {
      return a.z - b.z;
    } else {
      return a.id - b.id;
    }
  }
  function reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }
  function WebGLRenderList() {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transmissive = [];
    const transparent = [];
    function init() {
      renderItemsIndex = 0;
      opaque.length = 0;
      transmissive.length = 0;
      transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
      let renderItem = renderItems[renderItemsIndex];
      if (renderItem === void 0) {
        renderItem = {
          id: object.id,
          object,
          geometry,
          material,
          groupOrder,
          renderOrder: object.renderOrder,
          z,
          group
        };
        renderItems[renderItemsIndex] = renderItem;
      } else {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.groupOrder = groupOrder;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z;
        renderItem.group = group;
      }
      renderItemsIndex++;
      return renderItem;
    }
    function push(object, geometry, material, groupOrder, z, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      if (material.transmission > 0) {
        transmissive.push(renderItem);
      } else if (material.transparent === true) {
        transparent.push(renderItem);
      } else {
        opaque.push(renderItem);
      }
    }
    function unshift(object, geometry, material, groupOrder, z, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      if (material.transmission > 0) {
        transmissive.unshift(renderItem);
      } else if (material.transparent === true) {
        transparent.unshift(renderItem);
      } else {
        opaque.unshift(renderItem);
      }
    }
    function sort(customOpaqueSort, customTransparentSort) {
      if (opaque.length > 1)
        opaque.sort(customOpaqueSort || painterSortStable);
      if (transmissive.length > 1)
        transmissive.sort(customTransparentSort || reversePainterSortStable);
      if (transparent.length > 1)
        transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
      for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
        const renderItem = renderItems[i];
        if (renderItem.id === null)
          break;
        renderItem.id = null;
        renderItem.object = null;
        renderItem.geometry = null;
        renderItem.material = null;
        renderItem.group = null;
      }
    }
    return {
      opaque,
      transmissive,
      transparent,
      init,
      push,
      unshift,
      finish,
      sort
    };
  }
  function WebGLRenderLists() {
    let lists = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth) {
      const listArray = lists.get(scene);
      let list;
      if (listArray === void 0) {
        list = new WebGLRenderList();
        lists.set(scene, [list]);
      } else {
        if (renderCallDepth >= listArray.length) {
          list = new WebGLRenderList();
          listArray.push(list);
        } else {
          list = listArray[renderCallDepth];
        }
      }
      return list;
    }
    function dispose() {
      lists = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function UniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              direction: new Vector3(),
              color: new Color()
            };
            break;
          case "SpotLight":
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;
          case "RectAreaLight":
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  function ShadowUniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              shadowIntensity: 1,
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "SpotLight":
            uniforms = {
              shadowIntensity: 1,
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "PointLight":
            uniforms = {
              shadowIntensity: 1,
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  var nextVersion = 0;
  function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
  }
  function WebGLLights(extensions) {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0
    };
    for (let i = 0; i < 9; i++)
      state.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights) {
      let r = 0, g = 0, b = 0;
      for (let i = 0; i < 9; i++)
        state.probe[i].set(0, 0, 0);
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      let numDirectionalShadows = 0;
      let numPointShadows = 0;
      let numSpotShadows = 0;
      let numSpotMaps = 0;
      let numSpotShadowsWithMaps = 0;
      let numLightProbes = 0;
      lights.sort(shadowCastingAndTexturingLightsFirst);
      for (let i = 0, l = lights.length; i < l; i++) {
        const light = lights[i];
        const color = light.color;
        const intensity = light.intensity;
        const distance = light.distance;
        const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
        if (light.isAmbientLight) {
          r += color.r * intensity;
          g += color.g * intensity;
          b += color.b * intensity;
        } else if (light.isLightProbe) {
          for (let j = 0; j < 9; j++) {
            state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
          }
          numLightProbes++;
        } else if (light.isDirectionalLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity);
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowIntensity = shadow.intensity;
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.directionalShadow[directionalLength] = shadowUniforms;
            state.directionalShadowMap[directionalLength] = shadowMap;
            state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
            numDirectionalShadows++;
          }
          state.directional[directionalLength] = uniforms;
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = cache.get(light);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.distance = distance;
          uniforms.coneCos = Math.cos(light.angle);
          uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
          uniforms.decay = light.decay;
          state.spot[spotLength] = uniforms;
          const shadow = light.shadow;
          if (light.map) {
            state.spotLightMap[numSpotMaps] = light.map;
            numSpotMaps++;
            shadow.updateMatrices(light);
            if (light.castShadow)
              numSpotShadowsWithMaps++;
          }
          state.spotLightMatrix[spotLength] = shadow.matrix;
          if (light.castShadow) {
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowIntensity = shadow.intensity;
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.spotShadow[spotLength] = shadowUniforms;
            state.spotShadowMap[spotLength] = shadowMap;
            numSpotShadows++;
          }
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          state.rectArea[rectAreaLength] = uniforms;
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity);
          uniforms.distance = light.distance;
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowIntensity = shadow.intensity;
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            shadowUniforms.shadowCameraNear = shadow.camera.near;
            shadowUniforms.shadowCameraFar = shadow.camera.far;
            state.pointShadow[pointLength] = shadowUniforms;
            state.pointShadowMap[pointLength] = shadowMap;
            state.pointShadowMatrix[pointLength] = light.shadow.matrix;
            numPointShadows++;
          }
          state.point[pointLength] = uniforms;
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = cache.get(light);
          uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
          uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
          state.hemi[hemiLength] = uniforms;
          hemiLength++;
        }
      }
      if (rectAreaLength > 0) {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        }
      }
      state.ambient[0] = r;
      state.ambient[1] = g;
      state.ambient[2] = b;
      const hash = state.hash;
      if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
        state.directional.length = directionalLength;
        state.spot.length = spotLength;
        state.rectArea.length = rectAreaLength;
        state.point.length = pointLength;
        state.hemi.length = hemiLength;
        state.directionalShadow.length = numDirectionalShadows;
        state.directionalShadowMap.length = numDirectionalShadows;
        state.pointShadow.length = numPointShadows;
        state.pointShadowMap.length = numPointShadows;
        state.spotShadow.length = numSpotShadows;
        state.spotShadowMap.length = numSpotShadows;
        state.directionalShadowMatrix.length = numDirectionalShadows;
        state.pointShadowMatrix.length = numPointShadows;
        state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
        state.spotLightMap.length = numSpotMaps;
        state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
        state.numLightProbes = numLightProbes;
        hash.directionalLength = directionalLength;
        hash.pointLength = pointLength;
        hash.spotLength = spotLength;
        hash.rectAreaLength = rectAreaLength;
        hash.hemiLength = hemiLength;
        hash.numDirectionalShadows = numDirectionalShadows;
        hash.numPointShadows = numPointShadows;
        hash.numSpotShadows = numSpotShadows;
        hash.numSpotMaps = numSpotMaps;
        hash.numLightProbes = numLightProbes;
        state.version = nextVersion++;
      }
    }
    function setupView(lights, camera) {
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      const viewMatrix = camera.matrixWorldInverse;
      for (let i = 0, l = lights.length; i < l; i++) {
        const light = lights[i];
        if (light.isDirectionalLight) {
          const uniforms = state.directional[directionalLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = state.spot[spotLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = state.rectArea[rectAreaLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          matrix42.identity();
          matrix4.copy(light.matrixWorld);
          matrix4.premultiply(viewMatrix);
          matrix42.extractRotation(matrix4);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          uniforms.halfWidth.applyMatrix4(matrix42);
          uniforms.halfHeight.applyMatrix4(matrix42);
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = state.point[pointLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = state.hemi[hemiLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          uniforms.direction.transformDirection(viewMatrix);
          hemiLength++;
        }
      }
    }
    return {
      setup,
      setupView,
      state
    };
  }
  function WebGLRenderState(extensions) {
    const lights = new WebGLLights(extensions);
    const lightsArray = [];
    const shadowsArray = [];
    function init(camera) {
      state.camera = camera;
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }
    function pushLight(light) {
      lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
      shadowsArray.push(shadowLight);
    }
    function setupLights() {
      lights.setup(lightsArray);
    }
    function setupLightsView(camera) {
      lights.setupView(lightsArray, camera);
    }
    const state = {
      lightsArray,
      shadowsArray,
      camera: null,
      lights,
      transmissionRenderTarget: {}
    };
    return {
      init,
      state,
      setupLights,
      setupLightsView,
      pushLight,
      pushShadow
    };
  }
  function WebGLRenderStates(extensions) {
    let renderStates = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth = 0) {
      const renderStateArray = renderStates.get(scene);
      let renderState;
      if (renderStateArray === void 0) {
        renderState = new WebGLRenderState(extensions);
        renderStates.set(scene, [renderState]);
      } else {
        if (renderCallDepth >= renderStateArray.length) {
          renderState = new WebGLRenderState(extensions);
          renderStateArray.push(renderState);
        } else {
          renderState = renderStateArray[renderCallDepth];
        }
      }
      return renderState;
    }
    function dispose() {
      renderStates = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
  var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
  function WebGLShadowMap(renderer, objects, capabilities) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = capabilities.maxTextureSize;
    const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
    const shadowMaterialVertical = new ShaderMaterial({
      defines: {
        VSM_SAMPLES: 8
      },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 }
      },
      vertexShader: vertex,
      fragmentShader: fragment
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute(
      "position",
      new BufferAttribute(
        new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
        3
      )
    );
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    let _previousType = this.type;
    this.render = function(lights, scene, camera) {
      if (scope.enabled === false)
        return;
      if (scope.autoUpdate === false && scope.needsUpdate === false)
        return;
      if (lights.length === 0)
        return;
      const currentRenderTarget = renderer.getRenderTarget();
      const activeCubeFace = renderer.getActiveCubeFace();
      const activeMipmapLevel = renderer.getActiveMipmapLevel();
      const _state = renderer.state;
      _state.setBlending(NoBlending);
      _state.buffers.color.setClear(1, 1, 1, 1);
      _state.buffers.depth.setTest(true);
      _state.setScissorTest(false);
      const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
      const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
      for (let i = 0, il = lights.length; i < il; i++) {
        const light = lights[i];
        const shadow = light.shadow;
        if (shadow === void 0) {
          console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
          continue;
        }
        if (shadow.autoUpdate === false && shadow.needsUpdate === false)
          continue;
        _shadowMapSize.copy(shadow.mapSize);
        const shadowFrameExtents = shadow.getFrameExtents();
        _shadowMapSize.multiply(shadowFrameExtents);
        _viewportSize.copy(shadow.mapSize);
        if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
          if (_shadowMapSize.x > _maxTextureSize) {
            _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
            _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
            shadow.mapSize.x = _viewportSize.x;
          }
          if (_shadowMapSize.y > _maxTextureSize) {
            _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
            _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
            shadow.mapSize.y = _viewportSize.y;
          }
        }
        if (shadow.map === null || toVSM === true || fromVSM === true) {
          const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
          if (shadow.map !== null) {
            shadow.map.dispose();
          }
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.camera.updateProjectionMatrix();
        }
        renderer.setRenderTarget(shadow.map);
        renderer.clear();
        const viewportCount = shadow.getViewportCount();
        for (let vp = 0; vp < viewportCount; vp++) {
          const viewport = shadow.getViewport(vp);
          _viewport.set(
            _viewportSize.x * viewport.x,
            _viewportSize.y * viewport.y,
            _viewportSize.x * viewport.z,
            _viewportSize.y * viewport.w
          );
          _state.viewport(_viewport);
          shadow.updateMatrices(light, vp);
          _frustum = shadow.getFrustum();
          renderObject(scene, camera, shadow.camera, light, this.type);
        }
        if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
          VSMPass(shadow, camera);
        }
        shadow.needsUpdate = false;
      }
      _previousType = this.type;
      scope.needsUpdate = false;
      renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
      const geometry = objects.update(fullScreenMesh);
      if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
        shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
        shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
        shadowMaterialVertical.needsUpdate = true;
        shadowMaterialHorizontal.needsUpdate = true;
      }
      if (shadow.mapPass === null) {
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
      }
      shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
      shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialVertical.uniforms.radius.value = shadow.radius;
      renderer.setRenderTarget(shadow.mapPass);
      renderer.clear();
      renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
      shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
      shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
      renderer.setRenderTarget(shadow.map);
      renderer.clear();
      renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterial(object, material, light, type) {
      let result = null;
      const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
      if (customMaterial !== void 0) {
        result = customMaterial;
      } else {
        result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
        if (renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
          const keyA = result.uuid, keyB = material.uuid;
          let materialsForVariant = _materialCache[keyA];
          if (materialsForVariant === void 0) {
            materialsForVariant = {};
            _materialCache[keyA] = materialsForVariant;
          }
          let cachedMaterial = materialsForVariant[keyB];
          if (cachedMaterial === void 0) {
            cachedMaterial = result.clone();
            materialsForVariant[keyB] = cachedMaterial;
            material.addEventListener("dispose", onMaterialDispose);
          }
          result = cachedMaterial;
        }
      }
      result.visible = material.visible;
      result.wireframe = material.wireframe;
      if (type === VSMShadowMap) {
        result.side = material.shadowSide !== null ? material.shadowSide : material.side;
      } else {
        result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
      }
      result.alphaMap = material.alphaMap;
      result.alphaTest = material.alphaTest;
      result.map = material.map;
      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;
      result.displacementMap = material.displacementMap;
      result.displacementScale = material.displacementScale;
      result.displacementBias = material.displacementBias;
      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;
      if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
        const materialProperties = renderer.properties.get(result);
        materialProperties.light = light;
      }
      return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let k = 0, kl = groups.length; k < kl; k++) {
              const group = groups[k];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
                object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
                renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
              }
            }
          } else if (material.visible) {
            const depthMaterial = getDepthMaterial(object, material, light, type);
            object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
            renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
            object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        renderObject(children[i], camera, shadowCamera, light, type);
      }
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      for (const id in _materialCache) {
        const cache = _materialCache[id];
        const uuid = event.target.uuid;
        if (uuid in cache) {
          const shadowMaterial = cache[uuid];
          shadowMaterial.dispose();
          delete cache[uuid];
        }
      }
    }
  }
  var reversedFuncs = {
    [NeverDepth]: AlwaysDepth,
    [LessDepth]: GreaterDepth,
    [EqualDepth]: NotEqualDepth,
    [LessEqualDepth]: GreaterEqualDepth,
    [AlwaysDepth]: NeverDepth,
    [GreaterDepth]: LessDepth,
    [NotEqualDepth]: EqualDepth,
    [GreaterEqualDepth]: LessEqualDepth
  };
  function WebGLState(gl, extensions) {
    function ColorBuffer() {
      let locked = false;
      const color = new Vector4();
      let currentColorMask = null;
      const currentColorClear = new Vector4(0, 0, 0, 0);
      return {
        setMask: function(colorMask) {
          if (currentColorMask !== colorMask && !locked) {
            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
            currentColorMask = colorMask;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(r, g, b, a, premultipliedAlpha) {
          if (premultipliedAlpha === true) {
            r *= a;
            g *= a;
            b *= a;
          }
          color.set(r, g, b, a);
          if (currentColorClear.equals(color) === false) {
            gl.clearColor(r, g, b, a);
            currentColorClear.copy(color);
          }
        },
        reset: function() {
          locked = false;
          currentColorMask = null;
          currentColorClear.set(-1, 0, 0, 0);
        }
      };
    }
    function DepthBuffer() {
      let locked = false;
      let reversed = false;
      let currentDepthMask = null;
      let currentDepthFunc = null;
      let currentDepthClear = null;
      return {
        setReversed: function(value) {
          if (reversed !== value) {
            const ext = extensions.get("EXT_clip_control");
            if (reversed) {
              ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT);
            } else {
              ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.NEGATIVE_ONE_TO_ONE_EXT);
            }
            const oldDepth = currentDepthClear;
            currentDepthClear = null;
            this.setClear(oldDepth);
          }
          reversed = value;
        },
        getReversed: function() {
          return reversed;
        },
        setTest: function(depthTest) {
          if (depthTest) {
            enable(gl.DEPTH_TEST);
          } else {
            disable(gl.DEPTH_TEST);
          }
        },
        setMask: function(depthMask) {
          if (currentDepthMask !== depthMask && !locked) {
            gl.depthMask(depthMask);
            currentDepthMask = depthMask;
          }
        },
        setFunc: function(depthFunc) {
          if (reversed)
            depthFunc = reversedFuncs[depthFunc];
          if (currentDepthFunc !== depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(gl.NEVER);
                break;
              case AlwaysDepth:
                gl.depthFunc(gl.ALWAYS);
                break;
              case LessDepth:
                gl.depthFunc(gl.LESS);
                break;
              case LessEqualDepth:
                gl.depthFunc(gl.LEQUAL);
                break;
              case EqualDepth:
                gl.depthFunc(gl.EQUAL);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(gl.GEQUAL);
                break;
              case GreaterDepth:
                gl.depthFunc(gl.GREATER);
                break;
              case NotEqualDepth:
                gl.depthFunc(gl.NOTEQUAL);
                break;
              default:
                gl.depthFunc(gl.LEQUAL);
            }
            currentDepthFunc = depthFunc;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(depth) {
          if (currentDepthClear !== depth) {
            if (reversed) {
              depth = 1 - depth;
            }
            gl.clearDepth(depth);
            currentDepthClear = depth;
          }
        },
        reset: function() {
          locked = false;
          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;
          reversed = false;
        }
      };
    }
    function StencilBuffer() {
      let locked = false;
      let currentStencilMask = null;
      let currentStencilFunc = null;
      let currentStencilRef = null;
      let currentStencilFuncMask = null;
      let currentStencilFail = null;
      let currentStencilZFail = null;
      let currentStencilZPass = null;
      let currentStencilClear = null;
      return {
        setTest: function(stencilTest) {
          if (!locked) {
            if (stencilTest) {
              enable(gl.STENCIL_TEST);
            } else {
              disable(gl.STENCIL_TEST);
            }
          }
        },
        setMask: function(stencilMask) {
          if (currentStencilMask !== stencilMask && !locked) {
            gl.stencilMask(stencilMask);
            currentStencilMask = stencilMask;
          }
        },
        setFunc: function(stencilFunc, stencilRef, stencilMask) {
          if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;
          }
        },
        setOp: function(stencilFail, stencilZFail, stencilZPass) {
          if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(stencil) {
          if (currentStencilClear !== stencil) {
            gl.clearStencil(stencil);
            currentStencilClear = stencil;
          }
        },
        reset: function() {
          locked = false;
          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;
        }
      };
    }
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    const uboBindings = /* @__PURE__ */ new WeakMap();
    const uboProgramMap = /* @__PURE__ */ new WeakMap();
    let enabledCapabilities = {};
    let currentBoundFramebuffers = {};
    let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    let defaultDrawbuffers = [];
    let currentProgram = null;
    let currentBlendingEnabled = false;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentBlendColor = new Color(0, 0, 0);
    let currentBlendAlpha = 0;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(gl.VERSION);
    if (glVersion.indexOf("WebGL") !== -1) {
      version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
      version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
    const viewportParam = gl.getParameter(gl.VIEWPORT);
    const currentScissor = new Vector4().fromArray(scissorParam);
    const currentViewport = new Vector4().fromArray(viewportParam);
    function createTexture(type, target, count, dimensions) {
      const data = new Uint8Array(4);
      const texture = gl.createTexture();
      gl.bindTexture(type, texture);
      gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      for (let i = 0; i < count; i++) {
        if (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY) {
          gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        } else {
          gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        }
      }
      return texture;
    }
    const emptyTextures = {};
    emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
    emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
    emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
    emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(gl.DEPTH_TEST);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(gl.CULL_FACE);
    setBlending(NoBlending);
    function enable(id) {
      if (enabledCapabilities[id] !== true) {
        gl.enable(id);
        enabledCapabilities[id] = true;
      }
    }
    function disable(id) {
      if (enabledCapabilities[id] !== false) {
        gl.disable(id);
        enabledCapabilities[id] = false;
      }
    }
    function bindFramebuffer(target, framebuffer) {
      if (currentBoundFramebuffers[target] !== framebuffer) {
        gl.bindFramebuffer(target, framebuffer);
        currentBoundFramebuffers[target] = framebuffer;
        if (target === gl.DRAW_FRAMEBUFFER) {
          currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
        }
        if (target === gl.FRAMEBUFFER) {
          currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
        }
        return true;
      }
      return false;
    }
    function drawBuffers(renderTarget, framebuffer) {
      let drawBuffers2 = defaultDrawbuffers;
      let needsUpdate = false;
      if (renderTarget) {
        drawBuffers2 = currentDrawbuffers.get(framebuffer);
        if (drawBuffers2 === void 0) {
          drawBuffers2 = [];
          currentDrawbuffers.set(framebuffer, drawBuffers2);
        }
        const textures = renderTarget.textures;
        if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
          for (let i = 0, il = textures.length; i < il; i++) {
            drawBuffers2[i] = gl.COLOR_ATTACHMENT0 + i;
          }
          drawBuffers2.length = textures.length;
          needsUpdate = true;
        }
      } else {
        if (drawBuffers2[0] !== gl.BACK) {
          drawBuffers2[0] = gl.BACK;
          needsUpdate = true;
        }
      }
      if (needsUpdate) {
        gl.drawBuffers(drawBuffers2);
      }
    }
    function useProgram(program) {
      if (currentProgram !== program) {
        gl.useProgram(program);
        currentProgram = program;
        return true;
      }
      return false;
    }
    const equationToGL = {
      [AddEquation]: gl.FUNC_ADD,
      [SubtractEquation]: gl.FUNC_SUBTRACT,
      [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
    };
    equationToGL[MinEquation] = gl.MIN;
    equationToGL[MaxEquation] = gl.MAX;
    const factorToGL = {
      [ZeroFactor]: gl.ZERO,
      [OneFactor]: gl.ONE,
      [SrcColorFactor]: gl.SRC_COLOR,
      [SrcAlphaFactor]: gl.SRC_ALPHA,
      [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
      [DstColorFactor]: gl.DST_COLOR,
      [DstAlphaFactor]: gl.DST_ALPHA,
      [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
      [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
      [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
      [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,
      [ConstantColorFactor]: gl.CONSTANT_COLOR,
      [OneMinusConstantColorFactor]: gl.ONE_MINUS_CONSTANT_COLOR,
      [ConstantAlphaFactor]: gl.CONSTANT_ALPHA,
      [OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
      if (blending === NoBlending) {
        if (currentBlendingEnabled === true) {
          disable(gl.BLEND);
          currentBlendingEnabled = false;
        }
        return;
      }
      if (currentBlendingEnabled === false) {
        enable(gl.BLEND);
        currentBlendingEnabled = true;
      }
      if (blending !== CustomBlending) {
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
          if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
            gl.blendEquation(gl.FUNC_ADD);
            currentBlendEquation = AddEquation;
            currentBlendEquationAlpha = AddEquation;
          }
          if (premultipliedAlpha) {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                break;
              case AdditiveBlending:
                gl.blendFunc(gl.ONE, gl.ONE);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                break;
              case MultiplyBlending:
                gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          } else {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                break;
              case AdditiveBlending:
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                break;
              case MultiplyBlending:
                gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          }
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentBlendColor.set(0, 0, 0);
          currentBlendAlpha = 0;
          currentBlending = blending;
          currentPremultipledAlpha = premultipliedAlpha;
        }
        return;
      }
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
      if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
        gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
        currentBlendColor.copy(blendColor);
        currentBlendAlpha = blendAlpha;
      }
      currentBlending = blending;
      currentPremultipledAlpha = false;
    }
    function setMaterial(material, frontFaceCW) {
      material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
      let flipSided = material.side === BackSide;
      if (frontFaceCW)
        flipSided = !flipSided;
      setFlipSided(flipSided);
      material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
      depthBuffer.setFunc(material.depthFunc);
      depthBuffer.setTest(material.depthTest);
      depthBuffer.setMask(material.depthWrite);
      colorBuffer.setMask(material.colorWrite);
      const stencilWrite = material.stencilWrite;
      stencilBuffer.setTest(stencilWrite);
      if (stencilWrite) {
        stencilBuffer.setMask(material.stencilWriteMask);
        stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
        stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
      }
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    }
    function setFlipSided(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl.frontFace(gl.CW);
        } else {
          gl.frontFace(gl.CCW);
        }
        currentFlipSided = flipSided;
      }
    }
    function setCullFace(cullFace) {
      if (cullFace !== CullFaceNone) {
        enable(gl.CULL_FACE);
        if (cullFace !== currentCullFace) {
          if (cullFace === CullFaceBack) {
            gl.cullFace(gl.BACK);
          } else if (cullFace === CullFaceFront) {
            gl.cullFace(gl.FRONT);
          } else {
            gl.cullFace(gl.FRONT_AND_BACK);
          }
        }
      } else {
        disable(gl.CULL_FACE);
      }
      currentCullFace = cullFace;
    }
    function setLineWidth(width) {
      if (width !== currentLineWidth) {
        if (lineWidthAvailable)
          gl.lineWidth(width);
        currentLineWidth = width;
      }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        enable(gl.POLYGON_OFFSET_FILL);
        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      } else {
        disable(gl.POLYGON_OFFSET_FILL);
      }
    }
    function setScissorTest(scissorTest) {
      if (scissorTest) {
        enable(gl.SCISSOR_TEST);
      } else {
        disable(gl.SCISSOR_TEST);
      }
    }
    function activeTexture(webglSlot) {
      if (webglSlot === void 0)
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    }
    function bindTexture(webglType, webglTexture, webglSlot) {
      if (webglSlot === void 0) {
        if (currentTextureSlot === null) {
          webglSlot = gl.TEXTURE0 + maxTextures - 1;
        } else {
          webglSlot = currentTextureSlot;
        }
      }
      let boundTexture = currentBoundTextures[webglSlot];
      if (boundTexture === void 0) {
        boundTexture = { type: void 0, texture: void 0 };
        currentBoundTextures[webglSlot] = boundTexture;
      }
      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        if (currentTextureSlot !== webglSlot) {
          gl.activeTexture(webglSlot);
          currentTextureSlot = webglSlot;
        }
        gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    }
    function unbindTexture() {
      const boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture !== void 0 && boundTexture.type !== void 0) {
        gl.bindTexture(boundTexture.type, null);
        boundTexture.type = void 0;
        boundTexture.texture = void 0;
      }
    }
    function compressedTexImage2D() {
      try {
        gl.compressedTexImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexImage3D() {
      try {
        gl.compressedTexImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texSubImage2D() {
      try {
        gl.texSubImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texSubImage3D() {
      try {
        gl.texSubImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexSubImage2D() {
      try {
        gl.compressedTexSubImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexSubImage3D() {
      try {
        gl.compressedTexSubImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texStorage2D() {
      try {
        gl.texStorage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texStorage3D() {
      try {
        gl.texStorage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage2D() {
      try {
        gl.texImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage3D() {
      try {
        gl.texImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function scissor(scissor2) {
      if (currentScissor.equals(scissor2) === false) {
        gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
        currentScissor.copy(scissor2);
      }
    }
    function viewport(viewport2) {
      if (currentViewport.equals(viewport2) === false) {
        gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
        currentViewport.copy(viewport2);
      }
    }
    function updateUBOMapping(uniformsGroup, program) {
      let mapping = uboProgramMap.get(program);
      if (mapping === void 0) {
        mapping = /* @__PURE__ */ new WeakMap();
        uboProgramMap.set(program, mapping);
      }
      let blockIndex = mapping.get(uniformsGroup);
      if (blockIndex === void 0) {
        blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
        mapping.set(uniformsGroup, blockIndex);
      }
    }
    function uniformBlockBinding(uniformsGroup, program) {
      const mapping = uboProgramMap.get(program);
      const blockIndex = mapping.get(uniformsGroup);
      if (uboBindings.get(program) !== blockIndex) {
        gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
        uboBindings.set(program, blockIndex);
      }
    }
    function reset() {
      gl.disable(gl.BLEND);
      gl.disable(gl.CULL_FACE);
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.POLYGON_OFFSET_FILL);
      gl.disable(gl.SCISSOR_TEST);
      gl.disable(gl.STENCIL_TEST);
      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      gl.blendEquation(gl.FUNC_ADD);
      gl.blendFunc(gl.ONE, gl.ZERO);
      gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
      gl.blendColor(0, 0, 0, 0);
      gl.colorMask(true, true, true, true);
      gl.clearColor(0, 0, 0, 0);
      gl.depthMask(true);
      gl.depthFunc(gl.LESS);
      depthBuffer.setReversed(false);
      gl.clearDepth(1);
      gl.stencilMask(4294967295);
      gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      gl.clearStencil(0);
      gl.cullFace(gl.BACK);
      gl.frontFace(gl.CCW);
      gl.polygonOffset(0, 0);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
      gl.useProgram(null);
      gl.lineWidth(1);
      gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      enabledCapabilities = {};
      currentTextureSlot = null;
      currentBoundTextures = {};
      currentBoundFramebuffers = {};
      currentDrawbuffers = /* @__PURE__ */ new WeakMap();
      defaultDrawbuffers = [];
      currentProgram = null;
      currentBlendingEnabled = false;
      currentBlending = null;
      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;
      currentBlendColor = new Color(0, 0, 0);
      currentBlendAlpha = 0;
      currentPremultipledAlpha = false;
      currentFlipSided = null;
      currentCullFace = null;
      currentLineWidth = null;
      currentPolygonOffsetFactor = null;
      currentPolygonOffsetUnits = null;
      currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
      currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();
    }
    return {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      enable,
      disable,
      bindFramebuffer,
      drawBuffers,
      useProgram,
      setBlending,
      setMaterial,
      setFlipSided,
      setCullFace,
      setLineWidth,
      setPolygonOffset,
      setScissorTest,
      activeTexture,
      bindTexture,
      unbindTexture,
      compressedTexImage2D,
      compressedTexImage3D,
      texImage2D,
      texImage3D,
      updateUBOMapping,
      uniformBlockBinding,
      texStorage2D,
      texStorage3D,
      texSubImage2D,
      texSubImage3D,
      compressedTexSubImage2D,
      compressedTexSubImage3D,
      scissor,
      viewport,
      reset
    };
  }
  function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
    const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
    const _imageDimensions = new Vector2();
    const _videoTextures = /* @__PURE__ */ new WeakMap();
    let _canvas2;
    const _sources = /* @__PURE__ */ new WeakMap();
    let useOffscreenCanvas = false;
    try {
      useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    }
    function createCanvas(width, height) {
      return useOffscreenCanvas ? (
        // eslint-disable-next-line compat/compat
        new OffscreenCanvas(width, height)
      ) : createElementNS("canvas");
    }
    function resizeImage(image, needsNewCanvas, maxSize) {
      let scale = 1;
      const dimensions = getDimensions(image);
      if (dimensions.width > maxSize || dimensions.height > maxSize) {
        scale = maxSize / Math.max(dimensions.width, dimensions.height);
      }
      if (scale < 1) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap || typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
          const width = Math.floor(scale * dimensions.width);
          const height = Math.floor(scale * dimensions.height);
          if (_canvas2 === void 0)
            _canvas2 = createCanvas(width, height);
          const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
          canvas.width = width;
          canvas.height = height;
          const context = canvas.getContext("2d");
          context.drawImage(image, 0, 0, width, height);
          console.warn("THREE.WebGLRenderer: Texture has been resized from (" + dimensions.width + "x" + dimensions.height + ") to (" + width + "x" + height + ").");
          return canvas;
        } else {
          if ("data" in image) {
            console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + dimensions.width + "x" + dimensions.height + ").");
          }
          return image;
        }
      }
      return image;
    }
    function textureNeedsGenerateMipmaps(texture) {
      return texture.generateMipmaps;
    }
    function generateMipmap(target) {
      _gl.generateMipmap(target);
    }
    function getTargetType(texture) {
      if (texture.isWebGLCubeRenderTarget)
        return _gl.TEXTURE_CUBE_MAP;
      if (texture.isWebGL3DRenderTarget)
        return _gl.TEXTURE_3D;
      if (texture.isWebGLArrayRenderTarget || texture.isCompressedArrayTexture)
        return _gl.TEXTURE_2D_ARRAY;
      return _gl.TEXTURE_2D;
    }
    function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
      if (internalFormatName !== null) {
        if (_gl[internalFormatName] !== void 0)
          return _gl[internalFormatName];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
      }
      let internalFormat = glFormat;
      if (glFormat === _gl.RED) {
        if (glType === _gl.FLOAT)
          internalFormat = _gl.R32F;
        if (glType === _gl.HALF_FLOAT)
          internalFormat = _gl.R16F;
        if (glType === _gl.UNSIGNED_BYTE)
          internalFormat = _gl.R8;
      }
      if (glFormat === _gl.RED_INTEGER) {
        if (glType === _gl.UNSIGNED_BYTE)
          internalFormat = _gl.R8UI;
        if (glType === _gl.UNSIGNED_SHORT)
          internalFormat = _gl.R16UI;
        if (glType === _gl.UNSIGNED_INT)
          internalFormat = _gl.R32UI;
        if (glType === _gl.BYTE)
          internalFormat = _gl.R8I;
        if (glType === _gl.SHORT)
          internalFormat = _gl.R16I;
        if (glType === _gl.INT)
          internalFormat = _gl.R32I;
      }
      if (glFormat === _gl.RG) {
        if (glType === _gl.FLOAT)
          internalFormat = _gl.RG32F;
        if (glType === _gl.HALF_FLOAT)
          internalFormat = _gl.RG16F;
        if (glType === _gl.UNSIGNED_BYTE)
          internalFormat = _gl.RG8;
      }
      if (glFormat === _gl.RG_INTEGER) {
        if (glType === _gl.UNSIGNED_BYTE)
          internalFormat = _gl.RG8UI;
        if (glType === _gl.UNSIGNED_SHORT)
          internalFormat = _gl.RG16UI;
        if (glType === _gl.UNSIGNED_INT)
          internalFormat = _gl.RG32UI;
        if (glType === _gl.BYTE)
          internalFormat = _gl.RG8I;
        if (glType === _gl.SHORT)
          internalFormat = _gl.RG16I;
        if (glType === _gl.INT)
          internalFormat = _gl.RG32I;
      }
      if (glFormat === _gl.RGB_INTEGER) {
        if (glType === _gl.UNSIGNED_BYTE)
          internalFormat = _gl.RGB8UI;
        if (glType === _gl.UNSIGNED_SHORT)
          internalFormat = _gl.RGB16UI;
        if (glType === _gl.UNSIGNED_INT)
          internalFormat = _gl.RGB32UI;
        if (glType === _gl.BYTE)
          internalFormat = _gl.RGB8I;
        if (glType === _gl.SHORT)
          internalFormat = _gl.RGB16I;
        if (glType === _gl.INT)
          internalFormat = _gl.RGB32I;
      }
      if (glFormat === _gl.RGBA_INTEGER) {
        if (glType === _gl.UNSIGNED_BYTE)
          internalFormat = _gl.RGBA8UI;
        if (glType === _gl.UNSIGNED_SHORT)
          internalFormat = _gl.RGBA16UI;
        if (glType === _gl.UNSIGNED_INT)
          internalFormat = _gl.RGBA32UI;
        if (glType === _gl.BYTE)
          internalFormat = _gl.RGBA8I;
        if (glType === _gl.SHORT)
          internalFormat = _gl.RGBA16I;
        if (glType === _gl.INT)
          internalFormat = _gl.RGBA32I;
      }
      if (glFormat === _gl.RGB) {
        if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV)
          internalFormat = _gl.RGB9_E5;
      }
      if (glFormat === _gl.RGBA) {
        const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
        if (glType === _gl.FLOAT)
          internalFormat = _gl.RGBA32F;
        if (glType === _gl.HALF_FLOAT)
          internalFormat = _gl.RGBA16F;
        if (glType === _gl.UNSIGNED_BYTE)
          internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
        if (glType === _gl.UNSIGNED_SHORT_4_4_4_4)
          internalFormat = _gl.RGBA4;
        if (glType === _gl.UNSIGNED_SHORT_5_5_5_1)
          internalFormat = _gl.RGB5_A1;
      }
      if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
        extensions.get("EXT_color_buffer_float");
      }
      return internalFormat;
    }
    function getInternalDepthFormat(useStencil, depthType) {
      let glInternalFormat;
      if (useStencil) {
        if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
          glInternalFormat = _gl.DEPTH24_STENCIL8;
        } else if (depthType === FloatType) {
          glInternalFormat = _gl.DEPTH32F_STENCIL8;
        } else if (depthType === UnsignedShortType) {
          glInternalFormat = _gl.DEPTH24_STENCIL8;
          console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.");
        }
      } else {
        if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
          glInternalFormat = _gl.DEPTH_COMPONENT24;
        } else if (depthType === FloatType) {
          glInternalFormat = _gl.DEPTH_COMPONENT32F;
        } else if (depthType === UnsignedShortType) {
          glInternalFormat = _gl.DEPTH_COMPONENT16;
        }
      }
      return glInternalFormat;
    }
    function getMipLevels(texture, image) {
      if (textureNeedsGenerateMipmaps(texture) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        return Math.log2(Math.max(image.width, image.height)) + 1;
      } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
        return texture.mipmaps.length;
      } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
        return image.mipmaps.length;
      } else {
        return 1;
      }
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      deallocateTexture(texture);
      if (texture.isVideoTexture) {
        _videoTextures.delete(texture);
      }
    }
    function onRenderTargetDispose(event) {
      const renderTarget = event.target;
      renderTarget.removeEventListener("dispose", onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
    }
    function deallocateTexture(texture) {
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglInit === void 0)
        return;
      const source = texture.source;
      const webglTextures = _sources.get(source);
      if (webglTextures) {
        const webglTexture = webglTextures[textureProperties.__cacheKey];
        webglTexture.usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
        if (Object.keys(webglTextures).length === 0) {
          _sources.delete(source);
        }
      }
      properties.remove(texture);
    }
    function deleteTexture(texture) {
      const textureProperties = properties.get(texture);
      _gl.deleteTexture(textureProperties.__webglTexture);
      const source = texture.source;
      const webglTextures = _sources.get(source);
      delete webglTextures[textureProperties.__cacheKey];
      info.memory.textures--;
    }
    function deallocateRenderTarget(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
        properties.remove(renderTarget.depthTexture);
      }
      if (renderTarget.isWebGLCubeRenderTarget) {
        for (let i = 0; i < 6; i++) {
          if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) {
            for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++)
              _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);
          } else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
          }
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
        }
      } else {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
          for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++)
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        }
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        if (renderTargetProperties.__webglMultisampledFramebuffer)
          _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
        if (renderTargetProperties.__webglColorRenderbuffer) {
          for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {
            if (renderTargetProperties.__webglColorRenderbuffer[i])
              _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
          }
        }
        if (renderTargetProperties.__webglDepthRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
      }
      const textures = renderTarget.textures;
      for (let i = 0, il = textures.length; i < il; i++) {
        const attachmentProperties = properties.get(textures[i]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(textures[i]);
      }
      properties.remove(renderTarget);
    }
    let textureUnits = 0;
    function resetTextureUnits() {
      textureUnits = 0;
    }
    function allocateTextureUnit() {
      const textureUnit = textureUnits;
      if (textureUnit >= capabilities.maxTextures) {
        console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
      }
      textureUnits += 1;
      return textureUnit;
    }
    function getTextureCacheKey(texture) {
      const array = [];
      array.push(texture.wrapS);
      array.push(texture.wrapT);
      array.push(texture.wrapR || 0);
      array.push(texture.magFilter);
      array.push(texture.minFilter);
      array.push(texture.anisotropy);
      array.push(texture.internalFormat);
      array.push(texture.format);
      array.push(texture.type);
      array.push(texture.generateMipmaps);
      array.push(texture.premultiplyAlpha);
      array.push(texture.flipY);
      array.push(texture.unpackAlignment);
      array.push(texture.colorSpace);
      return array.join();
    }
    function setTexture2D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.isVideoTexture)
        updateVideoTexture(texture);
      if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
        const image = texture.image;
        if (image === null) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        } else if (image.complete === false) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        } else {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
      }
      state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    }
    function setTexture2DArray(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    }
    function setTexture3D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    }
    function setTextureCube(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadCubeTexture(textureProperties, texture, slot);
        return;
      }
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    }
    const wrappingToGL = {
      [RepeatWrapping]: _gl.REPEAT,
      [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
    };
    const filterToGL = {
      [NearestFilter]: _gl.NEAREST,
      [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: _gl.LINEAR,
      [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
    };
    const compareToGL = {
      [NeverCompare]: _gl.NEVER,
      [AlwaysCompare]: _gl.ALWAYS,
      [LessCompare]: _gl.LESS,
      [LessEqualCompare]: _gl.LEQUAL,
      [EqualCompare]: _gl.EQUAL,
      [GreaterEqualCompare]: _gl.GEQUAL,
      [GreaterCompare]: _gl.GREATER,
      [NotEqualCompare]: _gl.NOTEQUAL
    };
    function setTextureParameters(textureType, texture) {
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter)) {
        console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.");
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
      if (texture.compareFunction) {
        _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
        _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
      }
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        if (texture.magFilter === NearestFilter)
          return;
        if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter)
          return;
        if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
          return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          const extension = extensions.get("EXT_texture_filter_anisotropic");
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }
    function initTexture(textureProperties, texture) {
      let forceUpload = false;
      if (textureProperties.__webglInit === void 0) {
        textureProperties.__webglInit = true;
        texture.addEventListener("dispose", onTextureDispose);
      }
      const source = texture.source;
      let webglTextures = _sources.get(source);
      if (webglTextures === void 0) {
        webglTextures = {};
        _sources.set(source, webglTextures);
      }
      const textureCacheKey = getTextureCacheKey(texture);
      if (textureCacheKey !== textureProperties.__cacheKey) {
        if (webglTextures[textureCacheKey] === void 0) {
          webglTextures[textureCacheKey] = {
            texture: _gl.createTexture(),
            usedTimes: 0
          };
          info.memory.textures++;
          forceUpload = true;
        }
        webglTextures[textureCacheKey].usedTimes++;
        const webglTexture = webglTextures[textureProperties.__cacheKey];
        if (webglTexture !== void 0) {
          webglTextures[textureProperties.__cacheKey].usedTimes--;
          if (webglTexture.usedTimes === 0) {
            deleteTexture(texture);
          }
        }
        textureProperties.__cacheKey = textureCacheKey;
        textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
      }
      return forceUpload;
    }
    function uploadTexture(textureProperties, texture, slot) {
      let textureType = _gl.TEXTURE_2D;
      if (texture.isDataArrayTexture || texture.isCompressedArrayTexture)
        textureType = _gl.TEXTURE_2D_ARRAY;
      if (texture.isData3DTexture)
        textureType = _gl.TEXTURE_3D;
      const forceUpload = initTexture(textureProperties, texture);
      const source = texture.source;
      state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
      const sourceProperties = properties.get(source);
      if (source.version !== sourceProperties.__version || forceUpload === true) {
        state.activeTexture(_gl.TEXTURE0 + slot);
        const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
        const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
        const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
        let image = resizeImage(texture.image, false, capabilities.maxTextureSize);
        image = verifyColorSpace(texture, image);
        const glFormat = utils.convert(texture.format, texture.colorSpace);
        const glType = utils.convert(texture.type);
        let glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
        setTextureParameters(textureType, texture);
        let mipmap;
        const mipmaps = texture.mipmaps;
        const useTexStorage = texture.isVideoTexture !== true;
        const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
        const dataReady = source.dataReady;
        const levels = getMipLevels(texture, image);
        if (texture.isDepthTexture) {
          glInternalFormat = getInternalDepthFormat(texture.format === DepthStencilFormat, texture.type);
          if (allocateMemory) {
            if (useTexStorage) {
              state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
            }
          }
        } else if (texture.isDataTexture) {
          if (mipmaps.length > 0) {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
            texture.generateMipmaps = false;
          } else {
            if (useTexStorage) {
              if (allocateMemory) {
                state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
              }
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
            }
          }
        } else if (texture.isCompressedTexture) {
          if (texture.isCompressedArrayTexture) {
            if (useTexStorage && allocateMemory) {
              state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
            }
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    if (dataReady) {
                      if (texture.layerUpdates.size > 0) {
                        const layerByteLength = getByteLength(mipmap.width, mipmap.height, texture.format, texture.type);
                        for (const layerIndex of texture.layerUpdates) {
                          const layerData = mipmap.data.subarray(
                            layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,
                            (layerIndex + 1) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT
                          );
                          state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData);
                        }
                        texture.clearLayerUpdates();
                      } else {
                        state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);
                      }
                    }
                  } else {
                    state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                }
              } else {
                if (useTexStorage) {
                  if (dataReady) {
                    state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
                  }
                } else {
                  state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          } else {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    if (dataReady) {
                      state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                    }
                  } else {
                    state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                }
              } else {
                if (useTexStorage) {
                  if (dataReady) {
                    state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                  }
                } else {
                  state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          }
        } else if (texture.isDataArrayTexture) {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
            }
            if (dataReady) {
              if (texture.layerUpdates.size > 0) {
                const layerByteLength = getByteLength(image.width, image.height, texture.format, texture.type);
                for (const layerIndex of texture.layerUpdates) {
                  const layerData = image.data.subarray(
                    layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,
                    (layerIndex + 1) * layerByteLength / image.data.BYTES_PER_ELEMENT
                  );
                  state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData);
                }
                texture.clearLayerUpdates();
              } else {
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
              }
            }
          } else {
            state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          }
        } else if (texture.isData3DTexture) {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
            }
            if (dataReady) {
              state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
            }
          } else {
            state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          }
        } else if (texture.isFramebufferTexture) {
          if (allocateMemory) {
            if (useTexStorage) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            } else {
              let width = image.width, height = image.height;
              for (let i = 0; i < levels; i++) {
                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null);
                width >>= 1;
                height >>= 1;
              }
            }
          }
        } else {
          if (mipmaps.length > 0) {
            if (useTexStorage && allocateMemory) {
              const dimensions = getDimensions(mipmaps[0]);
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
            }
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
              }
            }
            texture.generateMipmaps = false;
          } else {
            if (useTexStorage) {
              if (allocateMemory) {
                const dimensions = getDimensions(image);
                state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
              }
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture)) {
          generateMipmap(textureType);
        }
        sourceProperties.__version = source.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      textureProperties.__version = texture.version;
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
      if (texture.image.length !== 6)
        return;
      const forceUpload = initTexture(textureProperties, texture);
      const source = texture.source;
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
      const sourceProperties = properties.get(source);
      if (source.version !== sourceProperties.__version || forceUpload === true) {
        state.activeTexture(_gl.TEXTURE0 + slot);
        const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
        const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
        const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
        const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
        const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        const cubeImage = [];
        for (let i = 0; i < 6; i++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i] = resizeImage(texture.image[i], true, capabilities.maxCubemapSize);
          } else {
            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
          }
          cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
        }
        const image = cubeImage[0], glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        const useTexStorage = texture.isVideoTexture !== true;
        const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
        const dataReady = source.dataReady;
        let levels = getMipLevels(texture, image);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
        let mipmaps;
        if (isCompressed) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
          }
          for (let i = 0; i < 6; i++) {
            mipmaps = cubeImage[i].mipmaps;
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    if (dataReady) {
                      state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                    }
                  } else {
                    state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                }
              } else {
                if (useTexStorage) {
                  if (dataReady) {
                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                  }
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          }
        } else {
          mipmaps = texture.mipmaps;
          if (useTexStorage && allocateMemory) {
            if (mipmaps.length > 0)
              levels++;
            const dimensions = getDimensions(cubeImage[0]);
            state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);
          }
          for (let i = 0; i < 6; i++) {
            if (isDataTexture) {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
              }
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                const mipmapImage = mipmap.image[i].image;
                if (useTexStorage) {
                  if (dataReady) {
                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                  }
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                }
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
              }
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                if (useTexStorage) {
                  if (dataReady) {
                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
                  }
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
                }
              }
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture)) {
          generateMipmap(_gl.TEXTURE_CUBE_MAP);
        }
        sourceProperties.__version = source.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      textureProperties.__version = texture.version;
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
      const glFormat = utils.convert(texture.format, texture.colorSpace);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      textureProperties.__renderTarget = renderTarget;
      if (!renderTargetProperties.__hasExternalTextures) {
        const width = Math.max(1, renderTarget.width >> level);
        const height = Math.max(1, renderTarget.height >> level);
        if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
          state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
        } else {
          state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
        }
      }
      state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, 0, getRenderTargetSamples(renderTarget));
      } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, level);
      }
      state.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
      if (renderTarget.depthBuffer) {
        const depthTexture = renderTarget.depthTexture;
        const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
        const glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);
        const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
        const samples = getRenderTargetSamples(renderTarget);
        const isUseMultisampledRTT = useMultisampledRTT(renderTarget);
        if (isUseMultisampledRTT) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (isMultisample) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
      } else {
        const textures = renderTarget.textures;
        for (let i = 0; i < textures.length; i++) {
          const texture = textures[i];
          const glFormat = utils.convert(texture.format, texture.colorSpace);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
          const samples = getRenderTargetSamples(renderTarget);
          if (isMultisample && useMultisampledRTT(renderTarget) === false) {
            _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else if (useMultisampledRTT(renderTarget)) {
            multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
          }
        }
      }
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
      const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
      if (isCube)
        throw new Error("Depth Texture with cube render targets is not supported");
      state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      }
      const textureProperties = properties.get(renderTarget.depthTexture);
      textureProperties.__renderTarget = renderTarget;
      if (!textureProperties.__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
      }
      setTexture2D(renderTarget.depthTexture, 0);
      const webglDepthTexture = textureProperties.__webglTexture;
      const samples = getRenderTargetSamples(renderTarget);
      if (renderTarget.depthTexture.format === DepthFormat) {
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        }
      } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        }
      } else {
        throw new Error("Unknown depthTexture format");
      }
    }
    function setupDepthRenderbuffer(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      if (renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture) {
        const depthTexture = renderTarget.depthTexture;
        if (renderTargetProperties.__depthDisposeCallback) {
          renderTargetProperties.__depthDisposeCallback();
        }
        if (depthTexture) {
          const disposeEvent = () => {
            delete renderTargetProperties.__boundDepthTexture;
            delete renderTargetProperties.__depthDisposeCallback;
            depthTexture.removeEventListener("dispose", disposeEvent);
          };
          depthTexture.addEventListener("dispose", disposeEvent);
          renderTargetProperties.__depthDisposeCallback = disposeEvent;
        }
        renderTargetProperties.__boundDepthTexture = depthTexture;
      }
      if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
        if (isCube)
          throw new Error("target.depthTexture not supported in Cube render targets");
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
      } else {
        if (isCube) {
          renderTargetProperties.__webglDepthbuffer = [];
          for (let i = 0; i < 6; i++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
            if (renderTargetProperties.__webglDepthbuffer[i] === void 0) {
              renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
            } else {
              const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
              const renderbuffer = renderTargetProperties.__webglDepthbuffer[i];
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
              _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
            }
          }
        } else {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          if (renderTargetProperties.__webglDepthbuffer === void 0) {
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
          } else {
            const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
            const renderbuffer = renderTargetProperties.__webglDepthbuffer;
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
          }
        }
      }
      state.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    function rebindTextures(renderTarget, colorTexture, depthTexture) {
      const renderTargetProperties = properties.get(renderTarget);
      if (colorTexture !== void 0) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
      }
      if (depthTexture !== void 0) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function setupRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      renderTarget.addEventListener("dispose", onRenderTargetDispose);
      const textures = renderTarget.textures;
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isMultipleRenderTargets = textures.length > 1;
      if (!isMultipleRenderTargets) {
        if (textureProperties.__webglTexture === void 0) {
          textureProperties.__webglTexture = _gl.createTexture();
        }
        textureProperties.__version = texture.version;
        info.memory.textures++;
      }
      if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let i = 0; i < 6; i++) {
          if (texture.mipmaps && texture.mipmaps.length > 0) {
            renderTargetProperties.__webglFramebuffer[i] = [];
            for (let level = 0; level < texture.mipmaps.length; level++) {
              renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer();
            }
          } else {
            renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
          }
        }
      } else {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer = [];
          for (let level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        }
        if (isMultipleRenderTargets) {
          for (let i = 0, il = textures.length; i < il; i++) {
            const attachmentProperties = properties.get(textures[i]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        }
        if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = [];
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          for (let i = 0; i < textures.length; i++) {
            const texture2 = textures[i];
            renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
            const glFormat = utils.convert(texture2.format, texture2.colorSpace);
            const glType = utils.convert(texture2.type);
            const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);
            const samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
          }
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
      }
      if (isCube) {
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
        for (let i = 0; i < 6; i++) {
          if (texture.mipmaps && texture.mipmaps.length > 0) {
            for (let level = 0; level < texture.mipmaps.length; level++) {
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level);
            }
          } else {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);
          }
        }
        if (textureNeedsGenerateMipmaps(texture)) {
          generateMipmap(_gl.TEXTURE_CUBE_MAP);
        }
        state.unbindTexture();
      } else if (isMultipleRenderTargets) {
        for (let i = 0, il = textures.length; i < il; i++) {
          const attachment = textures[i];
          const attachmentProperties = properties.get(attachment);
          state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
          setTextureParameters(_gl.TEXTURE_2D, attachment);
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0);
          if (textureNeedsGenerateMipmaps(attachment)) {
            generateMipmap(_gl.TEXTURE_2D);
          }
        }
        state.unbindTexture();
      } else {
        let glTextureType = _gl.TEXTURE_2D;
        if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
        }
        state.bindTexture(glTextureType, textureProperties.__webglTexture);
        setTextureParameters(glTextureType, texture);
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          for (let level = 0; level < texture.mipmaps.length; level++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
        }
        if (textureNeedsGenerateMipmaps(texture)) {
          generateMipmap(glTextureType);
        }
        state.unbindTexture();
      }
      if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function updateRenderTargetMipmap(renderTarget) {
      const textures = renderTarget.textures;
      for (let i = 0, il = textures.length; i < il; i++) {
        const texture = textures[i];
        if (textureNeedsGenerateMipmaps(texture)) {
          const targetType = getTargetType(renderTarget);
          const webglTexture = properties.get(texture).__webglTexture;
          state.bindTexture(targetType, webglTexture);
          generateMipmap(targetType);
          state.unbindTexture();
        }
      }
    }
    const invalidationArrayRead = [];
    const invalidationArrayDraw = [];
    function updateMultisampleRenderTarget(renderTarget) {
      if (renderTarget.samples > 0) {
        if (useMultisampledRTT(renderTarget) === false) {
          const textures = renderTarget.textures;
          const width = renderTarget.width;
          const height = renderTarget.height;
          let mask = _gl.COLOR_BUFFER_BIT;
          const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          const renderTargetProperties = properties.get(renderTarget);
          const isMultipleRenderTargets = textures.length > 1;
          if (isMultipleRenderTargets) {
            for (let i = 0; i < textures.length; i++) {
              state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
              _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
              state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
              _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
            }
          }
          state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          for (let i = 0; i < textures.length; i++) {
            if (renderTarget.resolveDepthBuffer) {
              if (renderTarget.depthBuffer)
                mask |= _gl.DEPTH_BUFFER_BIT;
              if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer)
                mask |= _gl.STENCIL_BUFFER_BIT;
            }
            if (isMultipleRenderTargets) {
              _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
              const webglTexture = properties.get(textures[i]).__webglTexture;
              _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
            }
            _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
            if (supportsInvalidateFramebuffer === true) {
              invalidationArrayRead.length = 0;
              invalidationArrayDraw.length = 0;
              invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i);
              if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {
                invalidationArrayRead.push(depthStyle);
                invalidationArrayDraw.push(depthStyle);
                _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);
              }
              _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead);
            }
          }
          state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
          state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
          if (isMultipleRenderTargets) {
            for (let i = 0; i < textures.length; i++) {
              state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
              _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
              const webglTexture = properties.get(textures[i]).__webglTexture;
              state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
              _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0);
            }
          }
          state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        } else {
          if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer) {
            const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
            _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
          }
        }
      }
    }
    function getRenderTargetSamples(renderTarget) {
      return Math.min(capabilities.maxSamples, renderTarget.samples);
    }
    function useMultisampledRTT(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      return renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
    }
    function updateVideoTexture(texture) {
      const frame = info.render.frame;
      if (_videoTextures.get(texture) !== frame) {
        _videoTextures.set(texture, frame);
        texture.update();
      }
    }
    function verifyColorSpace(texture, image) {
      const colorSpace = texture.colorSpace;
      const format = texture.format;
      const type = texture.type;
      if (texture.isCompressedTexture === true || texture.isVideoTexture === true)
        return image;
      if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
        if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
          if (format !== RGBAFormat || type !== UnsignedByteType) {
            console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
          }
        } else {
          console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace);
        }
      }
      return image;
    }
    function getDimensions(image) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement) {
        _imageDimensions.width = image.naturalWidth || image.width;
        _imageDimensions.height = image.naturalHeight || image.height;
      } else if (typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
        _imageDimensions.width = image.displayWidth;
        _imageDimensions.height = image.displayHeight;
      } else {
        _imageDimensions.width = image.width;
        _imageDimensions.height = image.height;
      }
      return _imageDimensions;
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.rebindTextures = rebindTextures;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.setupDepthRenderbuffer = setupDepthRenderbuffer;
    this.setupFrameBufferTexture = setupFrameBufferTexture;
    this.useMultisampledRTT = useMultisampledRTT;
  }
  function WebGLUtils(gl, extensions) {
    function convert(p, colorSpace = NoColorSpace) {
      let extension;
      const transfer = ColorManagement.getTransfer(colorSpace);
      if (p === UnsignedByteType)
        return gl.UNSIGNED_BYTE;
      if (p === UnsignedShort4444Type)
        return gl.UNSIGNED_SHORT_4_4_4_4;
      if (p === UnsignedShort5551Type)
        return gl.UNSIGNED_SHORT_5_5_5_1;
      if (p === UnsignedInt5999Type)
        return gl.UNSIGNED_INT_5_9_9_9_REV;
      if (p === ByteType)
        return gl.BYTE;
      if (p === ShortType)
        return gl.SHORT;
      if (p === UnsignedShortType)
        return gl.UNSIGNED_SHORT;
      if (p === IntType)
        return gl.INT;
      if (p === UnsignedIntType)
        return gl.UNSIGNED_INT;
      if (p === FloatType)
        return gl.FLOAT;
      if (p === HalfFloatType)
        return gl.HALF_FLOAT;
      if (p === AlphaFormat)
        return gl.ALPHA;
      if (p === RGBFormat)
        return gl.RGB;
      if (p === RGBAFormat)
        return gl.RGBA;
      if (p === LuminanceFormat)
        return gl.LUMINANCE;
      if (p === LuminanceAlphaFormat)
        return gl.LUMINANCE_ALPHA;
      if (p === DepthFormat)
        return gl.DEPTH_COMPONENT;
      if (p === DepthStencilFormat)
        return gl.DEPTH_STENCIL;
      if (p === RedFormat)
        return gl.RED;
      if (p === RedIntegerFormat)
        return gl.RED_INTEGER;
      if (p === RGFormat)
        return gl.RG;
      if (p === RGIntegerFormat)
        return gl.RG_INTEGER;
      if (p === RGBAIntegerFormat)
        return gl.RGBA_INTEGER;
      if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
        if (transfer === SRGBTransfer) {
          extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
          if (extension !== null) {
            if (p === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (p === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        } else {
          extension = extensions.get("WEBGL_compressed_texture_s3tc");
          if (extension !== null) {
            if (p === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        }
      }
      if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
        if (extension !== null) {
          if (p === RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p === RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p === RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p === RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else {
          return null;
        }
      }
      if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc");
        if (extension !== null) {
          if (p === RGB_ETC1_Format || p === RGB_ETC2_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
          if (p === RGBA_ETC2_EAC_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
        } else {
          return null;
        }
      }
      if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
        extension = extensions.get("WEBGL_compressed_texture_astc");
        if (extension !== null) {
          if (p === RGBA_ASTC_4x4_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (p === RGBA_ASTC_5x4_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (p === RGBA_ASTC_5x5_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (p === RGBA_ASTC_6x5_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (p === RGBA_ASTC_6x6_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (p === RGBA_ASTC_8x5_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (p === RGBA_ASTC_8x6_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (p === RGBA_ASTC_8x8_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (p === RGBA_ASTC_10x5_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (p === RGBA_ASTC_10x6_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (p === RGBA_ASTC_10x8_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (p === RGBA_ASTC_10x10_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (p === RGBA_ASTC_12x10_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (p === RGBA_ASTC_12x12_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
        } else {
          return null;
        }
      }
      if (p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format) {
        extension = extensions.get("EXT_texture_compression_bptc");
        if (extension !== null) {
          if (p === RGBA_BPTC_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          if (p === RGB_BPTC_SIGNED_Format)
            return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
          if (p === RGB_BPTC_UNSIGNED_Format)
            return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
        } else {
          return null;
        }
      }
      if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
        extension = extensions.get("EXT_texture_compression_rgtc");
        if (extension !== null) {
          if (p === RGBA_BPTC_Format)
            return extension.COMPRESSED_RED_RGTC1_EXT;
          if (p === SIGNED_RED_RGTC1_Format)
            return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
          if (p === RED_GREEN_RGTC2_Format)
            return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
          if (p === SIGNED_RED_GREEN_RGTC2_Format)
            return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
        } else {
          return null;
        }
      }
      if (p === UnsignedInt248Type)
        return gl.UNSIGNED_INT_24_8;
      return gl[p] !== void 0 ? gl[p] : null;
    }
    return { convert };
  }
  var _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;
  var _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
  var WebXRDepthSensing = class {
    constructor() {
      this.texture = null;
      this.mesh = null;
      this.depthNear = 0;
      this.depthFar = 0;
    }
    init(renderer, depthData, renderState) {
      if (this.texture === null) {
        const texture = new Texture();
        const texProps = renderer.properties.get(texture);
        texProps.__webglTexture = depthData.texture;
        if (depthData.depthNear !== renderState.depthNear || depthData.depthFar !== renderState.depthFar) {
          this.depthNear = depthData.depthNear;
          this.depthFar = depthData.depthFar;
        }
        this.texture = texture;
      }
    }
    getMesh(cameraXR) {
      if (this.texture !== null) {
        if (this.mesh === null) {
          const viewport = cameraXR.cameras[0].viewport;
          const material = new ShaderMaterial({
            vertexShader: _occlusion_vertex,
            fragmentShader: _occlusion_fragment,
            uniforms: {
              depthColor: { value: this.texture },
              depthWidth: { value: viewport.z },
              depthHeight: { value: viewport.w }
            }
          });
          this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
        }
      }
      return this.mesh;
    }
    reset() {
      this.texture = null;
      this.mesh = null;
    }
    getDepthTexture() {
      return this.texture;
    }
  };
  var WebXRManager = class extends EventDispatcher {
    constructor(renderer, gl) {
      super();
      const scope = this;
      let session = null;
      let framebufferScaleFactor = 1;
      let referenceSpace = null;
      let referenceSpaceType = "local-floor";
      let foveation = 1;
      let customReferenceSpace = null;
      let pose = null;
      let glBinding = null;
      let glProjLayer = null;
      let glBaseLayer = null;
      let xrFrame = null;
      const depthSensing = new WebXRDepthSensing();
      const attributes = gl.getContextAttributes();
      let initialRenderTarget = null;
      let newRenderTarget = null;
      const controllers = [];
      const controllerInputSources = [];
      const currentSize = new Vector2();
      let currentPixelRatio = null;
      const cameraL = new PerspectiveCamera();
      cameraL.viewport = new Vector4();
      const cameraR = new PerspectiveCamera();
      cameraR.viewport = new Vector4();
      const cameras = [cameraL, cameraR];
      const cameraXR = new ArrayCamera();
      let _currentDepthNear = null;
      let _currentDepthFar = null;
      this.cameraAutoUpdate = true;
      this.enabled = false;
      this.isPresenting = false;
      this.getController = function(index) {
        let controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index] = controller;
        }
        return controller.getTargetRaySpace();
      };
      this.getControllerGrip = function(index) {
        let controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index] = controller;
        }
        return controller.getGripSpace();
      };
      this.getHand = function(index) {
        let controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index] = controller;
        }
        return controller.getHandSpace();
      };
      function onSessionEvent(event) {
        const controllerIndex = controllerInputSources.indexOf(event.inputSource);
        if (controllerIndex === -1) {
          return;
        }
        const controller = controllers[controllerIndex];
        if (controller !== void 0) {
          controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
          controller.dispatchEvent({ type: event.type, data: event.inputSource });
        }
      }
      function onSessionEnd() {
        session.removeEventListener("select", onSessionEvent);
        session.removeEventListener("selectstart", onSessionEvent);
        session.removeEventListener("selectend", onSessionEvent);
        session.removeEventListener("squeeze", onSessionEvent);
        session.removeEventListener("squeezestart", onSessionEvent);
        session.removeEventListener("squeezeend", onSessionEvent);
        session.removeEventListener("end", onSessionEnd);
        session.removeEventListener("inputsourceschange", onInputSourcesChange);
        for (let i = 0; i < controllers.length; i++) {
          const inputSource = controllerInputSources[i];
          if (inputSource === null)
            continue;
          controllerInputSources[i] = null;
          controllers[i].disconnect(inputSource);
        }
        _currentDepthNear = null;
        _currentDepthFar = null;
        depthSensing.reset();
        renderer.setRenderTarget(initialRenderTarget);
        glBaseLayer = null;
        glProjLayer = null;
        glBinding = null;
        session = null;
        newRenderTarget = null;
        animation.stop();
        scope.isPresenting = false;
        renderer.setPixelRatio(currentPixelRatio);
        renderer.setSize(currentSize.width, currentSize.height, false);
        scope.dispatchEvent({ type: "sessionend" });
      }
      this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
        if (scope.isPresenting === true) {
          console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }
      };
      this.setReferenceSpaceType = function(value) {
        referenceSpaceType = value;
        if (scope.isPresenting === true) {
          console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }
      };
      this.getReferenceSpace = function() {
        return customReferenceSpace || referenceSpace;
      };
      this.setReferenceSpace = function(space) {
        customReferenceSpace = space;
      };
      this.getBaseLayer = function() {
        return glProjLayer !== null ? glProjLayer : glBaseLayer;
      };
      this.getBinding = function() {
        return glBinding;
      };
      this.getFrame = function() {
        return xrFrame;
      };
      this.getSession = function() {
        return session;
      };
      this.setSession = async function(value) {
        session = value;
        if (session !== null) {
          initialRenderTarget = renderer.getRenderTarget();
          session.addEventListener("select", onSessionEvent);
          session.addEventListener("selectstart", onSessionEvent);
          session.addEventListener("selectend", onSessionEvent);
          session.addEventListener("squeeze", onSessionEvent);
          session.addEventListener("squeezestart", onSessionEvent);
          session.addEventListener("squeezeend", onSessionEvent);
          session.addEventListener("end", onSessionEnd);
          session.addEventListener("inputsourceschange", onInputSourcesChange);
          if (attributes.xrCompatible !== true) {
            await gl.makeXRCompatible();
          }
          currentPixelRatio = renderer.getPixelRatio();
          renderer.getSize(currentSize);
          const useLayers = typeof XRWebGLBinding !== "undefined" && "createProjectionLayer" in XRWebGLBinding.prototype;
          if (!useLayers) {
            const layerInit = {
              antialias: attributes.antialias,
              alpha: true,
              depth: attributes.depth,
              stencil: attributes.stencil,
              framebufferScaleFactor
            };
            glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
            session.updateRenderState({ baseLayer: glBaseLayer });
            renderer.setPixelRatio(1);
            renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false);
            newRenderTarget = new WebGLRenderTarget(
              glBaseLayer.framebufferWidth,
              glBaseLayer.framebufferHeight,
              {
                format: RGBAFormat,
                type: UnsignedByteType,
                colorSpace: renderer.outputColorSpace,
                stencilBuffer: attributes.stencil
              }
            );
          } else {
            let depthFormat = null;
            let depthType = null;
            let glDepthFormat = null;
            if (attributes.depth) {
              glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
              depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
              depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
            }
            const projectionlayerInit = {
              colorFormat: gl.RGBA8,
              depthFormat: glDepthFormat,
              scaleFactor: framebufferScaleFactor
            };
            glBinding = new XRWebGLBinding(session, gl);
            glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
            session.updateRenderState({ layers: [glProjLayer] });
            renderer.setPixelRatio(1);
            renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, false);
            newRenderTarget = new WebGLRenderTarget(
              glProjLayer.textureWidth,
              glProjLayer.textureHeight,
              {
                format: RGBAFormat,
                type: UnsignedByteType,
                depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                stencilBuffer: attributes.stencil,
                colorSpace: renderer.outputColorSpace,
                samples: attributes.antialias ? 4 : 0,
                resolveDepthBuffer: glProjLayer.ignoreDepthValues === false
              }
            );
          }
          newRenderTarget.isXRRenderTarget = true;
          this.setFoveation(foveation);
          customReferenceSpace = null;
          referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
          animation.setContext(session);
          animation.start();
          scope.isPresenting = true;
          scope.dispatchEvent({ type: "sessionstart" });
        }
      };
      this.getEnvironmentBlendMode = function() {
        if (session !== null) {
          return session.environmentBlendMode;
        }
      };
      this.getDepthTexture = function() {
        return depthSensing.getDepthTexture();
      };
      function onInputSourcesChange(event) {
        for (let i = 0; i < event.removed.length; i++) {
          const inputSource = event.removed[i];
          const index = controllerInputSources.indexOf(inputSource);
          if (index >= 0) {
            controllerInputSources[index] = null;
            controllers[index].disconnect(inputSource);
          }
        }
        for (let i = 0; i < event.added.length; i++) {
          const inputSource = event.added[i];
          let controllerIndex = controllerInputSources.indexOf(inputSource);
          if (controllerIndex === -1) {
            for (let i2 = 0; i2 < controllers.length; i2++) {
              if (i2 >= controllerInputSources.length) {
                controllerInputSources.push(inputSource);
                controllerIndex = i2;
                break;
              } else if (controllerInputSources[i2] === null) {
                controllerInputSources[i2] = inputSource;
                controllerIndex = i2;
                break;
              }
            }
            if (controllerIndex === -1)
              break;
          }
          const controller = controllers[controllerIndex];
          if (controller) {
            controller.connect(inputSource);
          }
        }
      }
      const cameraLPos = new Vector3();
      const cameraRPos = new Vector3();
      function setProjectionFromUnion(camera, cameraL2, cameraR2) {
        cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
        cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
        const ipd = cameraLPos.distanceTo(cameraRPos);
        const projL = cameraL2.projectionMatrix.elements;
        const projR = cameraR2.projectionMatrix.elements;
        const near = projL[14] / (projL[10] - 1);
        const far = projL[14] / (projL[10] + 1);
        const topFov = (projL[9] + 1) / projL[5];
        const bottomFov = (projL[9] - 1) / projL[5];
        const leftFov = (projL[8] - 1) / projL[0];
        const rightFov = (projR[8] + 1) / projR[0];
        const left = near * leftFov;
        const right = near * rightFov;
        const zOffset = ipd / (-leftFov + rightFov);
        const xOffset = zOffset * -leftFov;
        cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
        camera.translateX(xOffset);
        camera.translateZ(zOffset);
        camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        if (projL[10] === -1) {
          camera.projectionMatrix.copy(cameraL2.projectionMatrix);
          camera.projectionMatrixInverse.copy(cameraL2.projectionMatrixInverse);
        } else {
          const near2 = near + zOffset;
          const far2 = far + zOffset;
          const left2 = left - xOffset;
          const right2 = right + (ipd - xOffset);
          const top2 = topFov * far / far2 * near2;
          const bottom2 = bottomFov * far / far2 * near2;
          camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
        }
      }
      function updateCamera(camera, parent) {
        if (parent === null) {
          camera.matrixWorld.copy(camera.matrix);
        } else {
          camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
        }
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      }
      this.updateCamera = function(camera) {
        if (session === null)
          return;
        let depthNear = camera.near;
        let depthFar = camera.far;
        if (depthSensing.texture !== null) {
          if (depthSensing.depthNear > 0)
            depthNear = depthSensing.depthNear;
          if (depthSensing.depthFar > 0)
            depthFar = depthSensing.depthFar;
        }
        cameraXR.near = cameraR.near = cameraL.near = depthNear;
        cameraXR.far = cameraR.far = cameraL.far = depthFar;
        if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
          session.updateRenderState({
            depthNear: cameraXR.near,
            depthFar: cameraXR.far
          });
          _currentDepthNear = cameraXR.near;
          _currentDepthFar = cameraXR.far;
        }
        cameraL.layers.mask = camera.layers.mask | 2;
        cameraR.layers.mask = camera.layers.mask | 4;
        cameraXR.layers.mask = cameraL.layers.mask | cameraR.layers.mask;
        const parent = camera.parent;
        const cameras2 = cameraXR.cameras;
        updateCamera(cameraXR, parent);
        for (let i = 0; i < cameras2.length; i++) {
          updateCamera(cameras2[i], parent);
        }
        if (cameras2.length === 2) {
          setProjectionFromUnion(cameraXR, cameraL, cameraR);
        } else {
          cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
        }
        updateUserCamera(camera, cameraXR, parent);
      };
      function updateUserCamera(camera, cameraXR2, parent) {
        if (parent === null) {
          camera.matrix.copy(cameraXR2.matrixWorld);
        } else {
          camera.matrix.copy(parent.matrixWorld);
          camera.matrix.invert();
          camera.matrix.multiply(cameraXR2.matrixWorld);
        }
        camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
        camera.updateMatrixWorld(true);
        camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
        camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
        if (camera.isPerspectiveCamera) {
          camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
          camera.zoom = 1;
        }
      }
      this.getCamera = function() {
        return cameraXR;
      };
      this.getFoveation = function() {
        if (glProjLayer === null && glBaseLayer === null) {
          return void 0;
        }
        return foveation;
      };
      this.setFoveation = function(value) {
        foveation = value;
        if (glProjLayer !== null) {
          glProjLayer.fixedFoveation = value;
        }
        if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
          glBaseLayer.fixedFoveation = value;
        }
      };
      this.hasDepthSensing = function() {
        return depthSensing.texture !== null;
      };
      this.getDepthSensingMesh = function() {
        return depthSensing.getMesh(cameraXR);
      };
      let onAnimationFrameCallback = null;
      function onAnimationFrame(time, frame) {
        pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
        xrFrame = frame;
        if (pose !== null) {
          const views = pose.views;
          if (glBaseLayer !== null) {
            renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
            renderer.setRenderTarget(newRenderTarget);
          }
          let cameraXRNeedsUpdate = false;
          if (views.length !== cameraXR.cameras.length) {
            cameraXR.cameras.length = 0;
            cameraXRNeedsUpdate = true;
          }
          for (let i = 0; i < views.length; i++) {
            const view = views[i];
            let viewport = null;
            if (glBaseLayer !== null) {
              viewport = glBaseLayer.getViewport(view);
            } else {
              const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
              viewport = glSubImage.viewport;
              if (i === 0) {
                renderer.setRenderTargetTextures(
                  newRenderTarget,
                  glSubImage.colorTexture,
                  glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
                );
                renderer.setRenderTarget(newRenderTarget);
              }
            }
            let camera = cameras[i];
            if (camera === void 0) {
              camera = new PerspectiveCamera();
              camera.layers.enable(i);
              camera.viewport = new Vector4();
              cameras[i] = camera;
            }
            camera.matrix.fromArray(view.transform.matrix);
            camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
            camera.projectionMatrix.fromArray(view.projectionMatrix);
            camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
            camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
            if (i === 0) {
              cameraXR.matrix.copy(camera.matrix);
              cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
            }
            if (cameraXRNeedsUpdate === true) {
              cameraXR.cameras.push(camera);
            }
          }
          const enabledFeatures = session.enabledFeatures;
          const gpuDepthSensingEnabled = enabledFeatures && enabledFeatures.includes("depth-sensing") && session.depthUsage == "gpu-optimized";
          if (gpuDepthSensingEnabled && glBinding) {
            const depthData = glBinding.getDepthInformation(views[0]);
            if (depthData && depthData.isValid && depthData.texture) {
              depthSensing.init(renderer, depthData, session.renderState);
            }
          }
        }
        for (let i = 0; i < controllers.length; i++) {
          const inputSource = controllerInputSources[i];
          const controller = controllers[i];
          if (inputSource !== null && controller !== void 0) {
            controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
          }
        }
        if (onAnimationFrameCallback)
          onAnimationFrameCallback(time, frame);
        if (frame.detectedPlanes) {
          scope.dispatchEvent({ type: "planesdetected", data: frame });
        }
        xrFrame = null;
      }
      const animation = new WebGLAnimation();
      animation.setAnimationLoop(onAnimationFrame);
      this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
      };
      this.dispose = function() {
      };
    }
  };
  var _e1 = /* @__PURE__ */ new Euler();
  var _m12 = /* @__PURE__ */ new Matrix4();
  function WebGLMaterials(renderer, properties) {
    function refreshTransformUniform(map, uniform) {
      if (map.matrixAutoUpdate === true) {
        map.updateMatrix();
      }
      uniform.value.copy(map.matrix);
    }
    function refreshFogUniforms(uniforms, fog) {
      fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
      if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshToonMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsToon(uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsPhong(uniforms, material);
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsStandard(uniforms, material);
        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsMatcap(uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDistance(uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(uniforms, material);
        if (material.isLineDashedMaterial) {
          refreshUniformsDash(uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(uniforms, material, pixelRatio, height);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(uniforms, material);
      } else if (material.isShadowMaterial) {
        uniforms.color.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
      } else if (material.isShaderMaterial) {
        material.uniformsNeedUpdate = false;
      }
    }
    function refreshUniformsCommon(uniforms, material) {
      uniforms.opacity.value = material.opacity;
      if (material.color) {
        uniforms.diffuse.value.copy(material.color);
      }
      if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      }
      if (material.map) {
        uniforms.map.value = material.map;
        refreshTransformUniform(material.map, uniforms.mapTransform);
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
        refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide) {
          uniforms.bumpScale.value *= -1;
        }
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide) {
          uniforms.normalScale.value.negate();
        }
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
        refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
      }
      if (material.specularMap) {
        uniforms.specularMap.value = material.specularMap;
        refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      const materialProperties = properties.get(material);
      const envMap = materialProperties.envMap;
      const envMapRotation = materialProperties.envMapRotation;
      if (envMap) {
        uniforms.envMap.value = envMap;
        _e1.copy(envMapRotation);
        _e1.x *= -1;
        _e1.y *= -1;
        _e1.z *= -1;
        if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {
          _e1.y *= -1;
          _e1.z *= -1;
        }
        uniforms.envMapRotation.value.setFromMatrix4(_m12.makeRotationFromEuler(_e1));
        uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.ior.value = material.ior;
        uniforms.refractionRatio.value = material.refractionRatio;
      }
      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
        refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
      }
      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
        refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
      }
    }
    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      if (material.map) {
        uniforms.map.value = material.map;
        refreshTransformUniform(material.map, uniforms.mapTransform);
      }
    }
    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * pixelRatio;
      uniforms.scale.value = height * 0.5;
      if (material.map) {
        uniforms.map.value = material.map;
        refreshTransformUniform(material.map, uniforms.uvTransform);
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
        refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
    }
    function refreshUniformsSprites(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.rotation.value = material.rotation;
      if (material.map) {
        uniforms.map.value = material.map;
        refreshTransformUniform(material.map, uniforms.mapTransform);
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
        refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
    }
    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value.copy(material.specular);
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    }
    function refreshUniformsToon(uniforms, material) {
      if (material.gradientMap) {
        uniforms.gradientMap.value = material.gradientMap;
      }
    }
    function refreshUniformsStandard(uniforms, material) {
      uniforms.metalness.value = material.metalness;
      if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
        refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
      }
      uniforms.roughness.value = material.roughness;
      if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
        refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
      }
      if (material.envMap) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
      }
    }
    function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
      uniforms.ior.value = material.ior;
      if (material.sheen > 0) {
        uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
        uniforms.sheenRoughness.value = material.sheenRoughness;
        if (material.sheenColorMap) {
          uniforms.sheenColorMap.value = material.sheenColorMap;
          refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
        }
        if (material.sheenRoughnessMap) {
          uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
          refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
        }
      }
      if (material.clearcoat > 0) {
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.clearcoatMap) {
          uniforms.clearcoatMap.value = material.clearcoatMap;
          refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
        }
        if (material.clearcoatRoughnessMap) {
          uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
          refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
        }
        if (material.clearcoatNormalMap) {
          uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
          refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
          uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
          if (material.side === BackSide) {
            uniforms.clearcoatNormalScale.value.negate();
          }
        }
      }
      if (material.dispersion > 0) {
        uniforms.dispersion.value = material.dispersion;
      }
      if (material.iridescence > 0) {
        uniforms.iridescence.value = material.iridescence;
        uniforms.iridescenceIOR.value = material.iridescenceIOR;
        uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
        uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
        if (material.iridescenceMap) {
          uniforms.iridescenceMap.value = material.iridescenceMap;
          refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
        }
        if (material.iridescenceThicknessMap) {
          uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
          refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
        }
      }
      if (material.transmission > 0) {
        uniforms.transmission.value = material.transmission;
        uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
        uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
        if (material.transmissionMap) {
          uniforms.transmissionMap.value = material.transmissionMap;
          refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
        }
        uniforms.thickness.value = material.thickness;
        if (material.thicknessMap) {
          uniforms.thicknessMap.value = material.thicknessMap;
          refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
        }
        uniforms.attenuationDistance.value = material.attenuationDistance;
        uniforms.attenuationColor.value.copy(material.attenuationColor);
      }
      if (material.anisotropy > 0) {
        uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
        if (material.anisotropyMap) {
          uniforms.anisotropyMap.value = material.anisotropyMap;
          refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
        }
      }
      uniforms.specularIntensity.value = material.specularIntensity;
      uniforms.specularColor.value.copy(material.specularColor);
      if (material.specularColorMap) {
        uniforms.specularColorMap.value = material.specularColorMap;
        refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
      }
      if (material.specularIntensityMap) {
        uniforms.specularIntensityMap.value = material.specularIntensityMap;
        refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
      }
    }
    function refreshUniformsMatcap(uniforms, material) {
      if (material.matcap) {
        uniforms.matcap.value = material.matcap;
      }
    }
    function refreshUniformsDistance(uniforms, material) {
      const light = properties.get(material).light;
      uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
      uniforms.nearDistance.value = light.shadow.camera.near;
      uniforms.farDistance.value = light.shadow.camera.far;
    }
    return {
      refreshFogUniforms,
      refreshMaterialUniforms
    };
  }
  function WebGLUniformsGroups(gl, info, capabilities, state) {
    let buffers = {};
    let updateList = {};
    let allocatedBindingPoints = [];
    const maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
    function bind(uniformsGroup, program) {
      const webglProgram = program.program;
      state.uniformBlockBinding(uniformsGroup, webglProgram);
    }
    function update(uniformsGroup, program) {
      let buffer = buffers[uniformsGroup.id];
      if (buffer === void 0) {
        prepareUniformsGroup(uniformsGroup);
        buffer = createBuffer(uniformsGroup);
        buffers[uniformsGroup.id] = buffer;
        uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
      }
      const webglProgram = program.program;
      state.updateUBOMapping(uniformsGroup, webglProgram);
      const frame = info.render.frame;
      if (updateList[uniformsGroup.id] !== frame) {
        updateBufferData(uniformsGroup);
        updateList[uniformsGroup.id] = frame;
      }
    }
    function createBuffer(uniformsGroup) {
      const bindingPointIndex = allocateBindingPointIndex();
      uniformsGroup.__bindingPointIndex = bindingPointIndex;
      const buffer = gl.createBuffer();
      const size = uniformsGroup.__size;
      const usage = uniformsGroup.usage;
      gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
      gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
      gl.bindBuffer(gl.UNIFORM_BUFFER, null);
      gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
      return buffer;
    }
    function allocateBindingPointIndex() {
      for (let i = 0; i < maxBindingPoints; i++) {
        if (allocatedBindingPoints.indexOf(i) === -1) {
          allocatedBindingPoints.push(i);
          return i;
        }
      }
      console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
      return 0;
    }
    function updateBufferData(uniformsGroup) {
      const buffer = buffers[uniformsGroup.id];
      const uniforms = uniformsGroup.uniforms;
      const cache = uniformsGroup.__cache;
      gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
      for (let i = 0, il = uniforms.length; i < il; i++) {
        const uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
        for (let j = 0, jl = uniformArray.length; j < jl; j++) {
          const uniform = uniformArray[j];
          if (hasUniformChanged(uniform, i, j, cache) === true) {
            const offset = uniform.__offset;
            const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
            let arrayOffset = 0;
            for (let k = 0; k < values.length; k++) {
              const value = values[k];
              const info2 = getUniformSize(value);
              if (typeof value === "number" || typeof value === "boolean") {
                uniform.__data[0] = value;
                gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
              } else if (value.isMatrix3) {
                uniform.__data[0] = value.elements[0];
                uniform.__data[1] = value.elements[1];
                uniform.__data[2] = value.elements[2];
                uniform.__data[3] = 0;
                uniform.__data[4] = value.elements[3];
                uniform.__data[5] = value.elements[4];
                uniform.__data[6] = value.elements[5];
                uniform.__data[7] = 0;
                uniform.__data[8] = value.elements[6];
                uniform.__data[9] = value.elements[7];
                uniform.__data[10] = value.elements[8];
                uniform.__data[11] = 0;
              } else {
                value.toArray(uniform.__data, arrayOffset);
                arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
              }
            }
            gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
          }
        }
      }
      gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    }
    function hasUniformChanged(uniform, index, indexArray, cache) {
      const value = uniform.value;
      const indexString = index + "_" + indexArray;
      if (cache[indexString] === void 0) {
        if (typeof value === "number" || typeof value === "boolean") {
          cache[indexString] = value;
        } else {
          cache[indexString] = value.clone();
        }
        return true;
      } else {
        const cachedObject = cache[indexString];
        if (typeof value === "number" || typeof value === "boolean") {
          if (cachedObject !== value) {
            cache[indexString] = value;
            return true;
          }
        } else {
          if (cachedObject.equals(value) === false) {
            cachedObject.copy(value);
            return true;
          }
        }
      }
      return false;
    }
    function prepareUniformsGroup(uniformsGroup) {
      const uniforms = uniformsGroup.uniforms;
      let offset = 0;
      const chunkSize = 16;
      for (let i = 0, l = uniforms.length; i < l; i++) {
        const uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
        for (let j = 0, jl = uniformArray.length; j < jl; j++) {
          const uniform = uniformArray[j];
          const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
          for (let k = 0, kl = values.length; k < kl; k++) {
            const value = values[k];
            const info2 = getUniformSize(value);
            const chunkOffset2 = offset % chunkSize;
            const chunkPadding = chunkOffset2 % info2.boundary;
            const chunkStart = chunkOffset2 + chunkPadding;
            offset += chunkPadding;
            if (chunkStart !== 0 && chunkSize - chunkStart < info2.storage) {
              offset += chunkSize - chunkStart;
            }
            uniform.__data = new Float32Array(info2.storage / Float32Array.BYTES_PER_ELEMENT);
            uniform.__offset = offset;
            offset += info2.storage;
          }
        }
      }
      const chunkOffset = offset % chunkSize;
      if (chunkOffset > 0)
        offset += chunkSize - chunkOffset;
      uniformsGroup.__size = offset;
      uniformsGroup.__cache = {};
      return this;
    }
    function getUniformSize(value) {
      const info2 = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      };
      if (typeof value === "number" || typeof value === "boolean") {
        info2.boundary = 4;
        info2.storage = 4;
      } else if (value.isVector2) {
        info2.boundary = 8;
        info2.storage = 8;
      } else if (value.isVector3 || value.isColor) {
        info2.boundary = 16;
        info2.storage = 12;
      } else if (value.isVector4) {
        info2.boundary = 16;
        info2.storage = 16;
      } else if (value.isMatrix3) {
        info2.boundary = 48;
        info2.storage = 48;
      } else if (value.isMatrix4) {
        info2.boundary = 64;
        info2.storage = 64;
      } else if (value.isTexture) {
        console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
      } else {
        console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
      }
      return info2;
    }
    function onUniformsGroupsDispose(event) {
      const uniformsGroup = event.target;
      uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
      const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
      allocatedBindingPoints.splice(index, 1);
      gl.deleteBuffer(buffers[uniformsGroup.id]);
      delete buffers[uniformsGroup.id];
      delete updateList[uniformsGroup.id];
    }
    function dispose() {
      for (const id in buffers) {
        gl.deleteBuffer(buffers[id]);
      }
      allocatedBindingPoints = [];
      buffers = {};
      updateList = {};
    }
    return {
      bind,
      update,
      dispose
    };
  }
  var WebGLRenderer = class {
    constructor(parameters = {}) {
      const {
        canvas = createCanvasElement(),
        context = null,
        depth = true,
        stencil = false,
        alpha = false,
        antialias = false,
        premultipliedAlpha = true,
        preserveDrawingBuffer = false,
        powerPreference = "default",
        failIfMajorPerformanceCaveat = false,
        reverseDepthBuffer = false
      } = parameters;
      this.isWebGLRenderer = true;
      let _alpha;
      if (context !== null) {
        if (typeof WebGLRenderingContext !== "undefined" && context instanceof WebGLRenderingContext) {
          throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
        }
        _alpha = context.getContextAttributes().alpha;
      } else {
        _alpha = alpha;
      }
      const uintClearColor = new Uint32Array(4);
      const intClearColor = new Int32Array(4);
      let currentRenderList = null;
      let currentRenderState = null;
      const renderListStack = [];
      const renderStateStack = [];
      this.domElement = canvas;
      this.debug = {
        /**
         * Enables error checking and reporting when shader programs are being compiled
         * @type {boolean}
         */
        checkShaderErrors: true,
        /**
         * Callback for custom error reporting.
         * @type {?Function}
         */
        onShaderError: null
      };
      this.autoClear = true;
      this.autoClearColor = true;
      this.autoClearDepth = true;
      this.autoClearStencil = true;
      this.sortObjects = true;
      this.clippingPlanes = [];
      this.localClippingEnabled = false;
      this._outputColorSpace = SRGBColorSpace;
      this.toneMapping = NoToneMapping;
      this.toneMappingExposure = 1;
      const _this = this;
      let _isContextLost = false;
      let _currentActiveCubeFace = 0;
      let _currentActiveMipmapLevel = 0;
      let _currentRenderTarget = null;
      let _currentMaterialId = -1;
      let _currentCamera = null;
      const _currentViewport = new Vector4();
      const _currentScissor = new Vector4();
      let _currentScissorTest = null;
      const _currentClearColor = new Color(0);
      let _currentClearAlpha = 0;
      let _width = canvas.width;
      let _height = canvas.height;
      let _pixelRatio = 1;
      let _opaqueSort = null;
      let _transparentSort = null;
      const _viewport = new Vector4(0, 0, _width, _height);
      const _scissor = new Vector4(0, 0, _width, _height);
      let _scissorTest = false;
      const _frustum = new Frustum();
      let _clippingEnabled = false;
      let _localClippingEnabled = false;
      this.transmissionResolutionScale = 1;
      const _currentProjectionMatrix = new Matrix4();
      const _projScreenMatrix = new Matrix4();
      const _vector3 = new Vector3();
      const _vector4 = new Vector4();
      const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
      let _renderBackground = false;
      function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
      }
      let _gl = context;
      function getContext(contextName, contextAttributes) {
        return canvas.getContext(contextName, contextAttributes);
      }
      try {
        const contextAttributes = {
          alpha: true,
          depth,
          stencil,
          antialias,
          premultipliedAlpha,
          preserveDrawingBuffer,
          powerPreference,
          failIfMajorPerformanceCaveat
        };
        if ("setAttribute" in canvas)
          canvas.setAttribute("data-engine", `three.js r${REVISION}`);
        canvas.addEventListener("webglcontextlost", onContextLost, false);
        canvas.addEventListener("webglcontextrestored", onContextRestore, false);
        canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
        if (_gl === null) {
          const contextName = "webgl2";
          _gl = getContext(contextName, contextAttributes);
          if (_gl === null) {
            if (getContext(contextName)) {
              throw new Error("Error creating WebGL context with your selected attributes.");
            } else {
              throw new Error("Error creating WebGL context.");
            }
          }
        }
      } catch (error) {
        console.error("THREE.WebGLRenderer: " + error.message);
        throw error;
      }
      let extensions, capabilities, state, info;
      let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
      let programCache, materials, renderLists, renderStates, clipping, shadowMap;
      let background, morphtargets, bufferRenderer, indexedBufferRenderer;
      let utils, bindingStates, uniformsGroups;
      function initGLContext() {
        extensions = new WebGLExtensions(_gl);
        extensions.init();
        utils = new WebGLUtils(_gl, extensions);
        capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);
        state = new WebGLState(_gl, extensions);
        if (capabilities.reverseDepthBuffer && reverseDepthBuffer) {
          state.buffers.depth.setReversed(true);
        }
        info = new WebGLInfo(_gl);
        properties = new WebGLProperties();
        textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
        cubemaps = new WebGLCubeMaps(_this);
        cubeuvmaps = new WebGLCubeUVMaps(_this);
        attributes = new WebGLAttributes(_gl);
        bindingStates = new WebGLBindingStates(_gl, attributes);
        geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
        objects = new WebGLObjects(_gl, geometries, attributes, info);
        morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
        clipping = new WebGLClipping(properties);
        programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
        materials = new WebGLMaterials(_this, properties);
        renderLists = new WebGLRenderLists();
        renderStates = new WebGLRenderStates(extensions);
        background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
        shadowMap = new WebGLShadowMap(_this, objects, capabilities);
        uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
        bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
        indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.shadowMap = shadowMap;
        _this.state = state;
        _this.info = info;
      }
      initGLContext();
      const xr = new WebXRManager(_this, _gl);
      this.xr = xr;
      this.getContext = function() {
        return _gl;
      };
      this.getContextAttributes = function() {
        return _gl.getContextAttributes();
      };
      this.forceContextLoss = function() {
        const extension = extensions.get("WEBGL_lose_context");
        if (extension)
          extension.loseContext();
      };
      this.forceContextRestore = function() {
        const extension = extensions.get("WEBGL_lose_context");
        if (extension)
          extension.restoreContext();
      };
      this.getPixelRatio = function() {
        return _pixelRatio;
      };
      this.setPixelRatio = function(value) {
        if (value === void 0)
          return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
      };
      this.getSize = function(target) {
        return target.set(_width, _height);
      };
      this.setSize = function(width, height, updateStyle = true) {
        if (xr.isPresenting) {
          console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
          return;
        }
        _width = width;
        _height = height;
        canvas.width = Math.floor(width * _pixelRatio);
        canvas.height = Math.floor(height * _pixelRatio);
        if (updateStyle === true) {
          canvas.style.width = width + "px";
          canvas.style.height = height + "px";
        }
        this.setViewport(0, 0, width, height);
      };
      this.getDrawingBufferSize = function(target) {
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
      };
      this.setDrawingBufferSize = function(width, height, pixelRatio) {
        _width = width;
        _height = height;
        _pixelRatio = pixelRatio;
        canvas.width = Math.floor(width * pixelRatio);
        canvas.height = Math.floor(height * pixelRatio);
        this.setViewport(0, 0, width, height);
      };
      this.getCurrentViewport = function(target) {
        return target.copy(_currentViewport);
      };
      this.getViewport = function(target) {
        return target.copy(_viewport);
      };
      this.setViewport = function(x, y, width, height) {
        if (x.isVector4) {
          _viewport.set(x.x, x.y, x.z, x.w);
        } else {
          _viewport.set(x, y, width, height);
        }
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round());
      };
      this.getScissor = function(target) {
        return target.copy(_scissor);
      };
      this.setScissor = function(x, y, width, height) {
        if (x.isVector4) {
          _scissor.set(x.x, x.y, x.z, x.w);
        } else {
          _scissor.set(x, y, width, height);
        }
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());
      };
      this.getScissorTest = function() {
        return _scissorTest;
      };
      this.setScissorTest = function(boolean) {
        state.setScissorTest(_scissorTest = boolean);
      };
      this.setOpaqueSort = function(method) {
        _opaqueSort = method;
      };
      this.setTransparentSort = function(method) {
        _transparentSort = method;
      };
      this.getClearColor = function(target) {
        return target.copy(background.getClearColor());
      };
      this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
      };
      this.getClearAlpha = function() {
        return background.getClearAlpha();
      };
      this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
      };
      this.clear = function(color = true, depth2 = true, stencil2 = true) {
        let bits = 0;
        if (color) {
          let isIntegerFormat = false;
          if (_currentRenderTarget !== null) {
            const targetFormat = _currentRenderTarget.texture.format;
            isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
          }
          if (isIntegerFormat) {
            const targetType = _currentRenderTarget.texture.type;
            const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
            const clearColor = background.getClearColor();
            const a = background.getClearAlpha();
            const r = clearColor.r;
            const g = clearColor.g;
            const b = clearColor.b;
            if (isUnsignedType) {
              uintClearColor[0] = r;
              uintClearColor[1] = g;
              uintClearColor[2] = b;
              uintClearColor[3] = a;
              _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
            } else {
              intClearColor[0] = r;
              intClearColor[1] = g;
              intClearColor[2] = b;
              intClearColor[3] = a;
              _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
            }
          } else {
            bits |= _gl.COLOR_BUFFER_BIT;
          }
        }
        if (depth2) {
          bits |= _gl.DEPTH_BUFFER_BIT;
        }
        if (stencil2) {
          bits |= _gl.STENCIL_BUFFER_BIT;
          this.state.buffers.stencil.setMask(4294967295);
        }
        _gl.clear(bits);
      };
      this.clearColor = function() {
        this.clear(true, false, false);
      };
      this.clearDepth = function() {
        this.clear(false, true, false);
      };
      this.clearStencil = function() {
        this.clear(false, false, true);
      };
      this.dispose = function() {
        canvas.removeEventListener("webglcontextlost", onContextLost, false);
        canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
        canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
        background.dispose();
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        cubemaps.dispose();
        cubeuvmaps.dispose();
        objects.dispose();
        bindingStates.dispose();
        uniformsGroups.dispose();
        programCache.dispose();
        xr.dispose();
        xr.removeEventListener("sessionstart", onXRSessionStart);
        xr.removeEventListener("sessionend", onXRSessionEnd);
        animation.stop();
      };
      function onContextLost(event) {
        event.preventDefault();
        console.log("THREE.WebGLRenderer: Context Lost.");
        _isContextLost = true;
      }
      function onContextRestore() {
        console.log("THREE.WebGLRenderer: Context Restored.");
        _isContextLost = false;
        const infoAutoReset = info.autoReset;
        const shadowMapEnabled = shadowMap.enabled;
        const shadowMapAutoUpdate = shadowMap.autoUpdate;
        const shadowMapNeedsUpdate = shadowMap.needsUpdate;
        const shadowMapType = shadowMap.type;
        initGLContext();
        info.autoReset = infoAutoReset;
        shadowMap.enabled = shadowMapEnabled;
        shadowMap.autoUpdate = shadowMapAutoUpdate;
        shadowMap.needsUpdate = shadowMapNeedsUpdate;
        shadowMap.type = shadowMapType;
      }
      function onContextCreationError(event) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
      }
      function onMaterialDispose(event) {
        const material = event.target;
        material.removeEventListener("dispose", onMaterialDispose);
        deallocateMaterial(material);
      }
      function deallocateMaterial(material) {
        releaseMaterialProgramReferences(material);
        properties.remove(material);
      }
      function releaseMaterialProgramReferences(material) {
        const programs = properties.get(material).programs;
        if (programs !== void 0) {
          programs.forEach(function(program) {
            programCache.releaseProgram(program);
          });
          if (material.isShaderMaterial) {
            programCache.releaseShaderCache(material);
          }
        }
      }
      this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
        if (scene === null)
          scene = _emptyScene;
        const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        const program = setProgram(camera, scene, geometry, material, object);
        state.setMaterial(material, frontFaceCW);
        let index = geometry.index;
        let rangeFactor = 1;
        if (material.wireframe === true) {
          index = geometries.getWireframeAttribute(geometry);
          if (index === void 0)
            return;
          rangeFactor = 2;
        }
        const drawRange = geometry.drawRange;
        const position = geometry.attributes.position;
        let drawStart = drawRange.start * rangeFactor;
        let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
        if (group !== null) {
          drawStart = Math.max(drawStart, group.start * rangeFactor);
          drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
        }
        if (index !== null) {
          drawStart = Math.max(drawStart, 0);
          drawEnd = Math.min(drawEnd, index.count);
        } else if (position !== void 0 && position !== null) {
          drawStart = Math.max(drawStart, 0);
          drawEnd = Math.min(drawEnd, position.count);
        }
        const drawCount = drawEnd - drawStart;
        if (drawCount < 0 || drawCount === Infinity)
          return;
        bindingStates.setup(object, material, program, geometry, index);
        let attribute;
        let renderer = bufferRenderer;
        if (index !== null) {
          attribute = attributes.get(index);
          renderer = indexedBufferRenderer;
          renderer.setIndex(attribute);
        }
        if (object.isMesh) {
          if (material.wireframe === true) {
            state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
            renderer.setMode(_gl.LINES);
          } else {
            renderer.setMode(_gl.TRIANGLES);
          }
        } else if (object.isLine) {
          let lineWidth = material.linewidth;
          if (lineWidth === void 0)
            lineWidth = 1;
          state.setLineWidth(lineWidth * getTargetPixelRatio());
          if (object.isLineSegments) {
            renderer.setMode(_gl.LINES);
          } else if (object.isLineLoop) {
            renderer.setMode(_gl.LINE_LOOP);
          } else {
            renderer.setMode(_gl.LINE_STRIP);
          }
        } else if (object.isPoints) {
          renderer.setMode(_gl.POINTS);
        } else if (object.isSprite) {
          renderer.setMode(_gl.TRIANGLES);
        }
        if (object.isBatchedMesh) {
          if (object._multiDrawInstances !== null) {
            renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
          } else {
            if (!extensions.get("WEBGL_multi_draw")) {
              const starts = object._multiDrawStarts;
              const counts = object._multiDrawCounts;
              const drawCount2 = object._multiDrawCount;
              const bytesPerElement = index ? attributes.get(index).bytesPerElement : 1;
              const uniforms = properties.get(material).currentProgram.getUniforms();
              for (let i = 0; i < drawCount2; i++) {
                uniforms.setValue(_gl, "_gl_DrawID", i);
                renderer.render(starts[i] / bytesPerElement, counts[i]);
              }
            } else {
              renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
            }
          }
        } else if (object.isInstancedMesh) {
          renderer.renderInstances(drawStart, drawCount, object.count);
        } else if (geometry.isInstancedBufferGeometry) {
          const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
          const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
          renderer.renderInstances(drawStart, drawCount, instanceCount);
        } else {
          renderer.render(drawStart, drawCount);
        }
      };
      function prepareMaterial(material, scene, object) {
        if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
          material.side = BackSide;
          material.needsUpdate = true;
          getProgram(material, scene, object);
          material.side = FrontSide;
          material.needsUpdate = true;
          getProgram(material, scene, object);
          material.side = DoubleSide;
        } else {
          getProgram(material, scene, object);
        }
      }
      this.compile = function(scene, camera, targetScene = null) {
        if (targetScene === null)
          targetScene = scene;
        currentRenderState = renderStates.get(targetScene);
        currentRenderState.init(camera);
        renderStateStack.push(currentRenderState);
        targetScene.traverseVisible(function(object) {
          if (object.isLight && object.layers.test(camera.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
        if (scene !== targetScene) {
          scene.traverseVisible(function(object) {
            if (object.isLight && object.layers.test(camera.layers)) {
              currentRenderState.pushLight(object);
              if (object.castShadow) {
                currentRenderState.pushShadow(object);
              }
            }
          });
        }
        currentRenderState.setupLights();
        const materials2 = /* @__PURE__ */ new Set();
        scene.traverse(function(object) {
          if (!(object.isMesh || object.isPoints || object.isLine || object.isSprite)) {
            return;
          }
          const material = object.material;
          if (material) {
            if (Array.isArray(material)) {
              for (let i = 0; i < material.length; i++) {
                const material2 = material[i];
                prepareMaterial(material2, targetScene, object);
                materials2.add(material2);
              }
            } else {
              prepareMaterial(material, targetScene, object);
              materials2.add(material);
            }
          }
        });
        renderStateStack.pop();
        currentRenderState = null;
        return materials2;
      };
      this.compileAsync = function(scene, camera, targetScene = null) {
        const materials2 = this.compile(scene, camera, targetScene);
        return new Promise((resolve) => {
          function checkMaterialsReady() {
            materials2.forEach(function(material) {
              const materialProperties = properties.get(material);
              const program = materialProperties.currentProgram;
              if (program.isReady()) {
                materials2.delete(material);
              }
            });
            if (materials2.size === 0) {
              resolve(scene);
              return;
            }
            setTimeout(checkMaterialsReady, 10);
          }
          if (extensions.get("KHR_parallel_shader_compile") !== null) {
            checkMaterialsReady();
          } else {
            setTimeout(checkMaterialsReady, 10);
          }
        });
      };
      let onAnimationFrameCallback = null;
      function onAnimationFrame(time) {
        if (onAnimationFrameCallback)
          onAnimationFrameCallback(time);
      }
      function onXRSessionStart() {
        animation.stop();
      }
      function onXRSessionEnd() {
        animation.start();
      }
      const animation = new WebGLAnimation();
      animation.setAnimationLoop(onAnimationFrame);
      if (typeof self !== "undefined")
        animation.setContext(self);
      this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        xr.setAnimationLoop(callback);
        callback === null ? animation.stop() : animation.start();
      };
      xr.addEventListener("sessionstart", onXRSessionStart);
      xr.addEventListener("sessionend", onXRSessionEnd);
      this.render = function(scene, camera) {
        if (camera !== void 0 && camera.isCamera !== true) {
          console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          return;
        }
        if (_isContextLost === true)
          return;
        if (scene.matrixWorldAutoUpdate === true)
          scene.updateMatrixWorld();
        if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
          camera.updateMatrixWorld();
        if (xr.enabled === true && xr.isPresenting === true) {
          if (xr.cameraAutoUpdate === true)
            xr.updateCamera(camera);
          camera = xr.getCamera();
        }
        if (scene.isScene === true)
          scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
        currentRenderState = renderStates.get(scene, renderStateStack.length);
        currentRenderState.init(camera);
        renderStateStack.push(currentRenderState);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
        currentRenderList = renderLists.get(scene, renderListStack.length);
        currentRenderList.init();
        renderListStack.push(currentRenderList);
        if (xr.enabled === true && xr.isPresenting === true) {
          const depthSensingMesh = _this.xr.getDepthSensingMesh();
          if (depthSensingMesh !== null) {
            projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects);
          }
        }
        projectObject(scene, camera, 0, _this.sortObjects);
        currentRenderList.finish();
        if (_this.sortObjects === true) {
          currentRenderList.sort(_opaqueSort, _transparentSort);
        }
        _renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
        if (_renderBackground) {
          background.addToRenderList(currentRenderList, scene);
        }
        this.info.render.frame++;
        if (_clippingEnabled === true)
          clipping.beginShadows();
        const shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        if (_clippingEnabled === true)
          clipping.endShadows();
        if (this.info.autoReset === true)
          this.info.reset();
        const opaqueObjects = currentRenderList.opaque;
        const transmissiveObjects = currentRenderList.transmissive;
        currentRenderState.setupLights();
        if (camera.isArrayCamera) {
          const cameras = camera.cameras;
          if (transmissiveObjects.length > 0) {
            for (let i = 0, l = cameras.length; i < l; i++) {
              const camera2 = cameras[i];
              renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);
            }
          }
          if (_renderBackground)
            background.render(scene);
          for (let i = 0, l = cameras.length; i < l; i++) {
            const camera2 = cameras[i];
            renderScene(currentRenderList, scene, camera2, camera2.viewport);
          }
        } else {
          if (transmissiveObjects.length > 0)
            renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
          if (_renderBackground)
            background.render(scene);
          renderScene(currentRenderList, scene, camera);
        }
        if (_currentRenderTarget !== null && _currentActiveMipmapLevel === 0) {
          textures.updateMultisampleRenderTarget(_currentRenderTarget);
          textures.updateRenderTargetMipmap(_currentRenderTarget);
        }
        if (scene.isScene === true)
          scene.onAfterRender(_this, scene, camera);
        bindingStates.resetDefaultState();
        _currentMaterialId = -1;
        _currentCamera = null;
        renderStateStack.pop();
        if (renderStateStack.length > 0) {
          currentRenderState = renderStateStack[renderStateStack.length - 1];
          if (_clippingEnabled === true)
            clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera);
        } else {
          currentRenderState = null;
        }
        renderListStack.pop();
        if (renderListStack.length > 0) {
          currentRenderList = renderListStack[renderListStack.length - 1];
        } else {
          currentRenderList = null;
        }
      };
      function projectObject(object, camera, groupOrder, sortObjects) {
        if (object.visible === false)
          return;
        const visible = object.layers.test(camera.layers);
        if (visible) {
          if (object.isGroup) {
            groupOrder = object.renderOrder;
          } else if (object.isLOD) {
            if (object.autoUpdate === true)
              object.update(camera);
          } else if (object.isLight) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          } else if (object.isSprite) {
            if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
              if (sortObjects) {
                _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
              }
              const geometry = objects.update(object);
              const material = object.material;
              if (material.visible) {
                currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
              }
            }
          } else if (object.isMesh || object.isLine || object.isPoints) {
            if (!object.frustumCulled || _frustum.intersectsObject(object)) {
              const geometry = objects.update(object);
              const material = object.material;
              if (sortObjects) {
                if (object.boundingSphere !== void 0) {
                  if (object.boundingSphere === null)
                    object.computeBoundingSphere();
                  _vector4.copy(object.boundingSphere.center);
                } else {
                  if (geometry.boundingSphere === null)
                    geometry.computeBoundingSphere();
                  _vector4.copy(geometry.boundingSphere.center);
                }
                _vector4.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);
              }
              if (Array.isArray(material)) {
                const groups = geometry.groups;
                for (let i = 0, l = groups.length; i < l; i++) {
                  const group = groups[i];
                  const groupMaterial = material[group.materialIndex];
                  if (groupMaterial && groupMaterial.visible) {
                    currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group);
                  }
                }
              } else if (material.visible) {
                currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
              }
            }
          }
        }
        const children = object.children;
        for (let i = 0, l = children.length; i < l; i++) {
          projectObject(children[i], camera, groupOrder, sortObjects);
        }
      }
      function renderScene(currentRenderList2, scene, camera, viewport) {
        const opaqueObjects = currentRenderList2.opaque;
        const transmissiveObjects = currentRenderList2.transmissive;
        const transparentObjects = currentRenderList2.transparent;
        currentRenderState.setupLightsView(camera);
        if (_clippingEnabled === true)
          clipping.setGlobalState(_this.clippingPlanes, camera);
        if (viewport)
          state.viewport(_currentViewport.copy(viewport));
        if (opaqueObjects.length > 0)
          renderObjects(opaqueObjects, scene, camera);
        if (transmissiveObjects.length > 0)
          renderObjects(transmissiveObjects, scene, camera);
        if (transparentObjects.length > 0)
          renderObjects(transparentObjects, scene, camera);
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
      }
      function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        if (overrideMaterial !== null) {
          return;
        }
        if (currentRenderState.state.transmissionRenderTarget[camera.id] === void 0) {
          currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {
            generateMipmaps: true,
            type: extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType,
            minFilter: LinearMipmapLinearFilter,
            samples: 4,
            stencilBuffer: stencil,
            resolveDepthBuffer: false,
            resolveStencilBuffer: false,
            colorSpace: ColorManagement.workingColorSpace
          });
        }
        const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];
        const activeViewport = camera.viewport || _currentViewport;
        transmissionRenderTarget.setSize(activeViewport.z * _this.transmissionResolutionScale, activeViewport.w * _this.transmissionResolutionScale);
        const currentRenderTarget = _this.getRenderTarget();
        _this.setRenderTarget(transmissionRenderTarget);
        _this.getClearColor(_currentClearColor);
        _currentClearAlpha = _this.getClearAlpha();
        if (_currentClearAlpha < 1)
          _this.setClearColor(16777215, 0.5);
        _this.clear();
        if (_renderBackground)
          background.render(scene);
        const currentToneMapping = _this.toneMapping;
        _this.toneMapping = NoToneMapping;
        const currentCameraViewport = camera.viewport;
        if (camera.viewport !== void 0)
          camera.viewport = void 0;
        currentRenderState.setupLightsView(camera);
        if (_clippingEnabled === true)
          clipping.setGlobalState(_this.clippingPlanes, camera);
        renderObjects(opaqueObjects, scene, camera);
        textures.updateMultisampleRenderTarget(transmissionRenderTarget);
        textures.updateRenderTargetMipmap(transmissionRenderTarget);
        if (extensions.has("WEBGL_multisampled_render_to_texture") === false) {
          let renderTargetNeedsUpdate = false;
          for (let i = 0, l = transmissiveObjects.length; i < l; i++) {
            const renderItem = transmissiveObjects[i];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = renderItem.material;
            const group = renderItem.group;
            if (material.side === DoubleSide && object.layers.test(camera.layers)) {
              const currentSide = material.side;
              material.side = BackSide;
              material.needsUpdate = true;
              renderObject(object, scene, camera, geometry, material, group);
              material.side = currentSide;
              material.needsUpdate = true;
              renderTargetNeedsUpdate = true;
            }
          }
          if (renderTargetNeedsUpdate === true) {
            textures.updateMultisampleRenderTarget(transmissionRenderTarget);
            textures.updateRenderTargetMipmap(transmissionRenderTarget);
          }
        }
        _this.setRenderTarget(currentRenderTarget);
        _this.setClearColor(_currentClearColor, _currentClearAlpha);
        if (currentCameraViewport !== void 0)
          camera.viewport = currentCameraViewport;
        _this.toneMapping = currentToneMapping;
      }
      function renderObjects(renderList, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        for (let i = 0, l = renderList.length; i < l; i++) {
          const renderItem = renderList[i];
          const object = renderItem.object;
          const geometry = renderItem.geometry;
          const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
          const group = renderItem.group;
          if (object.layers.test(camera.layers)) {
            renderObject(object, scene, camera, geometry, material, group);
          }
        }
      }
      function renderObject(object, scene, camera, geometry, material, group) {
        object.onBeforeRender(_this, scene, camera, geometry, material, group);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        material.onBeforeRender(_this, scene, camera, geometry, object, group);
        if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
          material.side = BackSide;
          material.needsUpdate = true;
          _this.renderBufferDirect(camera, scene, geometry, material, object, group);
          material.side = FrontSide;
          material.needsUpdate = true;
          _this.renderBufferDirect(camera, scene, geometry, material, object, group);
          material.side = DoubleSide;
        } else {
          _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        }
        object.onAfterRender(_this, scene, camera, geometry, material, group);
      }
      function getProgram(material, scene, object) {
        if (scene.isScene !== true)
          scene = _emptyScene;
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        const shadowsArray = currentRenderState.state.shadowsArray;
        const lightsStateVersion = lights.state.version;
        const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
        const programCacheKey = programCache.getProgramCacheKey(parameters2);
        let programs = materialProperties.programs;
        materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
        materialProperties.fog = scene.fog;
        materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
        materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
        if (programs === void 0) {
          material.addEventListener("dispose", onMaterialDispose);
          programs = /* @__PURE__ */ new Map();
          materialProperties.programs = programs;
        }
        let program = programs.get(programCacheKey);
        if (program !== void 0) {
          if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
            updateCommonMaterialProperties(material, parameters2);
            return program;
          }
        } else {
          parameters2.uniforms = programCache.getUniforms(material);
          material.onBeforeCompile(parameters2, _this);
          program = programCache.acquireProgram(parameters2, programCacheKey);
          programs.set(programCacheKey, program);
          materialProperties.uniforms = parameters2.uniforms;
        }
        const uniforms = materialProperties.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
          uniforms.clippingPlanes = clipping.uniform;
        }
        updateCommonMaterialProperties(material, parameters2);
        materialProperties.needsLights = materialNeedsLights(material);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
          uniforms.ambientLightColor.value = lights.state.ambient;
          uniforms.lightProbe.value = lights.state.probe;
          uniforms.directionalLights.value = lights.state.directional;
          uniforms.directionalLightShadows.value = lights.state.directionalShadow;
          uniforms.spotLights.value = lights.state.spot;
          uniforms.spotLightShadows.value = lights.state.spotShadow;
          uniforms.rectAreaLights.value = lights.state.rectArea;
          uniforms.ltc_1.value = lights.state.rectAreaLTC1;
          uniforms.ltc_2.value = lights.state.rectAreaLTC2;
          uniforms.pointLights.value = lights.state.point;
          uniforms.pointLightShadows.value = lights.state.pointShadow;
          uniforms.hemisphereLights.value = lights.state.hemi;
          uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
          uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
          uniforms.spotShadowMap.value = lights.state.spotShadowMap;
          uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
          uniforms.spotLightMap.value = lights.state.spotLightMap;
          uniforms.pointShadowMap.value = lights.state.pointShadowMap;
          uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        }
        materialProperties.currentProgram = program;
        materialProperties.uniformsList = null;
        return program;
      }
      function getUniformList(materialProperties) {
        if (materialProperties.uniformsList === null) {
          const progUniforms = materialProperties.currentProgram.getUniforms();
          materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
        }
        return materialProperties.uniformsList;
      }
      function updateCommonMaterialProperties(material, parameters2) {
        const materialProperties = properties.get(material);
        materialProperties.outputColorSpace = parameters2.outputColorSpace;
        materialProperties.batching = parameters2.batching;
        materialProperties.batchingColor = parameters2.batchingColor;
        materialProperties.instancing = parameters2.instancing;
        materialProperties.instancingColor = parameters2.instancingColor;
        materialProperties.instancingMorph = parameters2.instancingMorph;
        materialProperties.skinning = parameters2.skinning;
        materialProperties.morphTargets = parameters2.morphTargets;
        materialProperties.morphNormals = parameters2.morphNormals;
        materialProperties.morphColors = parameters2.morphColors;
        materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
        materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
        materialProperties.numIntersection = parameters2.numClipIntersection;
        materialProperties.vertexAlphas = parameters2.vertexAlphas;
        materialProperties.vertexTangents = parameters2.vertexTangents;
        materialProperties.toneMapping = parameters2.toneMapping;
      }
      function setProgram(camera, scene, geometry, material, object) {
        if (scene.isScene !== true)
          scene = _emptyScene;
        textures.resetTextureUnits();
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
        const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
        const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
        const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
        const morphTargets = !!geometry.morphAttributes.position;
        const morphNormals = !!geometry.morphAttributes.normal;
        const morphColors = !!geometry.morphAttributes.color;
        let toneMapping = NoToneMapping;
        if (material.toneMapped) {
          if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
            toneMapping = _this.toneMapping;
          }
        }
        const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
        const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        if (_clippingEnabled === true) {
          if (_localClippingEnabled === true || camera !== _currentCamera) {
            const useCache = camera === _currentCamera && material.id === _currentMaterialId;
            clipping.setState(material, camera, useCache);
          }
        }
        let needsProgramChange = false;
        if (material.version === materialProperties.__version) {
          if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
            needsProgramChange = true;
          } else if (materialProperties.outputColorSpace !== colorSpace) {
            needsProgramChange = true;
          } else if (object.isBatchedMesh && materialProperties.batching === false) {
            needsProgramChange = true;
          } else if (!object.isBatchedMesh && materialProperties.batching === true) {
            needsProgramChange = true;
          } else if (object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null) {
            needsProgramChange = true;
          } else if (object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null) {
            needsProgramChange = true;
          } else if (object.isInstancedMesh && materialProperties.instancing === false) {
            needsProgramChange = true;
          } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
            needsProgramChange = true;
          } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
            needsProgramChange = true;
          } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
            needsProgramChange = true;
          } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
            needsProgramChange = true;
          } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
            needsProgramChange = true;
          } else if (object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null) {
            needsProgramChange = true;
          } else if (object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null) {
            needsProgramChange = true;
          } else if (materialProperties.envMap !== envMap) {
            needsProgramChange = true;
          } else if (material.fog === true && materialProperties.fog !== fog) {
            needsProgramChange = true;
          } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
            needsProgramChange = true;
          } else if (materialProperties.vertexAlphas !== vertexAlphas) {
            needsProgramChange = true;
          } else if (materialProperties.vertexTangents !== vertexTangents) {
            needsProgramChange = true;
          } else if (materialProperties.morphTargets !== morphTargets) {
            needsProgramChange = true;
          } else if (materialProperties.morphNormals !== morphNormals) {
            needsProgramChange = true;
          } else if (materialProperties.morphColors !== morphColors) {
            needsProgramChange = true;
          } else if (materialProperties.toneMapping !== toneMapping) {
            needsProgramChange = true;
          } else if (materialProperties.morphTargetsCount !== morphTargetsCount) {
            needsProgramChange = true;
          }
        } else {
          needsProgramChange = true;
          materialProperties.__version = material.version;
        }
        let program = materialProperties.currentProgram;
        if (needsProgramChange === true) {
          program = getProgram(material, scene, object);
        }
        let refreshProgram = false;
        let refreshMaterial = false;
        let refreshLights = false;
        const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
        if (state.useProgram(program.program)) {
          refreshProgram = true;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
          _currentMaterialId = material.id;
          refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
          const reverseDepthBuffer2 = state.buffers.depth.getReversed();
          if (reverseDepthBuffer2) {
            _currentProjectionMatrix.copy(camera.projectionMatrix);
            toNormalizedProjectionMatrix(_currentProjectionMatrix);
            toReversedProjectionMatrix(_currentProjectionMatrix);
            p_uniforms.setValue(_gl, "projectionMatrix", _currentProjectionMatrix);
          } else {
            p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
          }
          p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
          const uCamPos = p_uniforms.map.cameraPosition;
          if (uCamPos !== void 0) {
            uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
          }
          if (capabilities.logarithmicDepthBuffer) {
            p_uniforms.setValue(
              _gl,
              "logDepthBufFC",
              2 / (Math.log(camera.far + 1) / Math.LN2)
            );
          }
          if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
            p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
          }
          if (_currentCamera !== camera) {
            _currentCamera = camera;
            refreshMaterial = true;
            refreshLights = true;
          }
        }
        if (object.isSkinnedMesh) {
          p_uniforms.setOptional(_gl, object, "bindMatrix");
          p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
          const skeleton = object.skeleton;
          if (skeleton) {
            if (skeleton.boneTexture === null)
              skeleton.computeBoneTexture();
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          }
        }
        if (object.isBatchedMesh) {
          p_uniforms.setOptional(_gl, object, "batchingTexture");
          p_uniforms.setValue(_gl, "batchingTexture", object._matricesTexture, textures);
          p_uniforms.setOptional(_gl, object, "batchingIdTexture");
          p_uniforms.setValue(_gl, "batchingIdTexture", object._indirectTexture, textures);
          p_uniforms.setOptional(_gl, object, "batchingColorTexture");
          if (object._colorsTexture !== null) {
            p_uniforms.setValue(_gl, "batchingColorTexture", object._colorsTexture, textures);
          }
        }
        const morphAttributes = geometry.morphAttributes;
        if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0) {
          morphtargets.update(object, geometry, program);
        }
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
          materialProperties.receiveShadow = object.receiveShadow;
          p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
        }
        if (material.isMeshGouraudMaterial && material.envMap !== null) {
          m_uniforms.envMap.value = envMap;
          m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
        }
        if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) {
          m_uniforms.envMapIntensity.value = scene.environmentIntensity;
        }
        if (refreshMaterial) {
          p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
          if (materialProperties.needsLights) {
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
          }
          if (fog && material.fog === true) {
            materials.refreshFogUniforms(m_uniforms, fog);
          }
          materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);
          WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
        }
        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
          WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
          material.uniformsNeedUpdate = false;
        }
        if (material.isSpriteMaterial) {
          p_uniforms.setValue(_gl, "center", object.center);
        }
        p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
        p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
        p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
        if (material.isShaderMaterial || material.isRawShaderMaterial) {
          const groups = material.uniformsGroups;
          for (let i = 0, l = groups.length; i < l; i++) {
            const group = groups[i];
            uniformsGroups.update(group, program);
            uniformsGroups.bind(group, program);
          }
        }
        return program;
      }
      function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.lightProbe.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.directionalLightShadows.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.pointLightShadows.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.spotLightShadows.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
      }
      function materialNeedsLights(material) {
        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
      }
      this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
      };
      this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
      };
      this.getRenderTarget = function() {
        return _currentRenderTarget;
      };
      this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
        properties.get(renderTarget.texture).__webglTexture = colorTexture;
        properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
        const renderTargetProperties = properties.get(renderTarget);
        renderTargetProperties.__hasExternalTextures = true;
        renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
        if (!renderTargetProperties.__autoAllocateDepthBuffer) {
          if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
            console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
            renderTargetProperties.__useRenderToTexture = false;
          }
        }
      };
      this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
        const renderTargetProperties = properties.get(renderTarget);
        renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
        renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
      };
      const _scratchFrameBuffer = _gl.createFramebuffer();
      this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
        _currentRenderTarget = renderTarget;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        let useDefaultFramebuffer = true;
        let framebuffer = null;
        let isCube = false;
        let isRenderTarget3D = false;
        if (renderTarget) {
          const renderTargetProperties = properties.get(renderTarget);
          if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, null);
            useDefaultFramebuffer = false;
          } else if (renderTargetProperties.__webglFramebuffer === void 0) {
            textures.setupRenderTarget(renderTarget);
          } else if (renderTargetProperties.__hasExternalTextures) {
            textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
          } else if (renderTarget.depthBuffer) {
            const depthTexture = renderTarget.depthTexture;
            if (renderTargetProperties.__boundDepthTexture !== depthTexture) {
              if (depthTexture !== null && properties.has(depthTexture) && (renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height)) {
                throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
              }
              textures.setupDepthRenderbuffer(renderTarget);
            }
          }
          const texture = renderTarget.texture;
          if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
            isRenderTarget3D = true;
          }
          const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
          if (renderTarget.isWebGLCubeRenderTarget) {
            if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
              framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
            } else {
              framebuffer = __webglFramebuffer[activeCubeFace];
            }
            isCube = true;
          } else if (renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
            framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
          } else {
            if (Array.isArray(__webglFramebuffer)) {
              framebuffer = __webglFramebuffer[activeMipmapLevel];
            } else {
              framebuffer = __webglFramebuffer;
            }
          }
          _currentViewport.copy(renderTarget.viewport);
          _currentScissor.copy(renderTarget.scissor);
          _currentScissorTest = renderTarget.scissorTest;
        } else {
          _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
          _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
          _currentScissorTest = _scissorTest;
        }
        if (activeMipmapLevel !== 0) {
          framebuffer = _scratchFrameBuffer;
        }
        const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        if (framebufferBound && useDefaultFramebuffer) {
          state.drawBuffers(renderTarget, framebuffer);
        }
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
          const textureProperties = properties.get(renderTarget.texture);
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
        } else if (isRenderTarget3D) {
          const textureProperties = properties.get(renderTarget.texture);
          const layer = activeCubeFace;
          _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel, layer);
        } else if (renderTarget !== null && activeMipmapLevel !== 0) {
          const textureProperties = properties.get(renderTarget.texture);
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, textureProperties.__webglTexture, activeMipmapLevel);
        }
        _currentMaterialId = -1;
      };
      this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          return;
        }
        let framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
          framebuffer = framebuffer[activeCubeFaceIndex];
        }
        if (framebuffer) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          try {
            const texture = renderTarget.texture;
            const textureFormat = texture.format;
            const textureType = texture.type;
            if (!capabilities.textureFormatReadable(textureFormat)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              return;
            }
            if (!capabilities.textureTypeReadable(textureType)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              return;
            }
            if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
              _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
            }
          } finally {
            const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
            state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
          }
        }
      };
      this.readRenderTargetPixelsAsync = async function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        }
        let framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
          framebuffer = framebuffer[activeCubeFaceIndex];
        }
        if (framebuffer) {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (!capabilities.textureFormatReadable(textureFormat)) {
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
          }
          if (!capabilities.textureTypeReadable(textureType)) {
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
          }
          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            const glBuffer = _gl.createBuffer();
            _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
            _gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ);
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);
            const currFramebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
            state.bindFramebuffer(_gl.FRAMEBUFFER, currFramebuffer);
            const sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
            _gl.flush();
            await probeAsync(_gl, sync, 4);
            _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
            _gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer);
            _gl.deleteBuffer(glBuffer);
            _gl.deleteSync(sync);
            return buffer;
          } else {
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
          }
        }
      };
      this.copyFramebufferToTexture = function(texture, position = null, level = 0) {
        if (texture.isTexture !== true) {
          warnOnce("WebGLRenderer: copyFramebufferToTexture function signature has changed.");
          position = arguments[0] || null;
          texture = arguments[1];
        }
        const levelScale = Math.pow(2, -level);
        const width = Math.floor(texture.image.width * levelScale);
        const height = Math.floor(texture.image.height * levelScale);
        const x = position !== null ? position.x : 0;
        const y = position !== null ? position.y : 0;
        textures.setTexture2D(texture, 0);
        _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x, y, width, height);
        state.unbindTexture();
      };
      const _srcFramebuffer = _gl.createFramebuffer();
      const _dstFramebuffer = _gl.createFramebuffer();
      this.copyTextureToTexture = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = null) {
        if (srcTexture.isTexture !== true) {
          warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed.");
          dstPosition = arguments[0] || null;
          srcTexture = arguments[1];
          dstTexture = arguments[2];
          dstLevel = arguments[3] || 0;
          srcRegion = null;
        }
        if (dstLevel === null) {
          if (srcLevel !== 0) {
            warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.");
            dstLevel = srcLevel;
            srcLevel = 0;
          } else {
            dstLevel = 0;
          }
        }
        let width, height, depth2, minX, minY, minZ;
        let dstX, dstY, dstZ;
        const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[dstLevel] : srcTexture.image;
        if (srcRegion !== null) {
          width = srcRegion.max.x - srcRegion.min.x;
          height = srcRegion.max.y - srcRegion.min.y;
          depth2 = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
          minX = srcRegion.min.x;
          minY = srcRegion.min.y;
          minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;
        } else {
          const levelScale = Math.pow(2, -srcLevel);
          width = Math.floor(image.width * levelScale);
          height = Math.floor(image.height * levelScale);
          if (srcTexture.isDataArrayTexture) {
            depth2 = image.depth;
          } else if (srcTexture.isData3DTexture) {
            depth2 = Math.floor(image.depth * levelScale);
          } else {
            depth2 = 1;
          }
          minX = 0;
          minY = 0;
          minZ = 0;
        }
        if (dstPosition !== null) {
          dstX = dstPosition.x;
          dstY = dstPosition.y;
          dstZ = dstPosition.z;
        } else {
          dstX = 0;
          dstY = 0;
          dstZ = 0;
        }
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        let glTarget;
        if (dstTexture.isData3DTexture) {
          textures.setTexture3D(dstTexture, 0);
          glTarget = _gl.TEXTURE_3D;
        } else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {
          textures.setTexture2DArray(dstTexture, 0);
          glTarget = _gl.TEXTURE_2D_ARRAY;
        } else {
          textures.setTexture2D(dstTexture, 0);
          glTarget = _gl.TEXTURE_2D;
        }
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
        const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
        const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
        const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
        const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
        const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
        _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
        _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
        _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
        _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
        _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);
        const isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;
        const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;
        if (srcTexture.isDepthTexture) {
          const srcTextureProperties = properties.get(srcTexture);
          const dstTextureProperties = properties.get(dstTexture);
          const srcRenderTargetProperties = properties.get(srcTextureProperties.__renderTarget);
          const dstRenderTargetProperties = properties.get(dstTextureProperties.__renderTarget);
          state.bindFramebuffer(_gl.READ_FRAMEBUFFER, srcRenderTargetProperties.__webglFramebuffer);
          state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, dstRenderTargetProperties.__webglFramebuffer);
          for (let i = 0; i < depth2; i++) {
            if (isSrc3D) {
              _gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(srcTexture).__webglTexture, srcLevel, minZ + i);
              _gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(dstTexture).__webglTexture, dstLevel, dstZ + i);
            }
            _gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST);
          }
          state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
          state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
        } else if (srcLevel !== 0 || srcTexture.isRenderTargetTexture || properties.has(srcTexture)) {
          const srcTextureProperties = properties.get(srcTexture);
          const dstTextureProperties = properties.get(dstTexture);
          state.bindFramebuffer(_gl.READ_FRAMEBUFFER, _srcFramebuffer);
          state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, _dstFramebuffer);
          for (let i = 0; i < depth2; i++) {
            if (isSrc3D) {
              _gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, srcTextureProperties.__webglTexture, srcLevel, minZ + i);
            } else {
              _gl.framebufferTexture2D(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, srcTextureProperties.__webglTexture, srcLevel);
            }
            if (isDst3D) {
              _gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, dstTextureProperties.__webglTexture, dstLevel, dstZ + i);
            } else {
              _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, dstTextureProperties.__webglTexture, dstLevel);
            }
            if (srcLevel !== 0) {
              _gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, _gl.COLOR_BUFFER_BIT, _gl.NEAREST);
            } else if (isDst3D) {
              _gl.copyTexSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ + i, minX, minY, width, height);
            } else {
              _gl.copyTexSubImage2D(glTarget, dstLevel, dstX, dstY, minX, minY, width, height);
            }
          }
          state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
          state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
        } else {
          if (isDst3D) {
            if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
              _gl.texSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image.data);
            } else if (dstTexture.isCompressedArrayTexture) {
              _gl.compressedTexSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth2, glFormat, image.data);
            } else {
              _gl.texSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image);
            }
          } else {
            if (srcTexture.isDataTexture) {
              _gl.texSubImage2D(_gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data);
            } else if (srcTexture.isCompressedTexture) {
              _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data);
            } else {
              _gl.texSubImage2D(_gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image);
            }
          }
        }
        _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
        _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
        _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
        _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
        _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
        if (dstLevel === 0 && dstTexture.generateMipmaps) {
          _gl.generateMipmap(glTarget);
        }
        state.unbindTexture();
      };
      this.copyTextureToTexture3D = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
        if (srcTexture.isTexture !== true) {
          warnOnce("WebGLRenderer: copyTextureToTexture3D function signature has changed.");
          srcRegion = arguments[0] || null;
          dstPosition = arguments[1] || null;
          srcTexture = arguments[2];
          dstTexture = arguments[3];
          level = arguments[4] || 0;
        }
        warnOnce('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.');
        return this.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);
      };
      this.initRenderTarget = function(target) {
        if (properties.get(target).__webglFramebuffer === void 0) {
          textures.setupRenderTarget(target);
        }
      };
      this.initTexture = function(texture) {
        if (texture.isCubeTexture) {
          textures.setTextureCube(texture, 0);
        } else if (texture.isData3DTexture) {
          textures.setTexture3D(texture, 0);
        } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          textures.setTexture2DArray(texture, 0);
        } else {
          textures.setTexture2D(texture, 0);
        }
        state.unbindTexture();
      };
      this.resetState = function() {
        _currentActiveCubeFace = 0;
        _currentActiveMipmapLevel = 0;
        _currentRenderTarget = null;
        state.reset();
        bindingStates.reset();
      };
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
    }
    get coordinateSystem() {
      return WebGLCoordinateSystem;
    }
    get outputColorSpace() {
      return this._outputColorSpace;
    }
    set outputColorSpace(colorSpace) {
      this._outputColorSpace = colorSpace;
      const gl = this.getContext();
      gl.drawingBufferColorspace = ColorManagement._getDrawingBufferColorSpace(colorSpace);
      gl.unpackColorSpace = ColorManagement._getUnpackColorSpace();
    }
  };

  // src/shaders/test/fragment.glsl
  var fragment_default = "uniform sampler2D uTexture;uniform float uOpacity;varying vec2 vUv;void main(){vec4 texture=texture2D(uTexture,vUv);gl_FragColor=texture;gl_FragColor.a*=uOpacity;}";

  // src/shaders/test/vertex.glsl
  var vertex_default = "varying vec2 vUv;uniform float uTime;uniform float uManualTime;uniform float uSpeed;uniform float uElevation;uniform float uTwistFactor;uniform float uTwistFactor2;uniform vec2 uFrequency;uniform sampler2D uTexture;varying float twistPerlin2;vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x,289.0);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float cnoise(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod(Pi0,289.0);Pi1=mod(Pi1,289.0);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0/7.0;vec4 gy0=fract(floor(gx0)/7.0)-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1/7.0;vec4 gy1=fract(floor(gx1)/7.0)-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}vec2 rotate2D(vec2 value,float angle){float s=sin(angle);float c=cos(angle);mat2 m=mat2(c,s,-s,c);return m*value;}void main(){vec3 newPosition=position;newPosition.x*=3.0;float elevation=sin(position.x*uFrequency.x+uManualTime*uSpeed)*sin(position.y*uFrequency.y+uManualTime*uSpeed)*uElevation;newPosition.xy+=elevation;float angle=newPosition.y*uTwistFactor*cnoise(vec3(newPosition.zx,uManualTime));float angle2=newPosition.y*uTwistFactor2*cnoise(vec3(newPosition.yz,uManualTime));newPosition.zy*=rotate2D(newPosition.zy,angle);gl_Position=projectionMatrix*modelViewMatrix*vec4(newPosition,1.0);vUv=uv;}";

  // src/shaders/test/vertex2.glsl
  var vertex2_default = "varying vec2 vUv;uniform float uTime;uniform float uManualTime;uniform float uSpeed;uniform float uElevation;uniform float uTwistFactor;uniform float uTwistFactor2;uniform vec2 uFrequency;uniform sampler2D uTexture;varying float twistPerlin2;vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x,289.0);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float cnoise(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod(Pi0,289.0);Pi1=mod(Pi1,289.0);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0/7.0;vec4 gy0=fract(floor(gx0)/7.0)-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1/7.0;vec4 gy1=fract(floor(gx1)/7.0)-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}vec2 rotate2D(vec2 value,float angle){float s=sin(angle);float c=cos(angle);mat2 m=mat2(c,s,-s,c);return m*value;}void main(){vec3 newPosition=position;newPosition.x*=5.0;float elevation=sin(position.x*uFrequency.x+uManualTime*uSpeed)*sin(position.y*uFrequency.y+uManualTime*uSpeed)*uElevation;newPosition.xy+=elevation;float angle=newPosition.y*uTwistFactor*cnoise(vec3(newPosition.zx,uManualTime));float angle2=newPosition.y*uTwistFactor2*cnoise(vec3(newPosition.yz,uManualTime));newPosition.zy*=rotate2D(newPosition.zy,angle);gl_Position=projectionMatrix*modelViewMatrix*vec4(newPosition,1.0);vUv=uv;}";

  // src/WaveAnim.js
  var WaveAnim = class {
    scene;
    meshTop;
    meshBottom;
    _currentSection;
    _isMobile;
    preloaderComplete = false;
    constructor() {
      const canvas = document.createElement("canvas");
      canvas.classList.add("webgl");
      canvas.style.zIndex = "1";
      document.body.appendChild(canvas);
      this.scene = new Scene();
      const sizes = {
        width: window.innerWidth,
        height: window.innerHeight
      };
      window.addEventListener("resize", () => {
        sizes.width = window.innerWidth;
        sizes.height = window.innerHeight;
        camera.aspect = sizes.width / sizes.height;
        camera.updateProjectionMatrix();
        renderer.setSize(sizes.width, sizes.height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      });
      const camera = new PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100);
      camera.position.set(0.25, 1, 1.2);
      this.scene.add(camera);
      const renderer = new WebGLRenderer({
        canvas,
        antialias: true,
        alpha: true,
        preserveDrawingBuffer: true
      });
      renderer.setSize(sizes.width, sizes.height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      const texture = new TextureLoader().load(
        "https://cdn.prod.website-files.com/67a51f5233734befd00d7699/67bf928a8f6ad5c62f6effc8_curved.png"
      );
      texture.minFilter = LinearMipmapLinearFilter;
      texture.magFilter = LinearFilter;
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      texture.generateMipmaps = true;
      const geometry = new PlaneGeometry(2, 1, 400, 400);
      const params1 = {
        position: [0, 0, 0],
        rotation: [0, 0, 0],
        vertexShader: vertex_default,
        fragmentShader: fragment_default,
        freqX: -5,
        freqY: -1.3,
        twist: -3,
        elevation: 0.1
      };
      const params2 = {
        position: [0, 2.1, 0],
        rotation: [0, 0, Math.PI],
        vertexShader: vertex2_default,
        fragmentShader: fragment_default,
        freqX: -3,
        freqY: 1.9,
        twist: -3.5,
        elevation: 0.2
      };
      this.meshBottom = this.createMesh(params1, texture, geometry);
      this.meshTop = this.createMesh(params2, texture, geometry);
      const tick = () => {
        if (this.meshTop) {
          this.meshTop.material.uniforms.uManualTime.value += 25e-4;
        }
        if (this.meshBottom) {
          this.meshBottom.material.uniforms.uManualTime.value += 22e-4;
        }
        if (this.meshTop || this.meshBottom) {
          renderer.render(this.scene, camera);
          window.requestAnimationFrame(tick);
        }
      };
      tick();
      this.initAnim();
    }
    createMesh(params, texture, geometry) {
      const material = new ShaderMaterial({
        vertexShader: params.vertexShader,
        fragmentShader: params.fragmentShader,
        side: DoubleSide,
        depthWrite: false,
        transparent: true,
        uniforms: {
          uTexture: { value: texture },
          uTime: { value: 0 },
          uElevation: { value: params.elevation },
          uTwistFactor: { value: params.twist },
          uTwistFactor2: { value: -2 },
          uFrequency: { value: new Vector2(params.freqX, params.freqY) },
          uSpeed: { value: 0.5 },
          uManualTime: { value: 0 },
          uOpacity: { value: 0 }
        }
      });
      const mesh = new Mesh(geometry, material);
      mesh.position.set(...params.position);
      mesh.rotation.set(...params.rotation);
      this.scene.add(mesh);
      return mesh;
    }
    get isMobile() {
      return this._isMobile;
    }
    set isMobile(val) {
      if (this.preloaderComplete) {
        this.showHideBottomMesh(val ? 0 : 1);
      }
      this._isMobile = val;
    }
    initAnim() {
      gsap.to(this.meshTop.material.uniforms.uOpacity, { value: 1, duration: 2, ease: "linear" });
      gsap.to(this.meshBottom.material.uniforms.uOpacity, {
        value: 1,
        duration: 2,
        ease: "linear"
      });
    }
    onPreloaderComplete() {
      this.preloaderComplete = true;
      if (this.meshTop) {
        gsap.killTweensOf(this.meshTop.material.uniforms.uOpacity);
        gsap.to(this.meshTop.material.uniforms.uOpacity, {
          value: 0,
          duration: 1,
          ease: "linear",
          onComplete: () => {
            this.meshTop.geometry.dispose();
            this.meshTop.material.dispose();
            this.scene.remove(this.meshTop);
            this.meshTop = null;
          }
        });
      }
      if (this.meshBottom && this.isMobile) {
        this.showHideBottomMesh(0);
      }
    }
    showHideBottomMesh(opacity) {
      opacity = 0;
      gsap.killTweensOf(this.meshBottom.material.uniforms.uOpacity);
      gsap.to(this.meshBottom.material.uniforms.uOpacity, {
        value: opacity,
        duration: 1,
        ease: "linear"
        // onComplete: () => {
        //   this.meshBottom.geometry.dispose();
        //   this.meshBottom.material.dispose();
        //   this.scene.remove(this.meshBottom);
        //   this.meshBottom = null;
        // },
      });
    }
  };

  // src/wave.svg
  var wave_default = '<svg preserveAspectRatio="xMidYMid meet" viewBox="0 0 4320 323" fill="none" xmlns="http://www.w3.org/2000/svg">\n<g clip-path="url(#clip0_1779_1730)">\n<g opacity="0.2">\n<path d="M3328.63 609.338C3329.06 621.032 3319.9 633.687 3299.61 634.924C3282.14 635.665 3263.75 630.584 3247.99 626.484C3218.23 618.738 3189.62 609.182 3161.33 599.525C3063.84 566.243 2969.09 529.686 2874.01 493.764C2785.01 460.133 2695.94 426.565 2606.21 393.712C2538.65 369.039 2470.72 344.762 2402.15 321.23C2157.18 294.174 1908.98 279.554 1660.81 270.873C1601.46 268.84 1542.08 267.156 1482.67 265.796C1476.58 278.779 1471.54 291.913 1466.65 305.09C1455.26 335.45 1442.8 365.339 1421.65 393.654C1403.41 416.782 1415.46 447.643 1421.41 471.765C1427.46 496.16 1435.83 522.677 1426.56 547.165C1416.68 573.231 1382.79 586.407 1342.64 590.234C1311.52 593.202 1279.79 591.775 1248.71 589.443C1165.35 582.526 1068.23 571.741 1004.98 533.424C968.595 510.262 954.194 481.304 949.726 449.398C948.821 443.227 948.175 437.043 947.563 430.859C945.146 407.415 943.515 381.723 921.883 361.622C892.728 334.537 836.714 327.187 788.664 323.587C515.269 304.964 240.502 325.225 -30.7025 347.625C-105.624 353.817 -180.719 360.708 -256.181 363.655C-302.313 365.436 -348.679 365.752 -394.885 365.587C-447.943 365.398 -502.431 365.31 -554.796 359.29C-566.015 357.879 -593.951 355.998 -596.994 346.644C-596.994 346.522 -597.007 346.391 -596.994 346.273C-595.882 335.833 -549.237 331.127 -536.473 329.216C-504.875 324.492 -472.79 321.137 -440.759 317.858C-439.667 317.744 -439.128 317.689 -438.036 317.576C-292.972 302.741 -145.439 295.61 0.916057 288.205C253.385 275.491 506.461 267.388 759.642 263.342C999.135 259.612 1238.78 259.663 1478.21 264.942C1490.87 238.678 1510.33 213.765 1545.01 196.408C1593.3 172.244 1657.91 165.475 1717.54 162.263C1821.73 157.043 1929.73 181.746 2025.12 205.257C2156.49 237.638 2282.55 278.371 2406.43 320.779C2448.12 325.423 2489.7 330.411 2531.17 335.829C2669.83 354.141 2807.72 376.781 2939.95 409.2C3022.56 429.453 3103.94 453.562 3177.04 485.476C3203.92 497.208 3229.67 510.06 3253.08 524.478C3287.8 546.314 3328.54 576.308 3328.69 609.329H3328.63V609.338ZM2410.25 322.139C2477.58 345.297 2544.26 369.183 2610.6 393.435C2700.34 426.287 2789.4 459.864 2878.41 493.495C2967.96 527.333 3057.25 561.591 3148.67 593.391C3179.05 603.958 3209.69 614.402 3241.38 623.331C3258.16 628.058 3278.99 634.928 3298 634.23C3321.02 632.984 3324.66 613.577 3322.7 602.459C3317.29 571.854 3281.22 545.447 3248.18 524.672C3224.83 510.279 3199.13 497.452 3172.31 485.741C3099.36 453.89 3018.15 429.832 2935.71 409.617C2803.77 377.261 2666.18 354.667 2527.83 336.397C2488.72 331.299 2449.51 326.564 2410.2 322.143H2410.26L2410.25 322.139ZM1482.97 265.064C1542.61 266.428 1602.22 268.116 1661.81 270.158C1908.28 278.779 2154.76 293.265 2398.13 319.891C2303.64 287.62 2207.96 256.59 2109.67 229.172C2035.67 208.608 1960.1 189.584 1881.91 176.349C1829.33 167.449 1773.69 160.242 1718.98 162.983C1650.2 166.708 1574.53 176.033 1526.97 210.586C1505.49 226.318 1492.82 245.468 1482.98 265.072V265.064H1482.97ZM1408.11 422.911C1408.07 412.972 1409.91 402.637 1416.77 393.569C1437.91 365.268 1450.38 335.4 1461.75 305.052C1466.7 291.863 1471.73 278.699 1477.77 265.691C1238.63 260.416 999.268 260.374 760.068 264.092C507.24 268.137 254.511 276.228 2.39414 288.925C-143.568 296.313 -290.702 303.419 -435.379 318.211C-436.471 318.321 -437.01 318.376 -438.102 318.485C-469.694 321.714 -501.326 325.019 -532.492 329.653C-544.962 331.506 -591.102 336.098 -592.174 346.278C-592.187 346.383 -592.174 346.505 -592.174 346.627C-589.477 355.484 -562.486 357.366 -551.893 358.709C-500.314 364.64 -446.604 364.699 -394.353 364.872C-348.719 365.023 -302.926 364.703 -257.366 362.944C-182.277 360.001 -107.549 353.139 -32.9995 346.976C239.637 324.45 515.795 304.181 790.635 322.909C839.318 326.551 896.523 333.893 926.304 361.256C948.235 381.399 949.9 407.276 952.316 430.846C952.936 437.03 953.628 443.21 954.48 449.382C958.941 481.215 973.242 510.128 1009.55 533.247C1072.25 571.181 1168.25 581.933 1250.87 588.794C1280.37 591.03 1310.43 592.44 1339.97 589.615C1379.63 585.835 1412.39 572.562 1421.81 546.87C1430.76 522.433 1422.47 496.118 1416.45 471.794C1412.46 455.566 1408.52 439.362 1408.03 422.915H1408.09L1408.11 422.911Z" fill="url(#paint0_linear_1779_1730)" style=""/>\n<path d="M3355.56 604.219C3355.66 617.062 3345.26 632.171 3322.06 632.962C3304.34 633.737 3285.69 628.66 3269.68 624.543C3240.35 616.999 3212.1 607.729 3184.17 598.333C3087.24 565.721 2993.01 529.837 2898.46 494.585C2810.56 461.809 2722.62 429.095 2634 397.097C2550.96 367.01 2467.39 337.492 2382.66 309.346C2242.98 293.816 2102.3 282.286 1960.98 274.721C1837.9 268.318 1714.51 265.413 1591.08 263.565C1569.3 263.25 1547.51 262.955 1525.73 262.706C1517.21 278.005 1510.68 293.644 1504.26 309.337C1492.28 338.801 1479.22 367.781 1457.85 395.161C1439.16 417.455 1449.93 447.622 1455.07 471.209C1460.26 494.952 1467.54 520.677 1457.78 544.327C1447.29 569.729 1413.58 582.438 1374.25 586.167C1343.29 589.106 1311.74 587.679 1280.82 585.347C1196.97 578.358 1100.86 567.417 1036.1 529.972C998.957 507.417 982.332 479.014 975.521 447.277C974.243 441.278 973.171 435.258 972.119 429.242C968.017 405.887 964.355 380.574 941.752 360.969C911.105 334.389 855.352 326.938 806.782 323.259C535.544 304.568 262.934 323.857 -6.33312 345.444C-79.7037 351.321 -153.234 357.879 -227.111 360.654C-227.583 360.367 -227.816 360.224 -228.282 359.934C-154.765 357.172 -81.5812 350.639 -8.55685 344.791C262.149 323.09 536.15 303.789 808.826 322.585C858.081 326.315 914.88 333.749 946.193 360.616C969.116 380.283 972.831 405.714 976.946 429.225C977.998 435.245 979.07 441.261 980.348 447.26C987.152 478.929 1003.74 507.286 1040.8 529.795C1104.96 566.904 1200.01 577.773 1283.11 584.698C1312.45 586.925 1342.33 588.335 1371.72 585.549C1410.55 582.025 1443.16 568.95 1453.2 544.049C1462.7 520.492 1455.42 494.863 1450.23 471.243C1445.11 447.622 1434.27 417.388 1453.1 395.081C1474.45 367.718 1487.5 338.751 1499.49 309.304C1505.87 293.606 1512.38 277.962 1520.85 262.656C1283.46 260.012 1045.98 261.364 808.706 266.824C767.121 267.792 725.535 268.794 683.963 269.926C662.471 270.511 640.979 271.096 619.487 271.686C487.027 275.281 354.554 278.817 222.181 283.502C92.3909 288.133 -37.3858 293.147 -166.976 299.659C-243.13 303.486 -319.736 307.136 -395.284 314.532C-427.728 317.723 -460.172 321.36 -492.037 326.412C-506.085 328.639 -550.88 333.034 -554.056 344.876C-553.456 351.982 -535.467 354.432 -527.45 356.002C-478.182 364.733 -423.8 364.8 -373.039 365.486C-329.35 366.076 -284.848 366.652 -241.272 364.047C-240.553 364.32 -240.193 364.455 -239.481 364.729C-282.944 367.318 -327.286 366.825 -370.869 366.311C-423.66 365.688 -479.953 365.566 -531.166 356.486C-539.608 354.827 -558.11 352.247 -558.949 344.867C-555.847 332.802 -510.286 328.256 -496.038 325.983C-463.741 320.834 -430.844 317.146 -397.947 313.905C-322.153 306.487 -245.3 302.817 -168.9 298.973C-39.0636 292.448 90.9594 287.422 220.996 282.787C353.476 278.093 486.049 274.557 618.615 270.962C640.107 270.377 661.599 269.796 683.091 269.202C724.709 268.061 766.328 267.059 807.96 266.091C1045.62 260.631 1283.48 259.271 1521.27 261.923C1535.21 237.718 1556.69 215.739 1590.43 200.689C1638.19 179.38 1699.11 173.28 1756.02 170.337C1851.17 165.601 1949.68 186.536 2037.56 207.13C2157.87 235.322 2273.47 271.286 2386.98 308.925C2453.25 316.389 2519.26 324.728 2584.97 333.964C2783.64 362.19 2989.83 397.577 3165.83 464.57C3191.74 474.433 3216.91 485.139 3240.57 497.073C3256.54 505.27 3272.01 513.824 3286.35 523.152C3318.88 544.441 3355.54 572.844 3355.6 604.223C3355.57 604.223 3355.56 604.227 3355.54 604.231L3355.56 604.219ZM2391.15 310.297C2474.5 338.106 2556.78 367.166 2638.52 396.811C2727.12 428.821 2815.08 461.527 2902.98 494.299C2992.03 527.497 3080.82 561.111 3171.71 592.267C3202.28 602.749 3233.13 613.105 3265.04 621.895C3281.58 626.454 3301.95 632.954 3320.6 632.251C3344.79 631.068 3351.63 612.747 3350.37 600.262C3347.36 570.293 3313.14 543.898 3281.66 523.308C3267.33 513.992 3251.91 505.438 3235.93 497.267C3212.6 485.492 3187.78 474.913 3162.24 465.164C2986.43 398.078 2780.32 362.704 2581.74 334.486C2518.49 325.591 2454.98 317.529 2391.22 310.285C2391.19 310.285 2391.19 310.289 2391.16 310.293L2391.15 310.297ZM1526.18 261.974C1547.98 262.231 1569.78 262.517 1591.57 262.833C1715.38 264.681 1839.15 267.598 1962.59 274.014C2101.99 281.482 2240.76 292.797 2378.58 307.969C2301.66 282.522 2223.85 258.105 2144.33 236.08C2071.13 215.903 1996.39 197.254 1919.1 184.271C1866.91 175.498 1811.75 168.426 1757.47 171.028C1689.33 174.568 1614.47 183.509 1566.59 217.187C1548.48 230.57 1536.11 245.569 1526.24 261.966C1526.21 261.966 1526.21 261.97 1526.18 261.974Z" fill="url(#paint1_linear_1779_1730)" style=""/>\n<path d="M3382.07 599.281C3382.16 613.619 3370.08 630.045 3344.51 630.997C3327.04 631.771 3308.76 626.968 3292.88 622.981C3263.4 615.585 3235.03 606.412 3206.96 597.113C3110.57 565.178 3016.86 529.964 2922.82 495.385C2836.07 463.48 2749.27 431.629 2661.83 400.477C2560.87 364.173 2459.1 328.689 2355.36 295.643C2243.54 283.305 2131.02 273.845 2017.89 267.868C1894 261.591 1769.74 260.505 1645.51 260.021C1620.45 259.928 1595.39 259.865 1570.33 259.84C1559.01 276.965 1551.02 294.747 1543.1 312.587C1530.26 341.529 1516.3 369.961 1494.11 396.672C1475.7 418.348 1484.75 447.079 1489.09 470.224C1493.47 493.352 1499.77 518.48 1489.45 541.338C1478.3 566.037 1444.66 578.59 1406 582.08C1375.18 584.984 1343.78 583.566 1313 581.238C1228.72 574.178 1133.47 563.128 1067.35 526.503C1029.44 504.529 1010.58 476.665 1001.39 445.134C999.687 439.304 998.229 433.448 996.745 427.596C990.939 404.334 985.28 379.42 961.697 360.292C929.566 334.221 874.085 326.66 824.976 322.897C555.889 304.138 285.45 322.451 18.1133 343.213C-53.7259 348.791 -125.718 355.008 -198.024 357.597C-198.47 357.311 -198.689 357.168 -199.135 356.878C-127.203 354.297 -55.5835 348.1 15.8829 342.548C284.638 321.676 556.455 303.351 826.96 322.223C876.762 326.029 933.241 333.581 966.038 359.921C989.934 379.117 995.673 404.144 1001.52 427.567C1002.95 433.423 1004.45 439.274 1006.16 445.104C1015.35 476.564 1034.1 504.381 1071.93 526.314C1137.43 562.593 1231.66 573.589 1315.17 580.581C1344.39 582.8 1374.14 584.21 1403.41 581.453C1441.57 578.017 1474.11 565.376 1484.79 541.035C1494.79 518.24 1488.56 493.293 1484.21 470.249C1479.86 447.049 1470.83 418.293 1489.29 396.571C1511.5 369.886 1525.43 341.466 1538.24 312.533C1546.15 294.7 1554.14 276.931 1565.46 259.823C1329.28 259.659 1093.09 262.424 857.161 269.522C848.126 269.791 839.091 270.065 830.056 270.334C796.866 271.332 763.677 272.342 730.5 273.445C635.658 276.569 540.762 279.028 445.866 281.452C381.697 283.094 317.521 284.727 253.372 286.651C238.911 287.089 224.456 287.527 209.995 287.965C91.4505 291.539 -27.1208 294.928 -145.592 299.415C-215.527 302.063 -286.062 304.307 -355.431 310.823C-382.921 313.425 -410.332 316.683 -437.383 320.733C-455.18 323.398 -473.163 326.29 -490.148 330.647C-498.969 332.912 -514.11 336.25 -516.187 343.078C-516.253 350.003 -499.755 353.194 -491.805 354.79C-446.039 364.404 -394.067 365.049 -346.269 366.16C-306.581 367.002 -264.996 368.555 -225.488 365.12C-224.476 365.373 -223.963 365.499 -222.951 365.752C-263.072 369.254 -305.323 367.848 -345.637 366.96C-395.052 365.874 -448.296 365.049 -495.7 355.223C-503.93 353.565 -521.127 350.247 -521.007 343.057C-519.003 336.271 -504.216 332.878 -495.454 330.584C-477.977 326.004 -459.401 323.01 -441.032 320.253C-413.595 316.14 -385.791 312.831 -357.901 310.188C-288.252 303.646 -217.431 301.377 -147.21 298.716C-28.4923 294.216 90.3387 290.819 209.136 287.236C223.598 286.799 238.052 286.361 252.513 285.923C316.709 284.003 380.918 282.357 445.134 280.716C539.943 278.291 634.752 275.837 729.515 272.717C762.738 271.606 795.968 270.604 829.198 269.598C838.232 269.328 847.267 269.055 856.302 268.785C1092.72 261.667 1329.42 258.897 1566.09 259.069C1581.34 236.994 1604.34 217.953 1636.85 205.034C1683.57 186.473 1740.6 181.021 1794.59 178.348C1879.96 174.581 1967.1 191.041 2046.8 208.557C2154.39 232.203 2257.97 262.841 2359.64 295.167C2453.29 305.641 2546.33 318.077 2638.83 332.045C2769.97 352.015 2900.26 375.783 3025.35 407.933C3113.25 430.522 3202.74 456.988 3276.1 495.709C3291.39 503.931 3305.83 512.565 3319.65 521.772C3349.72 542.601 3382.03 569.543 3382.08 599.239V599.268L3382.07 599.281ZM2363.97 296.611C2466.23 329.376 2566.64 364.371 2666.29 400.195C2753.72 431.347 2840.53 463.198 2927.28 495.103C3015.84 527.665 3104.14 560.644 3194.53 591.164C3224.98 601.449 3255.7 611.598 3287.46 620.19C3304.05 624.678 3324.36 631.022 3342.98 630.298C3368.94 628.904 3378.21 611.59 3377.23 597.386C3375.24 568.432 3344.54 542.5 3314.95 521.978C3301.14 512.796 3286.71 504.175 3271.45 495.962C3198.24 457.308 3108.92 430.893 3021.19 408.35C2896.35 376.267 2766.31 352.542 2635.43 332.609C2545.5 319.028 2455.05 306.908 2364.03 296.611H2363.97H2363.97ZM1570.83 259.103C1595.77 259.137 1620.7 259.191 1645.63 259.28C1770.34 259.764 1895.07 260.867 2019.44 267.173C2130.54 273.033 2241.05 282.256 2350.9 294.246C2294.21 276.266 2236.97 259.023 2178.82 242.992C2106.42 223.203 2032.53 204.945 1956.17 192.207C1904.36 183.564 1849.67 176.626 1795.81 179.081C1742.68 181.712 1686.62 187.147 1640.73 205.488C1608.59 218.332 1585.88 237.242 1570.77 259.09C1570.8 259.09 1570.81 259.095 1570.83 259.099V259.103Z" fill="url(#paint2_linear_1779_1730)" style=""/>\n<path d="M3409.75 594.84V595.909C3409.35 612.221 3394.6 627.62 3367.04 629.031C3348.88 629.856 3329.8 624.872 3313.28 620.776C3282.46 613.126 3252.76 603.642 3223.38 594.027C3122.48 561.002 3024.31 524.596 2925.81 488.835C2847.28 460.31 2768.71 431.836 2689.68 403.871C2567.28 360.595 2443.91 318.3 2317.37 280.03C2236.93 271.635 2156.08 265.199 2074.82 261.04C1950.08 254.889 1824.98 255.626 1699.97 256.493C1672.01 256.691 1644.04 256.906 1616.07 257.154C1600.56 275.845 1591.09 296.258 1581.41 316.368C1567.82 344.594 1553.15 372.302 1530.43 398.2C1511.8 419.025 1519.54 446.919 1523.01 469.483C1526.52 492.001 1531.73 516.396 1520.94 538.446C1509.15 562.517 1475.68 574.633 1437.75 578.03C1407.05 580.905 1375.78 579.491 1345.12 577.159C1260.85 570.078 1165.88 559.133 1098.68 523.464C1059.25 502.533 1038.91 474.097 1027.2 443.033C1025.18 437.363 1023.26 431.68 1021.38 425.988C1013.82 402.835 1006.17 378.343 981.605 359.66C947.989 334.095 892.802 326.433 843.114 322.585C576.19 303.764 307.901 321.095 42.4956 341.028C-27.8056 346.307 -98.26 352.196 -169.001 354.613C-169.42 354.327 -169.633 354.183 -170.053 353.893C-99.6915 351.493 -29.6099 345.617 40.3251 340.367C307.142 320.329 576.802 302.993 845.151 321.924C895.485 325.818 951.745 333.476 985.973 359.294C1010.81 378.027 1018.54 402.671 1026.14 425.959C1028.02 431.65 1029.94 437.329 1031.96 443.004C1043.62 473.912 1063.8 502.268 1103 523.123C1169.63 558.573 1263.7 569.493 1347.35 576.523C1376.42 578.737 1406.02 580.148 1435.15 577.42C1472.52 574.081 1504.95 561.857 1516.29 538.177C1526.8 516.202 1521.56 491.933 1518.06 469.525C1514.54 446.906 1506.87 418.992 1525.55 398.12C1548.26 372.235 1562.92 344.543 1576.54 316.334C1586.22 296.258 1595.64 275.879 1611.12 257.213C1375.85 259.373 1140.58 263.553 905.672 272.292C890.185 272.865 874.692 273.429 859.206 273.993C831.835 274.982 804.464 275.984 777.093 277.049C659.008 281.625 540.77 284.218 422.544 286.765C376.611 287.754 330.671 288.744 284.745 289.884C196.068 292.103 107.377 293.98 18.6735 295.803C-92.188 298.072 -205.393 297.352 -315.456 307.182C-348.852 310.2 -382.201 314.461 -414.652 320.304C-430.818 323.217 -473.568 328.487 -478.256 341.352C-478.768 348.374 -464.127 351.481 -456.105 353.64C-406.483 365.453 -348.499 366.291 -296.214 367.545C-268.171 368.084 -237.471 369.684 -209.647 366.286C-208.362 366.505 -207.717 366.615 -206.432 366.838C-235.58 370.378 -267.465 368.837 -296.893 368.273C-350.416 367.111 -409.625 366.219 -460.186 354.028C-468.136 352.154 -484.121 348.353 -483.083 341.314C-478.289 328.222 -434.952 322.842 -418.527 319.879C-385.617 313.939 -351.808 309.603 -317.939 306.538C-207.277 296.645 -93.4796 297.344 17.9877 295.062C106.625 293.244 195.256 291.362 283.873 289.144C329.839 288.003 375.819 287.013 421.792 286.024C539.837 283.486 657.889 280.893 775.788 276.325C803.173 275.26 830.563 274.262 857.961 273.265C873.454 272.705 888.94 272.136 904.427 271.564C1139.91 262.791 1375.76 258.619 1611.61 256.459C1655.5 204.297 1745.98 190.548 1832.82 186.46C1905.97 183.366 1980.2 195.52 2049.33 209.395C2142.56 228.115 2232.49 253.075 2320.77 279.571C2445.89 292.747 2569.61 310.344 2692.46 330.222C2821.41 351.199 2949.53 375.661 3072.43 408.27C3156.24 430.505 3242.46 456.323 3311.47 494.455C3326.06 502.668 3339.71 511.319 3352.8 520.488C3380.52 540.762 3409.91 566.736 3409.55 594.852C3409.62 594.844 3409.65 594.84 3409.73 594.831L3409.75 594.84ZM2325.29 280.859C2450.61 318.814 2572.83 360.696 2694.08 403.567C2773.09 431.554 2851.66 460.032 2930.2 488.54C3022.96 522.226 3115.48 556.342 3210.11 587.902C3241.68 598.43 3273.52 608.812 3306.39 617.643C3324.06 622.392 3345.59 629.111 3365.38 628.332C3391.46 627.069 3403.87 610.676 3404.42 595.888C3405.49 567.396 3376.3 541.174 3348.23 520.635C3335.16 511.483 3321.51 502.849 3306.96 494.64C3238.1 456.572 3152.03 430.808 3068.38 408.615C2945.69 376.065 2817.79 351.649 2689.07 330.714C2568.83 311.312 2447.67 293.955 2325.28 280.871V280.863L2325.29 280.859ZM1616.7 256.396C1644.4 256.148 1672.09 255.933 1699.78 255.744C1825.39 254.872 1951.09 254.157 2076.43 260.328C2155.72 264.462 2234.64 270.73 2313.18 278.733C2226.3 252.7 2137.83 228.174 2046.12 209.711C1978.55 196.109 1905.9 184.124 1834.36 187.142C1748.62 191.188 1660.05 204.987 1616.76 256.384C1616.73 256.384 1616.73 256.388 1616.7 256.392V256.396Z" fill="url(#paint3_linear_1779_1730)" style=""/>\n<path d="M3437.33 589.952C3437.33 591.32 3437.27 592.676 3437.09 594.006C3435.18 611.118 3417.52 625.591 3389.45 627.061C3370.78 627.928 3351.18 622.851 3334.16 618.679C3303.24 611.097 3273.38 601.714 3243.86 592.192C3141.73 559.255 3042.32 522.9 2942.58 487.193C2867.67 460.382 2792.77 433.583 2717.46 407.242C2571.67 356.297 2424.51 306.479 2272.07 263.868C2225.43 259.823 2178.67 256.59 2131.75 254.182C2012.82 248.465 1893.63 250.494 1774.53 252.574C1767.81 252.692 1761.08 252.805 1754.36 252.923C1724.04 253.445 1693.71 253.984 1663.39 254.54C1642.84 274.553 1631.36 297.639 1619.66 320.123C1605.29 347.629 1589.85 374.592 1566.62 399.686C1547.84 419.615 1554.19 446.818 1556.85 468.704C1559.54 490.59 1563.76 514.308 1552.45 535.533C1539.99 558.931 1506.66 570.629 1469.48 573.934C1438.92 576.771 1407.8 575.361 1377.28 573.037C1292.56 565.885 1198.55 554.776 1130 519.978C1089.77 499.561 1067.21 471.68 1053.05 440.874C1050.67 435.363 1048.38 429.844 1046.12 424.313C1036.77 401.298 1027.14 377.206 1001.62 358.961C966.584 333.922 911.596 326.143 861.361 322.211C596.608 303.322 330.504 319.676 67.0553 338.763C-1.71463 343.743 -70.631 349.304 -139.794 351.552C-140.187 351.262 -140.386 351.115 -140.786 350.824C-71.9693 348.593 -3.40575 343.045 65.0113 338.09C329.851 318.902 597.314 302.539 863.465 321.537C914.345 325.515 970.352 333.299 1006.01 358.578C1031.8 376.874 1041.53 401.113 1050.95 424.262C1053.2 429.794 1055.49 435.313 1057.88 440.823C1071.99 471.474 1094.38 499.241 1134.34 519.612C1202.23 554.224 1295.55 565.279 1379.58 572.377C1408.5 574.587 1437.97 575.997 1466.95 573.294C1503.73 570.036 1535.76 558.282 1547.85 535.217C1558.92 514.085 1554.69 490.468 1552.04 468.708C1549.42 446.78 1543.03 419.531 1561.87 399.568C1585.09 374.491 1600.53 347.545 1614.89 320.051C1626.7 297.462 1638.51 274.936 1658.52 254.62C1423.6 258.964 1188.73 264.769 954.24 274.974C934.892 275.811 915.551 276.628 896.203 277.44C872.047 278.455 847.892 279.478 823.744 280.551C691.757 286.378 559.477 288.71 427.237 290.996C390.192 291.636 353.147 292.275 316.109 293.021C203.909 295.26 91.683 296.43 -20.5566 297.247C-105.139 297.862 -191.38 296.363 -275.423 303.469C-307.627 306.218 -339.785 310.634 -370.991 316.33C-389.813 319.765 -433.323 325.381 -440.2 339.55C-441.818 346.48 -427.99 350.02 -420.273 352.415C-367.662 367.2 -301.668 368.328 -245.043 368.993C-228.364 369.128 -209.949 370.096 -193.623 367.377C-192.085 367.553 -191.32 367.642 -189.788 367.823C-207.458 370.862 -227.386 369.873 -245.475 369.734C-303.333 369.048 -370.838 367.861 -424.607 352.765C-432.564 350.289 -446.772 346.644 -445.087 339.504C-438.096 325.099 -393.967 319.382 -374.826 315.884C-343.154 310.095 -310.517 305.608 -277.833 302.817C-193.084 295.652 -106.151 297.117 -20.8629 296.502C91.237 295.685 203.317 294.519 315.377 292.288C352.435 291.543 389.5 290.903 426.571 290.263C558.518 287.986 690.505 285.658 822.206 279.848C846.395 278.775 870.589 277.748 894.784 276.737C914.112 275.925 933.44 275.108 952.762 274.271C1187.95 264.037 1423.53 258.227 1659.15 253.87C1706 209.1 1791.88 198.041 1871.31 194.488C1925.14 192.287 1979.46 198.673 2031.37 207.147C2106.71 219.448 2179.61 237.28 2251.1 256.535C2259.41 258.796 2267.7 261.077 2275.99 263.372C2435.17 277.6 2591.33 301.65 2746.3 328.323C2872.93 350.256 2998.82 375.371 3119.38 408.463C3199.21 430.375 3282.3 455.566 3347.06 493.125C3360.95 501.338 3373.83 509.993 3386.17 519.141C3411.62 538.804 3437.55 563.448 3437.22 589.952H3437.34H3437.33ZM2280.62 264.63C2431.6 307.031 2577.44 356.419 2721.93 406.944C2797.23 433.296 2872.13 460.087 2947.03 486.894C3040.95 520.521 3134.62 554.582 3230.42 586.058C3262.74 596.679 3295.35 607.161 3329.02 616.006C3346.72 620.658 3368.1 627.153 3387.84 626.353C3414.58 624.951 3430.5 609.872 3432.25 593.976C3435.82 566.218 3408.01 539.697 3381.59 519.271C3369.26 510.14 3356.41 501.494 3342.54 493.293C3277.9 455.806 3194.95 430.669 3115.27 408.796C2994.92 375.762 2869.24 350.689 2742.83 328.795C2590.52 302.572 2437.06 278.872 2280.68 264.618C2280.66 264.618 2280.65 264.622 2280.62 264.626L2280.62 264.63ZM1664.26 253.786C1694.13 253.243 1723.99 252.713 1753.86 252.199C1760.58 252.081 1767.31 251.968 1774.03 251.85C1893.81 249.762 2013.67 247.741 2133.28 253.487C2178.22 255.79 2223 258.85 2267.68 262.648C2196.21 242.938 2123.47 224.588 2048.35 211.188C1991.77 201.098 1931.89 192.813 1872.74 195.221C1794.49 198.732 1710.45 209.799 1664.26 253.799V253.79V253.786Z" fill="url(#paint4_linear_1779_1730)" style=""/>\n<path d="M3465.18 585.035C3465.18 587.447 3464.94 589.8 3464.51 592.099C3460.96 610.032 3440.79 623.566 3411.91 625.099C3391.51 626.059 3369.77 620.19 3351.23 615.593C3318.21 607.405 3286.27 597.445 3254.65 587.317C3154.64 555.272 3057.1 520.117 2959.22 485.577C2888.05 460.453 2816.85 435.359 2745.33 410.636C2593.64 358.242 2440.55 306.761 2281.44 263.852C2262.91 258.901 2244.31 254.077 2225.62 249.379C2213.34 248.646 2201.05 247.968 2188.74 247.345C2074.76 242.016 1960.64 245.131 1846.62 248.339C1834.03 248.697 1821.46 249.042 1808.87 249.387C1802.32 249.568 1795.76 249.749 1789.21 249.926C1763.92 250.616 1738.64 251.311 1713.35 252.014C1686.16 272.7 1672.24 298.969 1658.16 323.932C1643.03 350.731 1626.8 376.949 1603.02 401.231C1584.01 420.322 1589.02 446.666 1590.77 467.997C1592.54 489.252 1595.71 512.308 1583.88 532.7C1570.67 555.449 1537.82 566.71 1501.24 569.926C1470.84 572.73 1439.88 571.299 1409.54 568.962C1324.47 561.785 1231.16 550.574 1161.42 516.619C1120.36 496.636 1095.65 469.302 1079 438.777C1076.23 433.427 1073.54 428.064 1070.89 422.688C1059.82 400.052 1048.08 376.785 1021.99 359.071C985.499 334.293 930.771 325.962 879.571 321.891C616.988 302.943 353.067 318.313 91.5766 336.553C24.338 341.239 -43.0337 346.492 -110.632 348.559C-111.005 348.269 -111.191 348.121 -111.564 347.831C-44.312 345.777 22.7069 340.548 89.5992 335.88C352.482 317.555 617.761 302.173 881.742 321.23C933.194 325.301 988.948 333.202 1026.01 357.947C1052.78 375.825 1064.48 399.636 1075.72 422.633C1078.36 428.005 1081.06 433.364 1083.83 438.714C1100.38 469.087 1124.93 496.337 1165.75 516.249C1234.93 549.993 1327.38 561.183 1411.83 568.314C1440.62 570.537 1469.91 571.943 1498.76 569.295C1534.71 566.146 1566.73 554.793 1579.39 532.41C1590.91 512.056 1587.79 489.176 1586.02 468.01C1584.25 446.633 1579.21 420.238 1598.33 401.122C1622.11 376.861 1638.27 350.651 1653.38 323.874C1667.45 298.994 1681.33 272.827 1708.34 252.161C1473.03 258.682 1237.78 266.024 1002.95 277.731C981.052 278.826 959.147 279.87 937.236 280.909C914.998 281.966 892.76 283.031 870.529 284.142C727.81 291.189 584.617 293.063 441.545 294.936C410.252 295.349 378.967 295.757 347.681 296.241C224.562 298.102 101.477 298.005 -21.655 297.007C-92.4622 296.435 -164.728 294.115 -235.189 299.815C-267.999 302.526 -300.743 307.262 -332.355 313.4C-352.289 317.273 -393.954 323.339 -402.003 337.812C-404.034 344.35 -392.25 348.846 -384.367 351.253C-358.82 359.635 -328.593 362.906 -300.456 365.596C-270.296 368.48 -239.649 370.222 -209.129 370.294C-198.976 370.248 -187.158 370.82 -177.451 368.547C-175.72 368.677 -174.854 368.745 -173.117 368.879C-184.142 371.553 -197.678 370.984 -209.189 371.035C-240.482 370.959 -271.914 369.187 -302.847 366.232C-331.676 363.478 -362.628 360.144 -388.754 351.561C-396.597 349.035 -409.327 344.535 -406.824 337.749C-398.701 323.048 -356.33 316.881 -336.13 312.958C-304.025 306.723 -270.789 301.907 -237.472 299.154C-166.166 293.374 -93.0681 295.681 -21.402 296.262C101.484 297.26 224.323 297.352 347.195 295.496C378.501 295.02 409.813 294.604 441.125 294.191C583.832 292.322 726.651 290.449 868.998 283.435C891.269 282.324 913.547 281.259 935.824 280.202C957.709 279.167 979.593 278.114 1001.48 277.024C1237.14 265.275 1473.25 257.92 1709.4 251.378C1758.39 214.379 1838.01 205.627 1910.19 202.563C2018.55 198.184 2129.93 224.323 2229.04 248.785C2423.9 261.069 2612.93 292.116 2800.54 326.463C2924.7 349.309 3048.15 375.093 3166.24 408.619C3242.25 430.202 3322.39 454.846 3383.04 491.832C3396.21 500.045 3408.33 508.705 3419.92 517.819C3443.11 536.876 3465.77 560.122 3465.46 585.056C3465.36 585.052 3465.3 585.048 3465.2 585.043L3465.18 585.035ZM2233.1 249.833C2411.45 294.709 2581.51 352.234 2749.78 410.316C2821.3 435.039 2892.5 460.142 2963.67 485.257C3058.8 518.833 3153.68 552.843 3250.67 584.235C3283.44 594.839 3316.49 605.301 3350.59 614.107C3368.62 618.763 3390.28 625.221 3410.31 624.387C3437.68 622.775 3456.25 609.3 3459.95 592.524C3465.98 565.195 3440.01 538.556 3414.88 517.928C3403.34 508.848 3391.34 500.075 3378.06 491.98C3317.54 455.061 3237.54 430.463 3161.66 408.926C3043.77 375.455 2920.51 349.721 2796.55 326.913C2611.55 293.054 2425.17 262.323 2233.1 249.833ZM1714.28 251.223C1738.95 250.545 1763.61 249.867 1788.27 249.189C1794.83 249.008 1801.38 248.831 1807.94 248.65C1820.51 248.305 1833.06 247.956 1845.63 247.602C1960.44 244.378 2075.33 241.271 2190.11 246.638C2200.51 247.16 2210.89 247.724 2221.28 248.33C2124.57 224.554 2016.75 199.351 1911.1 203.278C1840.21 206.292 1762.43 215.027 1714.21 251.231C1714.24 251.231 1714.24 251.227 1714.27 251.223H1714.28Z" fill="url(#paint5_linear_1779_1730)" style=""/>\n<path d="M3493.34 580.084C3493.34 583.562 3492.83 586.938 3491.9 590.188C3486.6 608.635 3463.83 621.546 3434.37 623.12C3415.71 624.021 3396.12 619.256 3378.97 615.244C3346.66 607.683 3315.46 598.174 3284.62 588.525C3179.9 555.773 3077.88 519.524 2975.55 483.939C2908.18 460.516 2840.8 437.102 2773.16 414.007C2582.09 348.883 2387.7 282.147 2181.25 238.4C2092.52 236.985 2003.94 240.408 1915.42 243.834C1898.04 244.504 1880.66 245.177 1863.27 245.83C1831.03 247.025 1798.8 248.208 1766.56 249.395C1730.94 270.347 1713.49 299.68 1696.39 327.721C1680.55 353.804 1663.49 379.273 1639.22 402.738C1619.96 420.983 1623.71 446.481 1624.61 467.243C1625.53 487.9 1627.62 510.212 1615.36 529.821C1601.57 551.884 1568.71 562.74 1532.92 565.856C1502.63 568.617 1471.81 567.194 1441.59 564.862C1356.12 557.617 1263.62 546.255 1192.64 513.167C1150.72 493.63 1123.89 466.818 1104.74 436.647C1101.62 431.457 1098.58 426.249 1095.58 421.029C1082.67 398.583 1069.02 375.708 1041.95 358.389C1004.08 334.154 949.442 325.705 897.696 321.545C637.284 302.534 375.547 316.923 116.013 334.297C50.2862 338.696 -15.5609 343.63 -81.621 345.528C-81.9672 345.238 -82.1403 345.09 -82.4865 344.8C-16.7793 342.914 48.7216 337.993 114.096 333.619C374.994 316.157 638.083 301.764 899.86 320.885C951.865 325.044 1007.45 333.076 1045.88 357.273C1073.63 374.752 1087.3 398.154 1100.4 420.962C1103.41 426.178 1106.44 431.381 1109.56 436.567C1128.61 466.595 1155.27 493.297 1196.92 512.792C1267.27 545.708 1359.09 557.019 1443.89 564.21C1472.54 566.437 1501.71 567.847 1530.44 565.22C1565.81 562.151 1597.38 551.24 1610.78 529.501C1622.81 509.984 1620.71 487.774 1619.8 467.248C1618.9 446.426 1615.15 420.899 1634.47 402.608C1658.73 379.126 1675.69 353.712 1691.64 327.645C1708.66 299.71 1726.06 270.549 1761.37 249.585C1759.15 249.669 1758.04 249.711 1755.81 249.795C1520.83 258.392 1285.88 267.32 1051.41 280.442C1027.63 281.764 1003.85 283.031 980.068 284.29C959.069 285.397 938.07 286.517 917.078 287.674C765.057 295.95 612.357 297.243 459.87 298.619C432.912 298.864 405.954 299.104 379.002 299.394C250.045 300.75 121.253 299.205 -7.598 295.963C-69.7499 294.397 -133.22 291.345 -195.206 296.115C-227.63 298.632 -260.054 303.726 -291.14 309.977C-312.831 314.338 -354.284 320.864 -364.004 336.027C-366.841 342.417 -356.308 347.321 -348.658 350.054C-323.651 359.664 -292.738 363.596 -264.248 366.678C-237.29 369.595 -209.593 371.658 -182.209 371.485C-175.551 371.468 -167.362 371.713 -161.297 369.679C-159.439 369.763 -158.514 369.806 -156.656 369.886C-164.1 372.47 -173.834 372.066 -182.023 372.222C-211.657 372.411 -241.558 370.201 -270.687 366.871C-298.497 363.689 -328.731 359.715 -353.179 350.319C-361.035 347.528 -371.788 342.506 -368.898 335.96C-359.45 321.28 -319.929 314.709 -298.89 310.306C-266.046 303.431 -231.798 298.161 -197.443 295.454C-134.452 290.608 -70.0229 293.648 -6.86564 295.235C121.613 298.476 250.038 300.013 378.623 298.657C405.601 298.367 432.579 298.123 459.557 297.883C611.584 296.515 763.832 295.222 915.4 286.984C936.412 285.826 957.431 284.706 978.45 283.599C1002.21 282.345 1025.97 281.078 1049.73 279.752C1284.39 266.617 1519.52 257.676 1754.68 249.075C1757.42 248.97 1760.08 248.878 1762.8 248.781C1812.79 220.033 1883.66 213.217 1948.61 210.62C2028.58 207.808 2108.97 222.083 2184.16 237.722C2205.21 238.151 2226.22 238.837 2247.22 239.801C2455.61 250.119 2655.31 285.923 2854.23 324.585C2976.13 348.353 3097.52 374.634 3213.32 408.686C3285.5 429.916 3361.99 454.164 3418.49 490.51C3430.9 498.736 3442.42 507.341 3453.13 516.476C3474.2 534.965 3493.42 556.62 3493.48 580.093C3493.43 580.084 3493.4 580.08 3493.36 580.072L3493.34 580.084ZM2187.94 238.53C2232.61 248.099 2276.54 258.897 2320.04 270.406C2476.89 312.335 2627.84 362.636 2777.61 413.704C2845.26 436.807 2912.66 460.2 2980.02 483.636C3076.4 517.158 3172.53 551.126 3270.77 582.425C3303.67 592.907 3336.84 603.234 3371.03 611.943C3389.65 616.688 3412.1 623.31 3432.76 622.421C3460.64 620.767 3481.44 608.104 3487.12 590.958C3495.97 564.269 3471.93 537.352 3448.23 516.585C3437.5 507.48 3426.04 498.871 3413.63 490.666C3357.22 454.391 3280.87 430.185 3208.81 408.994C3093.2 374.996 2972.01 348.757 2850.31 325.023C2652.16 286.538 2453.22 250.776 2245.64 240.492C2226.44 239.612 2207.23 238.964 2187.99 238.534C2187.96 238.534 2187.95 238.53 2187.93 238.526L2187.94 238.53ZM1767.98 248.57C1799.36 247.421 1830.73 246.268 1862.09 245.101C1879.46 244.453 1896.82 243.784 1914.18 243.106C2001.82 239.713 2089.51 236.333 2177.35 237.575C2104.76 222.546 2026.79 208.536 1949.57 211.314C1886.23 213.857 1816.75 220.529 1767.92 248.558C1767.95 248.558 1767.96 248.562 1767.98 248.566V248.57Z" fill="url(#paint6_linear_1779_1730)" style=""/>\n<path d="M3521.67 575.075C3521.77 579.398 3520.95 584.075 3519.32 588.281C3512.13 607.384 3487.32 619.508 3456.82 621.159C3437.62 622.097 3417.45 617.239 3399.77 613.152C3367.29 605.646 3335.9 596.241 3304.85 586.685C3198.74 554.035 3095.31 517.831 2991.57 482.301C2928.12 460.558 2864.63 438.857 2800.94 417.388C2688.28 379.48 2575.11 342.055 2459.3 308.1C2357.91 278.371 2253.73 250.065 2145.24 232.376C2090.42 233.82 2035.72 236.522 1981.02 239.204C1959.88 240.239 1938.73 241.275 1917.59 242.268C1886.99 243.7 1856.38 245.097 1825.77 246.482C1778.26 266.47 1755.78 299.356 1734.69 331.502C1717.95 356.861 1700.21 381.538 1675.42 404.22C1655.95 421.661 1658.42 446.224 1658.45 466.477C1658.49 486.499 1659.54 508.124 1646.79 526.899C1632.25 548.301 1599.88 558.733 1564.64 561.772C1534.45 564.5 1503.74 563.077 1473.63 560.741C1387.83 553.441 1295.93 541.953 1223.82 509.698C1181.02 490.553 1152.12 464.28 1130.46 434.496C1126.96 429.419 1123.52 424.33 1120.12 419.223C1105.4 397 1089.88 374.546 1061.82 357.623C1022.59 333.947 968.037 325.414 915.746 321.188C657.544 302.017 397.964 315.463 140.434 332.002C76.2052 336.124 11.8562 340.767 -52.6793 342.485C-52.9988 342.194 -53.1586 342.047 -53.4848 341.756C10.6978 340.039 74.6939 335.421 138.577 331.321C397.464 314.705 658.356 301.251 917.909 320.527C970.427 324.753 1025.96 332.878 1065.7 356.507C1094.41 373.578 1110 396.588 1124.95 419.152C1128.35 424.254 1131.78 429.343 1135.28 434.42C1156.82 464.069 1185.55 490.262 1228.11 509.332C1299.66 541.393 1390.7 552.848 1475.91 560.097C1504.45 562.324 1533.5 563.734 1562.12 561.145C1596.71 558.173 1628.25 547.653 1642.23 526.596C1654.66 507.867 1653.65 486.41 1653.57 466.49C1653.59 446.191 1651.1 421.598 1670.58 404.11C1695.38 381.45 1713.12 356.793 1729.81 331.438C1750.79 299.508 1773.11 266.845 1820.01 246.748C1796.52 247.813 1773.03 248.869 1749.53 249.934C1532.74 259.705 1315.97 269.77 1099.64 283.153C1074.18 284.723 1048.7 286.209 1023.22 287.691C1003.26 288.849 983.29 290.015 963.33 291.206C802.754 300.737 641.225 301.352 480.076 302.173C456.727 302.29 433.377 302.408 410.035 302.56C277.715 303.36 145.814 300.341 13.8403 294.536C-42.2329 292.073 -99.4713 288.314 -155.578 292.419C-188.508 294.894 -221.385 300.278 -252.77 306.942C-275.727 311.813 -315.209 318.784 -326.354 334.238C-329.843 340.477 -320.668 345.739 -313.238 348.841C-290.921 358.936 -261.938 363.529 -235.54 367.065C-210.912 370.361 -185.053 373.005 -159.786 372.672C-151.25 372.55 -146.357 371.915 -145.431 370.791C-143.5 370.829 -142.535 370.85 -140.604 370.888C-145.697 373.363 -153.088 373.384 -159.293 373.401C-185.525 373.75 -212.31 371.161 -237.91 367.781C-265.101 364.19 -294.849 359.454 -317.825 349.069C-325.409 345.886 -334.663 340.523 -331.128 334.162C-319.809 318.477 -279.662 311.413 -256.366 306.479C-224.474 299.722 -191.085 294.258 -157.628 291.745C-100.39 287.573 -42.0132 291.303 15.1918 293.816C146.646 299.596 278.034 302.61 409.835 301.815C433.204 301.663 456.574 301.545 479.943 301.427C640.553 300.619 801.548 300.009 961.585 290.52C981.566 289.316 1001.55 288.154 1021.54 286.992C1046.98 285.519 1072.41 284.033 1097.83 282.467C1314.3 269.072 1531.21 258.994 1748.14 249.219C1772.78 248.112 1797.41 246.996 1822.04 245.88C1870.29 225.817 1930.44 220.774 1986.8 218.656C2040.41 216.737 2094.28 223.38 2146.01 231.597C2198.66 230.376 2251.23 230.587 2303.8 232.931C2507.16 242.837 2700.63 280.084 2893.55 319.756C2899.25 320.923 2902.09 321.508 2907.78 322.678C3026.97 347.258 3145.72 374.154 3258.76 408.644C3327.37 429.583 3401.18 453.381 3453.77 489.172C3465.49 497.397 3476.21 506.015 3486.19 515.112C3505.06 532.852 3521.55 553.151 3521.6 575.062C3521.63 575.071 3521.63 575.075 3521.66 575.083L3521.67 575.075ZM2150.17 232.266C2258.83 250.128 2363.2 278.405 2464.82 308.192C2580.24 342.022 2693.04 379.311 2805.32 417.093C2869.01 438.563 2932.48 460.281 2995.95 482.007C3092.51 515.082 3188.85 548.541 3287.23 579.424C3321.65 590.23 3356.36 600.868 3392.1 609.855C3411.12 614.638 3434.09 621.373 3455.14 620.468C3483.48 618.776 3506.7 606.858 3514.29 589.417C3525.63 563.342 3503.86 536.261 3481.5 515.247C3471.51 506.175 3460.85 497.557 3449.13 489.344C3396.65 453.612 3322.96 429.861 3254.46 408.964C3141.59 374.529 3023.01 347.679 2903.99 323.133C2898.3 321.962 2895.46 321.381 2889.77 320.211C2697.67 280.711 2505 243.519 2302.51 233.651C2251.76 231.395 2201 231.151 2150.16 232.27L2150.17 232.266ZM1827.92 245.632C1857.35 244.289 1886.79 242.942 1916.22 241.565C1937.35 240.572 1958.46 239.541 1979.58 238.505C2033.43 235.857 2087.29 233.209 2141.26 231.727C2091.29 223.868 2039.73 217.747 1988 219.38C1933.21 221.447 1875.02 226.394 1827.91 245.624V245.632H1827.92Z" fill="url(#paint7_linear_1779_1730)" style=""/>\n<path d="M3550.38 569.985C3550.4 575.513 3549.28 581.053 3546.8 586.357C3537.71 605.806 3510.56 617.458 3479.34 619.176C3459.48 620.144 3438.58 615.05 3420.27 610.853C3386.74 603.171 3354.27 593.585 3322.14 583.848C3215.58 551.555 3111.6 515.802 3007.36 480.651C2947.91 460.605 2888.46 440.571 2828.83 420.756C2702.89 378.949 2576.3 337.639 2446.1 301.347C2338.54 271.37 2225.85 242.066 2108.98 230.721C2087.69 231.921 2066.4 233.18 2045.12 234.447C2020.78 235.891 1996.45 237.33 1972.1 238.703C1947.56 240.075 1923.02 241.422 1898.47 242.757C1832.07 259.916 1801.13 295.963 1773.23 335.299C1755.72 359.934 1737.15 383.841 1711.86 405.723C1692.22 422.351 1693.41 446.031 1692.55 465.728C1691.75 485.147 1691.71 506.023 1678.58 524.015C1663.46 544.715 1631.17 554.755 1596.69 557.697C1566.62 560.387 1536.04 558.969 1506.04 556.628C1419.62 549.248 1327.96 537.693 1254.52 506.166C1210.95 487.463 1180.3 461.729 1156.57 432.353C1152.37 427.121 1148.32 421.838 1144.26 416.559C1127.62 394.799 1110.16 372.946 1081.25 356.566C1040.86 333.686 986.669 325.12 934.198 320.834C678.193 301.592 420.803 314.056 165.258 329.712C102.52 333.556 39.6692 337.883 -23.3416 339.449C-23.6412 339.159 -23.7877 339.012 -24.0873 338.721C38.5707 337.172 101.075 332.853 163.46 329.03C420.331 313.286 679.018 300.825 936.355 320.173C989.079 324.459 1044.1 332.634 1084.97 355.476C1114.55 372.007 1132.11 394.361 1149.02 416.47C1153.08 421.749 1157.13 427.032 1161.33 432.265C1184.92 461.493 1215.39 487.13 1258.7 505.787C1331.5 537.15 1422.54 548.659 1508.28 555.984C1536.72 558.211 1565.65 559.625 1594.17 557.07C1628.18 554.182 1659.29 544.083 1673.98 523.704C1686.87 505.8 1686.86 485.021 1687.66 465.736C1688.52 445.984 1687.35 422.275 1707.03 405.596C1732.32 383.731 1750.84 359.824 1768.41 335.219C1795.95 296.409 1826.45 260.614 1891.48 243.14C1846.73 245.565 1801.97 247.943 1757.21 250.326C1554.13 261.119 1351.07 272.162 1148.42 285.868C1121.55 287.674 1094.67 289.383 1067.79 291.076C1048.59 292.288 1029.38 293.505 1010.18 294.755C841.492 305.57 671.435 305.431 502.057 305.637C481.923 305.662 461.796 305.688 441.663 305.73C307.392 305.97 173.927 301.52 40.3949 292.894C-11.0044 289.577 -63.6155 285.06 -115.288 288.735C-149.19 291.156 -182.986 296.974 -215.03 304.256C-238.36 309.561 -276.217 317.075 -288.108 332.474C-292.103 338.561 -284.44 344.122 -277.282 347.654C-257.888 358.061 -231.416 363.398 -207.254 367.431C-185.17 371.119 -161.587 374.268 -138.617 373.906C-132.186 373.775 -128.903 373.114 -128.903 371.931H-124.076C-124.076 373.493 -129.03 374.457 -137.998 374.634C-161.96 375.085 -186.594 371.936 -209.664 368.16C-234.645 364.076 -261.956 358.595 -281.983 347.852C-289.253 344.236 -297.03 338.578 -292.935 332.386C-280.898 316.772 -242.348 309.156 -218.706 303.797C-186.135 296.414 -151.78 290.52 -117.332 288.062C-64.3678 284.298 -10.4518 288.815 42.2458 292.212C175.132 300.804 307.964 305.233 441.596 304.993C461.73 304.947 481.857 304.917 501.99 304.896C670.743 304.694 840.187 304.85 1008.26 294.073C1027.48 292.823 1046.7 291.61 1065.93 290.398C1092.77 288.706 1119.61 287.005 1146.43 285.199C1349.21 271.488 1552.39 260.433 1755.59 249.635C1802.13 247.164 1848.66 244.689 1895.19 242.167C1936.54 231.677 1981.34 228.267 2025.51 226.722C2053.86 226.061 2081.84 227.408 2109.91 229.9C2193.51 225.299 2277.04 222.458 2360.89 226.091C2557.56 235.516 2743.45 273.256 2928.78 313.644C2939.77 316.035 2950.77 318.43 2961.77 320.809C3078.46 346.223 3194.9 373.603 3305.38 408.598C3370.45 429.209 3440.85 452.699 3489.52 487.871C3500.54 496.101 3510.44 504.739 3519.7 513.79C3536.4 530.709 3550.35 549.653 3550.4 569.998V569.977L3550.38 569.985ZM2115.04 230.401C2230.37 241.894 2341.43 270.448 2447.67 300.055C2578.85 336.608 2706.3 378.343 2833.16 420.461C2892.8 440.272 2952.25 460.306 3011.69 480.357C3109.61 513.382 3207.34 546.798 3307.08 577.597C3341.67 588.277 3376.54 598.771 3412.38 607.675C3432.12 612.575 3455.82 619.424 3477.61 618.49C3507.97 616.675 3533.54 605.061 3542.32 586.252C3554.02 561.2 3535.5 534.805 3514.85 513.895C3505.65 504.836 3495.74 496.227 3484.72 488.014C3436.15 452.905 3365.87 429.461 3300.91 408.888C3190.59 373.944 3074.3 346.602 2957.78 321.226C2946.79 318.83 2935.8 316.443 2924.81 314.052C2740.31 273.866 2555.23 236.181 2359.44 226.785C2277.8 223.253 2196.45 225.952 2115.04 230.384V230.405L2115.04 230.401ZM1902.38 241.772C1925.04 240.538 1947.71 239.288 1970.37 238.017C1994.69 236.644 2019 235.205 2043.32 233.765C2063.43 232.569 2083.54 231.378 2103.65 230.237C2078.03 228.035 2052.3 226.684 2026.43 227.438C1984.42 228.915 1941.88 232.127 1902.37 241.767L1902.38 241.772Z" fill="url(#paint8_linear_1779_1730)" style=""/>\n<path d="M3579.28 564.828C3578.86 571.703 3577.34 577.874 3574.14 584.454C3563.08 604.202 3533.73 615.446 3501.68 617.227C3481.8 618.207 3460.84 613.274 3442.45 609.157C3408.13 601.478 3374.9 591.842 3342 582.038C3233.92 549.829 3128.41 514.127 3022.64 479.031C2967.32 460.68 2912.01 442.343 2856.56 424.157C2712.3 376.937 2567.27 329.877 2416.77 291C2354.77 274.982 2291.62 260.29 2226.79 249.488C2174.25 240.732 2119.37 233.954 2064.78 235.508C2003.37 237.486 1936.69 243.266 1887.35 268.579C1851.53 286.963 1831.19 313.438 1811.46 339.15C1793.14 363.053 1773.75 386.215 1747.91 407.268C1728.13 423.092 1728.02 445.888 1726.26 465.033C1724.57 483.825 1723.51 503.998 1709.92 521.17C1694.09 541.17 1662.25 550.814 1628.3 553.677C1598.3 556.325 1567.82 554.906 1537.9 552.561C1451.17 545.123 1359.9 533.449 1285.41 502.74C1240.92 484.394 1208.28 459.169 1182.12 430.261C1177.5 425.146 1173.02 419.977 1168.57 414.795C1150.08 393.329 1130.77 371.881 1100.86 355.863C1059.24 333.568 1005.08 324.892 952.124 320.531C698.316 301.208 443.11 312.688 189.563 327.469C128.316 331.034 66.9698 335.071 5.48365 336.456C5.21067 336.166 5.07754 336.018 4.80456 335.728C65.9445 334.335 126.938 330.327 187.831 326.774C442.691 311.918 699.175 300.451 954.294 319.874C1007.5 324.244 1062.44 332.537 1104.52 354.79C1135.1 370.959 1154.56 392.887 1173.33 414.702C1177.78 419.88 1182.26 425.049 1186.88 430.168C1212.91 458.946 1245.36 484.082 1289.61 502.373C1363.52 532.915 1454.09 544.546 1540.2 551.934C1568.55 554.169 1597.39 555.584 1625.83 553.058C1659.18 550.01 1690.01 540.719 1705.37 520.879C1718.63 503.75 1719.69 483.729 1721.37 465.05C1723.15 445.85 1723.27 423.025 1743.09 407.15C1768.9 386.114 1788.28 362.969 1806.57 339.092C1826.46 313.193 1846.98 286.571 1883.2 268.133C1933.47 242.542 2001.44 236.813 2063.79 234.805C2118.54 233.247 2173.53 239.839 2226.29 248.499C2292.19 259.309 2356.36 274.153 2419.36 290.368C2570.48 329.27 2716.05 376.478 2860.83 423.871C2916.3 442.052 2971.63 460.407 3026.97 478.753C3126.32 511.727 3225.48 545.098 3326.65 575.812C3362.15 586.588 3397.93 597.197 3434.74 606.1C3454.48 610.878 3478.23 617.606 3499.93 616.566C3530.77 614.84 3558.66 603.238 3569.24 584.425C3583.32 560.257 3567.16 533.63 3548.08 512.594C3539.6 503.573 3530.49 494.96 3520.17 486.738C3475.42 452.24 3408.42 429.066 3346.87 408.808C3239.22 373.375 3125.34 345.549 3011.43 319.386C2995.87 315.816 2980.33 312.234 2964.77 308.66C2786.25 267.501 2607.15 229.008 2416.29 219.999C2312.98 215.625 2210.44 222.516 2107.84 229.66C2080.69 231.55 2053.54 233.428 2026.37 235.209C1941.13 240.757 1855.85 245.943 1770.56 251.138C1579.16 262.803 1387.8 274.675 1196.78 288.647C1168.63 290.697 1140.44 292.625 1112.26 294.536C1093.72 295.795 1075.17 297.058 1056.63 298.354C880.025 310.495 701.652 309.518 524.251 309.076C507.133 309.03 490.009 308.992 472.891 308.963C337.509 308.647 203.398 302.854 69.3334 291.164C21.6758 287.009 -27.1869 281.835 -75.3904 285.106C-108.407 287.359 -141.417 293.433 -172.53 300.585C-197.957 306.433 -236.466 314.473 -250.195 330.752C-254.942 336.721 -248.377 342.514 -241.719 346.501C-224.828 357.391 -200.387 363.533 -177.843 368.075C-159.154 371.839 -138.461 375.489 -118.647 375.181C-113.88 375.059 -111.843 374.352 -112.768 373.093C-110.837 373.064 -109.872 373.047 -107.941 373.018C-106.396 375.278 -113.507 375.804 -117.841 375.91C-139.42 376.318 -161.771 372.597 -182.131 368.467C-204.801 363.866 -229.442 357.635 -246.42 346.673C-253.257 342.602 -259.469 336.663 -255.022 330.66C-241.42 314.473 -203.602 306.315 -178.349 300.413C-145.998 292.856 -111.69 286.752 -77.3146 284.424C-27.613 281.061 22.6012 286.243 71.7435 290.524C205.029 302.143 338.354 307.914 472.951 308.226C490.069 308.255 507.187 308.293 524.304 308.34C700.999 308.782 878.68 309.784 1054.58 297.685C1073.14 296.388 1091.71 295.121 1110.27 293.867C1138.41 291.96 1166.55 290.032 1194.67 287.99C1385.78 274.014 1577.25 262.13 1768.75 250.46C1853.99 245.266 1939.23 240.084 2024.42 234.539C2051.56 232.759 2078.67 230.894 2105.79 228.999C2209.53 221.776 2313.19 214.876 2417.65 219.3C2609.44 228.343 2789.4 266.878 2968.8 308.26C2984.34 311.846 2999.89 315.425 3015.45 318.99C3129.52 345.191 3243.54 373.055 3351.33 408.543C3412.99 428.842 3480.07 452.063 3524.94 486.612C3535.29 494.846 3544.38 503.48 3552.91 512.502C3567.45 528.52 3579.17 546.099 3579.21 564.879C3579.24 564.858 3579.24 564.845 3579.27 564.82L3579.28 564.828Z" fill="url(#paint9_linear_1779_1730)" style=""/>\n<path d="M3608.42 559.684C3608.47 591.051 3572.5 612.546 3524.21 615.257C3503.7 616.284 3482.1 611.253 3463.09 607.06C3428.55 599.441 3395.06 589.91 3361.89 580.198C3252.19 548.082 3145.06 512.418 3037.67 477.368C2986.63 460.702 2935.57 444.056 2884.41 427.533C2742.9 381.866 2600.76 336.423 2453.5 298.54C2387.8 281.806 2320.96 266.369 2252.13 255.571C2203.66 247.968 2153.36 242.268 2103.23 243.561C2042.57 245.358 1977 250.827 1927.52 275.096C1891.74 292.65 1870.5 318.106 1849.89 342.977C1830.73 366.135 1810.55 388.53 1784.18 408.766C1764.23 423.825 1762.88 445.656 1760.24 464.292C1757.66 482.474 1755.5 501.894 1741.56 518.29C1725.04 537.718 1693.55 546.596 1660.24 549.606C1630.32 552.216 1599.94 550.798 1570.1 548.453C1483.05 540.96 1392.16 529.177 1316.66 499.271C1271.17 481.253 1236.59 456.542 1208 428.114C1202.99 423.096 1198.08 418.04 1193.21 412.972C1172.85 391.818 1151.7 370.791 1120.78 355.114C1077.95 333.392 1023.79 324.619 970.327 320.161C924.234 316.608 878.008 314.002 831.662 312.213C736.746 313.37 641.824 312.916 546.908 312.343C532.673 312.259 518.445 312.179 504.211 312.099C502.167 312.091 500.063 312.078 498.019 312.061C403.23 315.004 308.667 319.942 214.131 325.153C154.389 328.445 94.5339 332.221 34.5658 333.413C34.3194 333.118 34.1929 332.971 33.9466 332.676C93.5818 331.485 153.11 327.721 212.519 324.45C301.29 319.546 390.087 314.89 479.084 311.897C351.551 310.491 225.809 303.309 100.28 289.236C55.5383 284.231 10.1444 278.636 -35.4758 281.372C-68.3794 283.498 -101.316 289.804 -132.169 297.113C-159.127 303.494 -197.018 312.124 -212.258 328.934C-217.324 334.735 -212.178 340.797 -206.066 345.259C-183.988 363.129 -137.855 374.331 -102.921 376.293C-101.19 376.39 -98.8994 376.453 -97.5412 376.272C-96.6091 376.15 -94.5718 375.687 -96.5492 374.154C-94.645 374.095 -93.6929 374.07 -91.7821 374.011C-89.9911 375.421 -90.85 376.364 -94.3787 376.827C-96.1098 377.055 -99.2656 377.274 -104.525 376.987C-140.611 374.95 -188.023 363.878 -210.826 345.398C-218.157 340.03 -220.32 335.539 -217.078 328.837C-202.151 312.381 -164.966 303.709 -138.634 297.298C-106.33 289.43 -71.8282 282.909 -37.2668 280.695C9.98463 277.883 56.7833 283.465 103.129 288.655C233.838 303.301 364.807 310.327 497.593 311.324C609.073 308.007 720.7 307.43 832.161 311.476C921.963 310.268 1011.8 307.729 1101.08 301.2C1119.02 299.866 1136.96 298.556 1154.9 297.247C1184.31 295.109 1213.71 292.962 1243.08 290.667C1422.91 276.561 1603.04 264.045 1783.19 251.702C1881.71 244.958 1980.24 238.227 2078.66 230.944C2108.3 228.73 2137.9 226.394 2167.51 224.032C2269.6 215.895 2371.54 208.153 2474.59 212.396C2662.79 221.123 2837.98 260.669 3012.61 303.267C3031.52 307.877 3050.43 312.486 3069.36 317.058C3180.71 344 3292.22 372.34 3397.2 408.303C3455.59 428.308 3519.44 451.297 3560.59 485.244C3570.21 493.504 3578.45 502.15 3586.32 511.117C3598.83 526.205 3608.38 542.441 3608.4 559.697V559.676L3608.42 559.684ZM846.209 312.019C888.461 313.812 930.592 316.267 972.624 319.517C1026.29 323.97 1081.23 332.369 1124.48 354.045C1156.06 369.869 1177.42 391.393 1198.1 412.875C1202.98 417.939 1207.84 423.008 1212.89 428.009C1241.32 456.307 1275.71 480.929 1320.94 498.884C1395.86 528.625 1486.07 540.362 1572.5 547.805C1600.78 550.04 1629.54 551.454 1657.91 548.966C1690.67 545.999 1721.12 537.087 1737.13 517.958C1750.81 501.62 1752.92 482.352 1755.48 464.28C1758.17 445.593 1759.55 423.724 1779.55 408.623C1805.88 388.4 1826.05 366.017 1845.2 342.889C1865.96 317.824 1887.41 292.208 1923.58 274.607C1974.03 250.069 2040.9 244.66 2102.54 242.837C2220.72 239.781 2340.76 268.449 2448.58 295.782C2599.25 333.981 2744.39 380.616 2888.87 427.226C2940.03 443.749 2991.09 460.398 3042.15 477.06C3143.02 509.993 3243.7 543.325 3346.39 573.964C3382.1 584.618 3418.1 595.088 3455.07 603.899C3475.52 608.774 3500.17 615.665 3522.61 614.57C3554.66 612.777 3584.24 601.722 3596.91 582.48C3612.45 558.796 3599.45 532.746 3581.64 511.222C3573.8 502.268 3565.56 493.638 3555.97 485.387C3514.89 451.495 3451.12 428.552 3392.82 408.581C3287.97 372.668 3176.61 344.366 3065.4 317.454C3046.47 312.882 3027.57 308.272 3008.66 303.663C2834.95 261.292 2660.64 221.797 2473.44 213.112C2371.55 208.902 2270.86 216.644 2169.93 224.693C2140.28 227.063 2110.63 229.399 2080.96 231.614C1982.5 238.901 1883.94 245.628 1785.39 252.38C1605.29 264.719 1425.22 277.222 1245.45 291.324C1216.03 293.618 1186.59 295.77 1157.15 297.912C1139.22 299.213 1121.3 300.518 1103.38 301.853C1018.02 308.1 932.15 310.706 846.283 312.015H846.223L846.209 312.019ZM519.564 311.442C528.765 311.501 537.96 311.548 547.161 311.602C636.797 312.141 726.439 312.583 816.075 311.661C717.285 308.453 618.381 308.824 519.564 311.442Z" fill="url(#paint10_linear_1779_1730)" style=""/>\n<path d="M3638.07 554.388C3638.11 588.117 3597.97 610.382 3546.67 613.291C3525.53 614.364 3503.27 609.245 3483.62 604.981C3448.84 597.428 3415.06 587.986 3381.6 578.367C3270.21 546.344 3161.37 510.709 3052.28 475.705C3005.62 460.744 2958.98 445.774 2912.24 430.926C2770.08 385.765 2627.33 340.569 2479.36 303.414C2374.06 276.973 2256.96 248.962 2141.7 251.635C2081.77 253.256 2017.36 258.413 1967.76 281.638C1932.02 298.367 1909.86 322.813 1888.39 346.837C1868.35 369.233 1847.34 390.863 1820.5 410.303C1800.41 424.561 1797.83 445.534 1794.2 463.598C1790.73 481.173 1787.53 499.826 1773.19 515.436C1756.01 534.14 1724.91 542.648 1692.16 545.573C1662.32 548.158 1632.02 546.731 1602.26 544.374C1514.86 536.817 1424.41 524.921 1347.87 495.836C1301.38 478.168 1264.86 453.911 1233.9 426.014C1228.48 421.113 1223.15 416.167 1217.88 411.2C1195.67 390.383 1172.7 369.764 1140.75 354.411C1096.76 333.265 1042.51 324.396 988.565 319.857C967.679 318.228 946.766 316.776 925.821 315.479C807.143 317.723 688.418 316.751 569.72 315.618C558.375 315.509 547.03 315.404 535.685 315.298C503.887 314.978 472.095 314.41 440.336 313.4C373.111 316.001 305.986 319.378 238.867 322.872C180.597 325.903 122.22 329.384 63.7564 330.424C63.5366 330.129 63.4235 329.982 63.1971 329.687C121.334 328.652 179.378 325.187 237.316 322.173C301.405 318.839 365.508 315.601 429.69 313.05C329.362 309.472 230.764 300.998 132.686 287.329C90.5945 281.478 48.0436 275.281 4.66042 277.718C-29.1886 279.777 -62.9843 286.483 -94.4431 294.397C-121.987 301.326 -157.773 310.478 -174.165 327.195C-177.994 333.728 -176.649 338.296 -170.264 344.097C-153.333 361.31 -112.14 375.632 -80.3616 377.627C-80.1152 377.636 -79.1831 377.686 -78.9368 377.636C-78.8169 377.627 -76.5865 377.278 -80.1152 375.291C-78.2576 375.211 -77.3322 375.173 -75.4746 375.093C-72.5651 376.726 -72.6317 377.741 -75.661 378.174C-76.5931 378.309 -78.6305 378.494 -81.9728 378.318C-114.91 376.343 -157.507 362.123 -175.097 344.202C-181.536 338.346 -182.787 333.678 -178.999 327.081C-162.427 310.137 -125.922 300.897 -98.0251 293.917C-65.9937 285.898 -31.5788 279.12 2.85615 277.02C48.2167 274.835 91.8263 280.648 135.889 286.773C236.277 300.758 337.032 309.291 439.764 312.646C601.865 306.551 764.512 305.233 926.36 314.705C1000.28 313.181 1074.13 310.44 1147.56 304.761C1164.87 303.398 1182.17 302.055 1199.48 300.716C1230.14 298.346 1260.8 295.959 1291.42 293.408C1459.03 279.39 1626.86 266.533 1794.72 253.79C1907.45 245.236 2020.18 236.733 2132.75 227.417C2164.6 224.756 2196.42 221.931 2228.23 219.081C2329.01 210.039 2429.42 201.46 2531.42 205.564C2716.99 214.03 2888.27 254.746 3058.97 298.75C3080.3 304.248 3101.64 309.742 3123.01 315.18C3231.23 342.746 3339.58 371.637 3441.34 407.933C3496.71 427.685 3558.32 450.506 3596 483.931C3604.88 492.194 3612.48 500.799 3619.43 509.774C3629.93 523.738 3638.06 538.737 3637.87 554.393H3638.01L3638.07 554.388ZM935.555 315.248C953.997 316.427 972.413 317.727 990.809 319.163C1045.38 323.747 1100.43 332.638 1145.02 353.977C1177.21 369.38 1200.33 390.109 1222.66 411.048C1227.93 416.016 1233.26 420.958 1238.68 425.862C1269.51 453.629 1305.83 477.801 1352.09 495.415C1428.05 524.335 1517.83 536.194 1604.61 543.7C1632.83 545.927 1661.5 547.358 1689.81 544.912C1721.93 542.062 1752.16 533.479 1768.77 515.095C1782.81 499.549 1785.95 481.005 1789.38 463.56C1792.96 445.425 1795.61 424.448 1815.74 410.13C1842.58 390.715 1863.59 369.115 1883.55 346.72C1905.2 322.51 1927.55 297.895 1963.67 281.12C2014.25 257.634 2079.98 252.532 2140.9 250.898C2260.93 248.107 2382.61 277.516 2492.11 305.111C2637.04 342.013 2777.02 386.266 2916.51 430.606C2963.24 445.479 3009.9 460.432 3056.55 475.393C3159.04 508.284 3261.32 541.574 3365.62 572.132C3402.32 582.884 3439.3 593.45 3477.29 602.278C3497.82 607.052 3522.43 613.72 3544.88 612.609C3577.88 610.735 3609.57 600.005 3624.19 580.556C3641.46 557.609 3631.06 531.677 3614.72 509.875C3607.69 500.934 3600.15 492.325 3591.26 484.07C3553.67 450.691 3492.13 427.916 3436.86 408.202C3335.22 371.957 3227 343.103 3118.91 315.572C3097.54 310.133 3076.2 304.639 3054.87 299.133C2885.11 255.365 2714.71 214.699 2530.15 206.275C2429.44 202.226 2330.23 210.792 2230.73 219.717C2198.88 222.58 2167.02 225.404 2135.13 228.065C2022.5 237.389 1909.7 245.897 1796.91 254.456C1629.1 267.186 1461.31 280.042 1293.75 294.056C1263.08 296.611 1232.38 298.99 1201.67 301.373C1184.39 302.707 1167.1 304.054 1149.82 305.418C1078.69 310.933 1007.15 313.69 935.541 315.269V315.248H935.555ZM451.122 312.962C479.392 313.737 507.662 314.238 535.958 314.524C547.303 314.629 558.648 314.734 569.993 314.844C685.389 315.951 800.804 316.894 916.187 314.882C761.469 306.201 606.059 307.334 451.122 312.962Z" fill="url(#paint11_linear_1779_1730)" style=""/>\n<path d="M3668.07 549.076C3668.11 585.321 3623.57 608.214 3569.13 611.325C3546.22 612.495 3521.84 606.702 3500.59 602.072C3462.88 593.85 3426.2 583.705 3389.86 573.349C3280.59 542.21 3173.63 507.816 3066.4 474.004C3024.32 460.735 2982.25 447.475 2940.1 434.302C2806.99 392.652 2673.72 350.752 2535.84 315.702C2472.35 299.562 2407.73 284.757 2341.45 273.866C2289.05 265.258 2234.52 258.564 2180.14 259.675C2120.98 261.111 2057.64 265.973 2007.96 288.142C1972.28 304.063 1949.25 327.515 1926.89 350.672C1905.99 372.34 1884.17 393.136 1856.78 411.793C1836.63 425.256 1832.64 445.365 1828.18 462.865C1823.83 479.813 1819.58 497.743 1804.91 512.565C1787.14 530.502 1756.3 538.695 1724.18 541.507C1694.37 544.058 1664.11 542.618 1634.4 540.261C1546.7 532.645 1456.57 520.643 1379.08 492.367C1331.51 475.01 1293.07 451.221 1259.73 423.871C1253.9 419.084 1248.18 414.235 1242.47 409.381C1218.42 388.926 1193.65 368.703 1160.65 353.657C1115.53 333.084 1061.13 324.126 1006.72 319.504C1003.87 319.268 1000.97 319.041 998.058 318.822C862.875 322.03 727.599 320.552 592.396 318.792C583.94 318.683 575.485 318.573 567.029 318.46C516.755 317.769 466.521 316.325 416.426 313.556C365.406 315.622 314.44 318.06 263.467 320.539C206.674 323.309 149.782 326.496 92.8102 327.384C92.6104 327.09 92.5106 326.942 92.3175 326.648C148.957 325.768 205.523 322.585 261.982 319.832C310.831 317.449 359.681 315.117 408.57 313.101C326.218 308.159 245.797 298.859 165.954 285.329C125.84 278.552 86.4652 272.225 44.6133 274.014C11.024 275.946 -22.6186 283.086 -53.6513 291.122C-82.4269 298.573 -118.42 308.277 -136.183 325.402C-141.616 331.135 -139.346 337.323 -134.639 342.88C-121.316 359.589 -89.0116 374.613 -60.0162 378.781C-60.0162 378.545 -60.509 377.846 -63.7913 376.368C-61.9604 376.276 -61.0416 376.225 -59.2107 376.133C-53.7645 378.583 -54.8164 379.185 -56.614 379.45C-57.666 379.602 -59.0908 379.648 -60.5755 379.564C-90.2766 377.013 -126.736 359.82 -139.406 342.952C-144.206 337.336 -146.47 331.072 -140.95 325.275C-122.927 307.881 -86.688 298.017 -57.4197 290.491C-25.6546 282.324 8.68043 275.272 43.0088 273.302C86.7448 271.408 127.658 277.739 169.61 284.816C250.95 298.586 332.882 307.906 416.806 312.747C610.758 305.073 805.663 303.36 998.937 318.014C1064.19 316.342 1129.37 313.581 1194.15 308.289C1210.88 306.896 1227.6 305.523 1244.34 304.159C1276.24 301.549 1308.14 298.927 1340 296.115C1493.04 282.551 1646.26 269.749 1799.48 257.028C1928.77 246.301 2058.09 235.668 2187.15 223.859C2220.96 220.732 2254.73 217.419 2288.49 214.047C2388.15 204.124 2487.37 194.737 2588.54 198.694C2772.29 206.928 2940.35 248.983 3107.8 294.557C3130.86 300.83 3153.93 307.094 3177.04 313.282C3294.19 344.678 3413.17 377.231 3520.69 420.701C3561.85 437.338 3604.52 456.378 3631.78 482.6C3639.98 490.881 3646.76 499.494 3653 508.423C3661.63 521.3 3668.27 534.935 3668.09 549.059V549.08L3668.07 549.076ZM1006.15 318.595C1007.15 318.67 1008.07 318.746 1009.06 318.83C1064.1 323.499 1119.24 332.482 1164.94 353.249C1198.18 368.349 1223.1 388.652 1247.28 409.238C1252.98 414.096 1258.7 418.941 1264.55 423.728C1297.77 450.96 1335.99 474.64 1383.32 491.958C1460.21 520.096 1549.71 532.043 1636.79 539.612C1664.95 541.852 1693.55 543.283 1721.81 540.858C1753.37 538.097 1783.19 529.875 1800.42 512.22C1814.83 497.452 1819.02 479.666 1823.36 462.832C1827.83 445.273 1831.81 425.125 1852.05 411.625C1879.42 392.984 1901.2 372.201 1922.1 350.559C1944.65 327.199 1967.91 303.608 2004.01 287.636C2054.71 265.207 2119.3 260.395 2179.5 258.943C2292.95 256.615 2407.38 282.719 2511.48 308.352C2659.45 344.796 2802.19 389.482 2944.42 433.97C2986.55 447.163 3028.63 460.428 3070.72 473.68C3174.92 506.537 3278.92 539.793 3384.92 570.293C3421.9 580.931 3459.16 591.366 3497.38 600.114C3518.72 604.997 3544.14 611.8 3567.39 610.626C3602.4 608.786 3636.45 597.887 3652.61 577.466C3669.73 555.836 3663.47 529.787 3648.14 508.519C3641.91 499.591 3635.13 490.999 3626.92 482.731C3585.34 442.806 3508.78 416.617 3444.34 394.268C3356.63 363.845 3264.8 338.313 3172.75 313.665C3149.63 307.468 3126.57 301.2 3103.51 294.932C2937.02 249.631 2769.86 207.614 2587.15 199.418C2487.33 195.52 2389.39 204.886 2291.07 214.674C2257.25 218.046 2223.43 221.371 2189.54 224.495C2060.43 236.312 1931.04 246.945 1801.69 257.684C1648.49 270.406 1495.29 283.199 1342.26 296.763C1310.36 299.575 1278.42 302.202 1246.48 304.816C1229.77 306.184 1213.06 307.552 1196.36 308.946C1133.21 314.107 1069.69 316.877 1006.09 318.599C1006.11 318.595 1006.12 318.59 1006.15 318.586L1006.15 318.595ZM424.889 313.206C472.34 315.728 519.911 317.054 567.515 317.706C575.971 317.816 584.426 317.925 592.882 318.039C725.468 319.761 858.114 321.213 990.681 318.237C802.8 304.34 613.395 305.885 424.882 313.219V313.21L424.889 313.206Z" fill="url(#paint12_linear_1779_1730)" style=""/>\n<path d="M3697.96 542.791C3698 581.448 3649.48 606.016 3591.6 609.359C3568.29 610.567 3543.43 604.804 3521.75 600.177C3483.37 591.989 3446.01 581.857 3408.99 571.505C3297.86 540.433 3189.03 506.069 3079.94 472.282C3042.62 460.735 3005.31 449.179 2967.95 437.674C2834.94 396.743 2701.85 355.396 2564.19 320.998C2456.18 294.01 2336.66 265.641 2218.63 267.733C2160.23 268.992 2097.98 273.576 2048.24 294.675C2012.61 309.788 1988.66 332.251 1965.42 354.529C1943.66 375.434 1921 395.447 1893.1 413.296C1872.86 426.026 1867.75 445.222 1862.22 462.15C1856.95 478.483 1851.66 495.638 1836.62 509.69C1818.24 526.882 1787.82 534.716 1756.22 537.444C1726.44 539.949 1696.24 538.509 1666.57 536.139C1578.58 528.465 1488.69 516.375 1410.31 488.881C1361.63 471.807 1321.31 448.51 1285.6 421.72C1279.37 417.026 1273.23 412.286 1267.1 407.541C1243.46 389.208 1219.32 370.955 1189.11 356.76C1150.26 338.506 1104.8 328.428 1057.71 322.434C910.198 326.425 762.525 324.29 614.992 321.886C608.38 321.777 605.078 321.722 598.467 321.613C534.764 320.51 471.067 318.119 407.83 312.991C367.949 314.587 328.081 316.376 288.22 318.182C232.899 320.695 177.491 323.604 122.017 324.337C121.844 324.042 121.758 323.895 121.585 323.6C176.746 322.876 231.847 319.971 286.855 317.475C325.105 315.736 363.361 314.027 401.631 312.474C332.855 306.538 266.149 296.683 200.102 283.3C161.905 275.58 125.213 268.777 84.6997 270.313C51.2502 272.132 17.6875 279.566 -13.0522 287.737C-43.1062 295.727 -78.9593 306.058 -98.0875 323.608C-104.519 328.98 -102.222 335.896 -98.8332 341.651C-90.098 357.075 -68.4597 369.262 -46.6083 377.391C-45.1236 377.299 -44.3779 377.257 -42.8931 377.164C-34.7238 380.313 -35.9622 380.519 -37.0741 380.688C-38.186 380.726 -38.7452 380.747 -39.8571 380.784C-66.7352 376.92 -94.5788 357.227 -103.654 341.697C-107.122 335.88 -109.373 328.9 -102.848 323.474C-83.3934 305.641 -47.2741 295.151 -16.6808 287.085C14.7846 278.788 49.0264 271.433 83.215 269.594C125.713 267.969 163.903 274.729 203.997 282.837C270.483 296.127 338.427 306.13 407.51 312.225C614.046 304.092 821.621 302.017 1027.32 318.464C1037.97 319.378 1048.56 320.426 1059.13 321.63C1119.84 319.849 1180.44 317.012 1240.67 311.838C1256.8 310.428 1272.93 309.034 1289.06 307.641C1322.19 304.782 1355.3 301.916 1388.37 298.843C1522.62 286.289 1656.96 274.174 1791.31 262.1C1941.41 248.608 2091.59 235.339 2241.33 220.311C2276.91 216.715 2312.44 212.88 2347.96 209.003C2446.69 198.21 2544.91 188.022 2645.46 191.836C2828.09 199.872 2993.51 243.426 3158.27 290.693C3182.46 297.634 3206.66 304.559 3230.93 311.396C3321.64 336.945 3412.29 363.222 3498.41 394.605C3558.78 416.609 3630.11 442.549 3667.47 481.283C3674.78 489.336 3680.61 497.696 3686.03 506.322C3686.23 506.629 3686.33 506.781 3686.54 507.088C3693.33 518.606 3698.15 530.41 3698.16 542.782C3698.09 542.782 3698.05 542.786 3697.98 542.791H3697.96ZM1063.94 322.261C1110.69 328.42 1155.8 338.595 1194.31 356.831C1224.3 371.031 1248.32 389.153 1271.85 407.402C1277.98 412.147 1284.13 416.887 1290.35 421.585C1325.87 448.249 1366.01 471.487 1414.44 488.49C1492.31 515.827 1581.55 527.876 1668.98 535.499C1697.12 537.743 1725.68 539.175 1753.94 536.796C1784.9 534.123 1814.44 526.251 1832.24 509.353C1846.99 495.36 1852.19 478.319 1857.38 462.116C1862.92 445.117 1868.08 425.896 1888.39 413.123C1916.26 395.287 1938.89 375.287 1960.66 354.411C1984.11 331.914 2008.25 309.337 2044.33 294.157C2095.11 272.789 2158.6 268.263 2218.07 266.988C2337.33 264.87 2457.89 293.147 2567.1 320.354C2705.3 354.785 2838.87 396.268 2972.34 437.338C3009.7 448.834 3047.01 460.39 3084.33 471.946C3190.35 504.769 3296.18 538.008 3404 568.436C3442.04 579.175 3480.39 589.704 3519.7 598.468C3541.26 603.276 3566.61 609.78 3589.99 608.651C3625.94 606.732 3661.86 596.283 3680.28 575.887C3699.32 554.801 3695.31 528.958 3681.61 507.155C3681.42 506.848 3681.32 506.697 3681.13 506.389C3675.76 497.768 3669.9 489.433 3662.63 481.388C3625.37 442.709 3554.1 416.815 3493.84 394.853C3407.81 363.504 3317.25 337.265 3226.63 311.745C3202.37 304.917 3178.18 297.988 3154 291.042C2990.25 244.049 2825.72 200.55 2644.19 192.543C2545.04 188.788 2448.12 198.955 2350.77 209.597C2315.22 213.487 2279.66 217.317 2244.04 220.921C2094.24 235.966 1943.99 249.24 1793.83 262.732C1659.5 274.805 1525.17 286.912 1390.95 299.466C1357.81 302.547 1324.64 305.418 1291.45 308.277C1275.34 309.666 1259.23 311.063 1243.13 312.474C1183.73 317.576 1123.98 320.43 1064.12 322.236C1064.04 322.244 1064 322.249 1063.93 322.257L1063.94 322.261ZM413.502 312.772C475.115 317.87 536.934 319.883 599.006 320.885C605.617 320.99 608.92 321.045 615.524 321.15C761.16 323.52 906.929 325.633 1052.56 321.828C1043.4 320.775 1034.2 319.887 1024.96 319.133C822.04 302.918 617.262 304.833 413.502 312.772Z" fill="url(#paint13_linear_1779_1730)" style=""/>\n<path d="M3728.59 537.373C3728.63 578.754 3675.25 603.835 3614.05 607.38C3590.62 608.609 3565.71 603.023 3543.83 598.485C3504.39 590.301 3465.98 580.089 3427.93 569.653C3314.81 538.636 3203.97 504.28 3092.87 470.514C3060.51 460.685 3028.16 450.851 2995.78 441.05C2864.52 401.345 2733.18 361.251 2597.51 327.852C2490.85 301.596 2373.29 274.052 2257.04 275.786C2199.36 276.864 2138.28 281.17 2088.5 301.221C2052.9 315.563 2028.11 337.003 2003.97 358.401C1981.33 378.532 1957.82 397.758 1929.41 414.807C1909.15 426.754 1902.62 445.096 1896.32 461.446C1890.16 477.149 1883.85 493.554 1868.5 506.835C1849.54 523.253 1819.44 530.751 1788.41 533.39C1758.65 535.861 1728.51 534.426 1698.87 532.039C1610.59 524.306 1520.94 512.119 1441.65 485.425C1391.82 468.649 1349.59 445.786 1311.58 419.598C1304.94 415.013 1298.38 410.383 1291.85 405.731C1268.89 389.427 1245.62 373.186 1218.03 359.934C1184.52 343.84 1146.34 333.349 1105.91 326.366C949.818 330.786 793.536 327.986 637.448 324.93C634.451 324.871 632.953 324.837 629.964 324.779C555.961 323.242 481.851 319.908 408.82 311.943C376.862 313.168 344.917 314.49 312.973 315.837C259.11 318.094 205.16 320.733 151.165 321.31C151.018 321.015 150.945 320.868 150.792 320.573C204.475 320.005 258.118 317.374 311.668 315.13C342.334 313.846 373.001 312.57 403.674 311.387C345.63 304.702 289.856 294.485 234.755 281.28C198.396 272.591 164.021 265.359 124.679 266.638C90.2842 268.39 55.9492 276.346 24.6702 285.144C-5.5036 293.631 -40.2248 304.446 -60.0854 321.844C-66.5969 327.132 -65.6781 334.048 -63.3012 340.119C-63.2546 340.253 -63.228 340.325 -63.1813 340.46C-57.5021 356.785 -38.2474 369.654 -18.9992 380.267C-16.9353 381.37 -16.669 381.963 -18.1936 382.043C-19.7183 382.123 -22.4813 381.487 -26.4828 380.132C-28.3403 379.492 -29.2658 379.172 -31.1234 378.532C-29.7385 378.44 -29.0461 378.389 -27.6612 378.296C-45.4046 368.046 -62.722 355.787 -68.0683 340.485C-68.1149 340.35 -68.1415 340.279 -68.1881 340.144C-70.6383 334.019 -71.5837 327.039 -64.9723 321.701C-44.8387 304.029 -9.7913 293.029 20.8952 284.466C52.9399 275.529 88.0339 267.678 123.194 265.91C164.44 264.47 200.606 271.74 238.717 280.863C294.483 294.241 350.956 304.484 409.739 311.131C621.568 303.103 834.416 301.048 1045.33 318.127C1066.23 319.937 1086.97 322.223 1107.39 325.557C1167.45 323.705 1227.4 320.746 1286.96 315.395C1302.46 313.972 1317.98 312.562 1333.49 311.16C1367.87 308.049 1402.25 304.926 1436.57 301.575C1544.73 290.949 1652.92 280.518 1761.12 270.099C1939.32 252.94 2117.66 236.164 2295.3 216.774C2332.41 212.704 2369.45 208.359 2406.48 203.947C2504.52 192.287 2601.95 181.308 2702.13 184.995C2792.73 188.902 2881.21 200.937 2966.79 220.071C3050.28 238.736 3130.22 263.056 3210 287.177C3234.81 294.666 3259.61 302.16 3284.51 309.523C3373.41 335.846 3462.42 362.737 3546.46 394.937C3602.92 416.567 3669.76 442.318 3702.79 479.978C3709.24 487.904 3714.23 496.012 3718.82 504.423C3719.12 504.958 3719.26 505.223 3719.55 505.758C3724.81 516.072 3728.53 526.482 3728.54 537.377H3728.6L3728.59 537.373ZM1111.34 326.214C1151.58 333.307 1189.6 343.844 1222.95 359.917C1250.41 373.148 1273.61 389.343 1296.47 405.588C1303 410.24 1309.56 414.866 1316.21 419.446C1354.06 445.534 1396.07 468.291 1445.67 485.029C1524.39 511.597 1613.45 523.725 1701.13 531.408C1729.26 533.664 1757.79 535.087 1786.04 532.759C1816.48 530.17 1845.58 522.66 1863.99 506.503C1879.08 493.268 1885.31 477.001 1891.41 461.421C1897.78 445.008 1904.31 426.615 1924.7 414.639C1953.08 397.602 1976.56 378.389 1999.2 358.292C2023.56 336.709 2048.63 315.088 2084.63 300.707C2135.45 280.404 2197.88 276.156 2256.61 275.062C2372.53 273.328 2489.12 299.697 2595.67 325.776C2733.56 359.53 2866.87 400.414 3000.16 440.731C3032.54 450.531 3064.91 460.352 3097.25 470.194C3205.23 503.005 3313.02 536.232 3422.79 566.605C3461.19 577.234 3499.88 587.649 3539.52 596.325C3561.94 601.234 3588.18 607.889 3612.44 606.702C3649.54 604.69 3687.01 594.646 3707.75 574.3C3728.6 553.858 3727.13 528.103 3714.96 505.829C3714.66 505.299 3714.51 505.038 3714.21 504.508C3709.58 496.126 3704.58 488.018 3698.19 480.1C3665.19 442.507 3598.44 416.803 3542.06 395.207C3458.11 363.049 3369.2 336.183 3280.39 309.893C3255.51 302.513 3230.71 295.029 3205.91 287.535C3044.42 238.724 2882.08 193.575 2701.12 185.736C2602.33 182.078 2506.35 193.061 2409.68 204.558C2372.59 208.97 2335.48 213.322 2298.3 217.406C2120.58 236.8 1942.16 253.588 1763.89 270.76C1655.69 281.183 1547.49 291.61 1439.34 302.236C1404.97 305.591 1370.55 308.727 1336.13 311.838C1320.62 313.24 1305.11 314.65 1289.6 316.073C1230.5 321.385 1171 324.362 1111.39 326.243C1111.37 326.231 1111.36 326.227 1111.33 326.214H1111.34ZM414.986 311.716C486.166 319.331 558.344 322.564 630.437 324.063C633.433 324.122 634.931 324.151 637.927 324.214C792.484 327.237 947.242 330.02 1101.81 325.747C1082.47 322.661 1062.85 320.518 1043.1 318.809C834.676 301.941 624.325 303.856 414.986 311.728V311.72V311.716Z" fill="url(#paint14_linear_1779_1730)" style=""/>\n<path d="M3759.59 531.871C3760.15 575.993 3700.56 601.562 3636.52 605.414C3612.31 606.774 3586.37 600.973 3563.75 596.363C3523.92 588.243 3485.09 578.127 3446.6 567.784C3331.35 536.817 3218.37 502.47 3105.13 468.717C3077.95 460.617 3050.77 452.514 3023.57 444.439C3021.5 443.821 3020.45 443.509 3018.37 442.89C2888.49 404.304 2758.59 365.188 2624.43 332.819C2520.85 307.83 2407.85 282.488 2295.41 283.848C2238.45 284.753 2178.49 288.786 2128.68 307.78C2093.12 321.348 2067.47 341.79 2042.46 362.295C2018.88 381.622 1994.53 400.069 1965.6 416.327C1945.26 427.546 1937.55 444.991 1930.22 460.765C1923.13 475.84 1915.82 491.458 1900.16 503.994C1880.61 519.658 1850.99 526.802 1820.45 529.353C1790.69 531.787 1760.55 530.338 1730.91 527.947C1642.37 520.155 1552.92 507.888 1472.78 481.973C1421.74 465.467 1377.63 443.063 1337.33 417.468C1330.29 412.98 1323.31 408.455 1316.35 403.913C1266.82 371.59 1216.38 344.985 1147.86 330.386C985.708 334.928 823.361 331.649 661.26 327.957C579.221 325.983 496.795 321.748 416.48 310.525C390.182 311.476 363.883 312.465 337.59 313.476C285.166 315.488 232.655 317.854 180.117 318.279C180.017 317.984 179.97 317.837 179.87 317.542C232.095 317.13 284.3 314.76 336.419 312.76C361.686 311.796 386.946 310.836 412.219 309.923C362.871 302.657 315.945 292.221 269.719 279.221C235.138 269.522 203.027 261.818 164.59 262.934C130.362 264.567 96.0868 272.877 65.134 281.793C33.8084 290.819 -1.07261 302.261 -22.2116 320.06C-28.2237 326.054 -32.8111 332.2 -27.5912 339.209C-20.8401 347.477 -13.5895 355.547 -6.05941 363.542C-4.27508 365.449 15.5456 382.7 3.65451 383.251C-3.08999 383.331 -8.91565 381.361 -14.9078 379.631C-13.1767 379.501 -12.3112 379.433 -10.5735 379.303C-2.59064 381.791 0.871505 382.372 2.1698 382.506C5.97149 377.77 -7.25784 367.52 -10.8864 363.647C-18.4232 355.644 -25.687 347.57 -32.4848 339.306C-37.7645 332.221 -33.1106 325.999 -27.0386 319.937C-5.5867 301.865 29.6139 290.238 61.4788 281.141C93.1972 272.082 128.178 263.889 163.172 262.235C203.539 260.993 237.502 268.689 273.867 278.884C320.553 292.014 367.977 302.501 417.852 309.729C632.99 302.156 849.353 300.265 1063.47 317.803C1092.67 320.363 1121.6 323.907 1149.72 329.582C1211.16 327.696 1272.5 324.669 1333.37 318.957C1348.15 317.538 1362.94 316.136 1377.73 314.73C1413.46 311.345 1449.18 307.957 1484.84 304.303C1554.14 297.184 1623.44 290.091 1692.75 283.014C1911.84 260.619 2131.21 238.892 2349.43 213.221C2387.91 208.671 2426.29 203.813 2464.66 198.879C2562.23 186.343 2658.89 174.534 2758.94 178.138C2849.37 181.96 2937.54 194.324 3022.51 214.211C3105.41 233.613 3184.42 258.897 3263.28 283.987C3288.23 291.913 3313.17 299.832 3338.21 307.637C3422.08 333.724 3506.15 360.178 3585.37 391.641C3640.9 413.692 3707.86 440.263 3738.25 478.66C3743.9 486.452 3748.12 494.371 3751.91 502.584C3752.26 503.316 3752.43 503.683 3752.78 504.419C3756.64 513.432 3759.39 522.491 3759.41 531.871H3759.59ZM1153.11 330.243C1221.32 344.951 1271.68 371.506 1321.04 403.748C1327.99 408.291 1334.98 412.808 1342.02 417.295C1382.17 442.76 1426.02 465.096 1476.82 481.556C1556.42 507.341 1645.28 519.553 1733.26 527.299C1761.39 529.568 1789.91 530.999 1818.16 528.701C1848.04 526.272 1876.86 519.006 1895.79 503.645C1911.16 491.163 1918.39 475.65 1925.4 460.714C1932.74 444.873 1940.49 427.399 1960.9 416.133C1989.83 399.901 2014.13 381.466 2037.7 362.165C2062.97 341.462 2088.89 320.868 2124.89 307.245C2175.74 288.007 2237.02 284.02 2295.05 283.111C2408.62 281.73 2522.61 306.984 2627.32 332.179C2761.99 364.581 2892.32 403.828 3022.64 442.553C3024.72 443.172 3025.76 443.484 3027.84 444.103C3055.03 452.189 3082.22 460.281 3109.39 468.38C3219.45 501.182 3329.32 534.409 3441.15 564.74C3480.35 575.374 3519.85 585.78 3560.27 594.435C3583.22 599.348 3609.98 605.966 3634.72 604.728C3672.87 602.64 3711.61 592.583 3734.42 572.402C3756.78 552.625 3758.7 527.248 3748.08 504.47C3747.73 503.737 3747.56 503.371 3747.21 502.634C3743.38 494.442 3739.19 486.524 3733.53 478.748C3703.18 440.411 3636.28 413.89 3580.83 391.873C3501.68 360.447 3417.7 334.027 3333.93 307.961C3308.9 300.156 3283.94 292.238 3259 284.311C3180.46 259.318 3101.76 234.097 3019.19 214.758C2934.92 195.019 2847.51 182.659 2757.8 178.862C2659.26 175.313 2563.94 187.109 2467.85 199.452C2429.44 204.394 2391 209.264 2352.46 213.819C2134.16 239.49 1914.7 261.233 1695.52 283.637C1626.24 290.718 1556.95 297.803 1487.68 304.926C1451.96 308.58 1416.18 311.981 1380.39 315.361C1365.6 316.763 1350.82 318.169 1336.03 319.575C1275.36 325.267 1214.23 328.323 1153 330.23C1153.05 330.23 1153.08 330.234 1153.12 330.239L1153.11 330.243ZM422.293 310.335C500.963 321.171 581.624 325.305 661.939 327.237C822.722 330.9 983.744 334.154 1144.57 329.742C1117.4 324.337 1089.47 320.927 1061.29 318.456C849.24 301.086 635.294 302.825 422.233 310.335H422.293Z" fill="url(#paint15_linear_1779_1730)" style=""/>\n<path d="M3790.66 525.417C3791.23 572.275 3726.56 599.352 3658.92 603.453C3635.91 604.711 3611.62 599.71 3589.95 595.496C3551.89 588.1 3514.76 578.737 3477.96 569.169C3355.89 537.432 3236.29 501.839 3116.51 466.848C3094.79 460.499 3073.07 454.16 3051.35 447.82C3044.97 445.959 3041.78 445.029 3035.39 443.168C2909.75 406.527 2784.1 369.393 2654.42 338.725C2553.13 314.768 2443.34 290.899 2333.78 291.905C2277.57 292.638 2218.66 296.409 2168.9 314.343C2133.37 327.144 2106.84 346.623 2080.95 366.202C2056.45 384.725 2031.27 402.389 2001.81 417.843C1981.34 428.392 1972.67 444.894 1964.19 460.087C1956.19 474.522 1947.88 489.37 1931.93 501.165C1911.58 516.211 1882.76 522.534 1852.57 525.32C1822.78 527.703 1792.63 526.259 1762.97 523.847C1674.18 515.996 1584.84 503.67 1503.91 478.517C1451.61 462.263 1405.67 440.301 1363.08 415.346C1355.65 410.951 1348.25 406.531 1340.87 402.102C1294.47 374.158 1247.15 349.536 1186.85 334.554C1022.1 339.041 857.179 335.417 692.522 331.152C604.177 328.744 514.848 323.735 429.3 308.853C406.942 309.586 384.585 310.352 362.228 311.131C311.234 312.895 260.168 315.004 209.088 315.282C209.015 314.987 208.975 314.84 208.902 314.545C259.695 314.275 310.475 312.175 361.182 310.415C382.694 309.666 404.206 308.929 425.718 308.222C383.6 300.51 343.978 289.96 305.122 277.205C272.252 266.457 242.291 258.345 204.574 259.284C170.519 260.8 136.33 269.48 105.724 278.51C73.2861 288.078 38.2054 300.148 15.7881 318.317C9.40981 324.353 4.06348 330.622 8.05159 338.043C11.3673 343.524 14.8294 348.968 18.3847 354.385C20.968 358.385 42.5996 384.485 23.8309 384.51C15.868 384.763 8.59089 382.641 1.43359 380.738C3.14469 380.599 3.99688 380.528 5.70132 380.389C17.892 383.895 21.9734 383.82 22.4061 383.803C35.2227 381.256 16.5404 359.092 13.5577 354.449C10.0489 349.014 6.54024 343.579 3.22458 338.094C-0.830106 330.588 4.54283 324.265 11.021 318.165C33.7712 299.71 69.2114 287.451 102.215 277.807C133.607 268.634 168.501 260.088 203.336 258.556C242.957 257.503 274.949 265.506 309.517 276.885C348.719 289.75 388.693 300.341 431.231 308.041C648.093 301.027 866.068 299.592 1081.8 317.475C1118.38 320.712 1154.56 325.536 1189.22 333.745C1253.05 331.834 1316.8 328.698 1379.98 322.535C1394.02 321.133 1408.06 319.744 1422.11 318.359C1459.24 314.692 1496.37 311.004 1533.43 307.06C1539.79 306.374 1542.97 306.033 1549.33 305.351C1834.45 274.78 2120.15 245.489 2403.79 209.715C2443.45 204.684 2483 199.313 2522.52 193.861C2619.73 180.449 2715.95 167.828 2816 171.327C2906.49 175.086 2994.55 187.824 3079.1 208.502C3161.66 228.692 3239.94 255.053 3318.07 281.191C3342.72 289.451 3367.41 297.685 3392.19 305.797C3473.01 332.242 3554.03 359.041 3630.09 390.753C3682.76 412.715 3747.25 439.535 3773.97 477.389C3778.89 485.076 3782.36 492.851 3785.41 500.9C3785.76 501.784 3785.93 502.226 3786.28 503.11C3789.01 510.397 3790.76 517.941 3790.67 525.447V525.417H3790.66ZM1192.04 334.402C1252.12 349.456 1299.33 374.036 1345.62 401.913C1353 406.346 1360.38 410.77 1367.83 415.157C1410.23 440.011 1455.95 461.897 1507.99 478.096C1588.39 503.123 1677.14 515.402 1765.38 523.203C1793.52 525.485 1822.06 526.933 1850.34 524.668C1879.73 522.323 1908.06 515.39 1927.54 500.803C1943.23 489.062 1951.45 474.333 1959.36 460.028C1967.85 444.759 1976.6 428.232 1997.17 417.64C2026.59 402.203 2051.79 384.577 2076.24 366.063C2102.41 346.273 2129.21 326.673 2165.2 313.808C2216.05 295.635 2276.21 291.913 2333.53 291.177C2444.19 290.158 2554.98 313.96 2657.36 338.107C2787.54 368.808 2913.65 406.064 3039.72 442.84C3046.11 444.7 3049.29 445.631 3055.68 447.491C3077.4 453.823 3099.12 460.171 3120.83 466.519C3233.15 499.334 3345.28 532.578 3459.38 562.875C3499.81 573.614 3540.55 584.122 3582.23 592.798C3605.41 597.622 3632.28 604.042 3657.19 602.775C3696.54 600.594 3736.86 590.878 3761.95 570.823C3785.91 551.682 3790.32 526.364 3781.42 503.139C3781.08 502.255 3780.9 501.813 3780.56 500.925C3777.51 492.885 3774.05 485.126 3769.11 477.452C3742.41 439.649 3678.02 412.913 3625.4 390.959C3549.45 359.273 3468.5 332.512 3387.77 306.096C3363 297.975 3338.31 289.745 3313.65 281.482C3235.85 255.449 3157.89 229.159 3075.67 209.033C2991.85 188.511 2904.6 175.768 2814.86 172.034C2716.35 168.594 2621.48 181.198 2525.78 194.4C2486.21 199.856 2446.63 205.244 2406.92 210.283C2123.18 246.061 1837.37 275.374 1552.15 305.957C1545.79 306.643 1542.61 306.984 1536.25 307.666C1499.13 311.619 1461.94 315.307 1424.75 318.982C1410.73 320.367 1396.7 321.756 1382.68 323.149C1319.53 329.317 1255.82 332.478 1192.03 334.419V334.389L1192.04 334.402ZM434.919 308.672C518.996 323.128 606.674 328.045 693.44 330.415C856.88 334.655 1020.59 338.258 1184.12 333.876C1150.34 325.94 1115.1 321.272 1079.49 318.106C865.748 300.388 649.791 301.768 434.926 308.664V308.672H434.919Z" fill="url(#paint16_linear_1779_1730)" style=""/>\n<path d="M3822.4 519.671C3822.98 569.59 3752.75 597.117 3681.45 601.487C3658.49 602.754 3634.32 597.993 3612.61 593.918C3573.11 586.504 3534.57 576.995 3496.37 567.27C3371.71 535.546 3249.49 499.923 3127.09 464.899C3102.5 457.864 3077.92 450.826 3053.33 443.791C2931.78 409.015 2810.21 373.788 2684.87 344.741C2585.94 321.815 2478.93 299.133 2372.26 299.967C2316.78 300.527 2258.96 304.033 2209.25 320.923C2173.74 332.983 2146.38 351.472 2119.61 370.13C2094.21 387.857 2068.14 404.708 2038.14 419.371C2017.66 429.188 2007.63 444.848 1998.28 459.434C1989.38 473.209 1980.08 487.294 1963.88 498.357C1943.06 512.578 1914.59 518.606 1884.92 521.3C1855.1 523.641 1824.94 522.188 1795.26 519.759C1706.21 511.849 1616.96 499.473 1535.25 475.069C1481.69 459.072 1433.91 437.573 1389.11 413.237C1381.25 408.947 1373.44 404.632 1365.66 400.296C1322.2 376.103 1278.1 353.83 1224.76 338.898C1057.92 343.263 890.822 339.138 724.127 334.33C630.849 331.493 535.468 325.873 446.431 306.955C426.69 307.536 406.949 308.138 387.215 308.752C337.633 310.28 287.992 312.086 238.343 312.259V311.522C287.666 311.35 336.974 309.548 386.23 308.032C405.245 307.447 424.26 306.866 443.282 306.302C407.196 298.236 373.653 287.649 340.936 275.163C309.85 263.279 281.787 254.839 244.655 255.605C210.706 257.007 176.604 265.868 146.257 275.016C112.661 285.144 77.5674 297.954 53.8917 316.549C46.9808 321.924 40.5891 329.687 43.8648 336.844C44.9168 339.424 45.9688 341.95 47.0207 344.396C50.1633 351.906 70.6032 385.238 44.1778 385.752C34.8633 386.085 26.3811 383.925 17.8789 381.829C19.5634 381.681 20.4022 381.605 22.0867 381.458C28.6115 383.209 35.6223 385.003 42.8129 385.032C64.2115 384.178 44.8103 350.643 42.1937 344.434C41.1417 341.984 40.0898 339.462 39.0378 336.882C35.7555 329.658 42.1538 321.832 49.1246 316.397C72.9201 297.563 108.394 285.098 142.063 274.7C173.588 265.447 208.396 256.245 243.543 254.868C282.625 253.988 312.593 262.323 345.39 274.868C378.353 287.439 412.156 298.064 448.541 306.13C665.81 299.832 884.018 298.998 1100.03 317.125C1143.52 321.011 1186.67 327.115 1227.19 338.064C1293.92 336.128 1360.55 332.777 1426.55 326.079C1439.78 324.707 1453.03 323.347 1466.27 321.988C1504.84 318.022 1543.42 314.048 1581.92 309.784C1874.45 277.15 2167.52 245.287 2458.1 206.17C2498.77 200.66 2539.3 194.791 2579.8 188.814C2676.8 174.526 2772.74 161.072 2872.98 164.473C2963.78 168.173 3051.91 181.358 3136.23 202.878C3218.66 223.91 3296.38 251.467 3373.92 278.741C3397.91 287.173 3421.91 295.589 3446 303.907C3524.65 330.963 3603.66 358.267 3677.24 390.648C3726.46 412.311 3787.02 439.194 3809.59 476.063C3813.82 483.64 3816.71 491.302 3818.94 499.203C3819.24 500.231 3819.39 500.744 3819.69 501.776C3821.47 507.678 3822.4 513.685 3822.41 519.696V519.675L3822.4 519.671ZM1229.72 338.742C1282.87 353.716 1326.89 375.939 1370.24 400.082C1378.02 404.418 1385.84 408.737 1393.69 413.022C1438.31 437.253 1485.9 458.681 1539.23 474.631C1620.43 498.913 1709.12 511.247 1797.63 519.111C1825.82 521.405 1854.38 522.854 1882.71 520.631C1911.58 518.374 1939.6 511.778 1959.55 497.974C1975.48 486.957 1984.66 472.985 1993.46 459.346C2002.87 444.7 2012.93 429.002 2033.49 419.135C2063.43 404.485 2089.49 387.659 2114.86 369.961C2141.92 351.106 2169.59 332.47 2205.55 320.358C2256.36 303.246 2315.48 299.786 2372.08 299.226C2479.82 298.388 2587.79 321.007 2687.78 344.114C2813.61 373.19 2935.62 408.539 3057.59 443.438C3082.18 450.472 3106.76 457.511 3131.35 464.545C3246.11 497.393 3360.69 530.675 3477.23 560.956C3518.61 571.703 3560.27 582.227 3602.89 590.87C3626.74 595.707 3654.2 602.105 3679.71 600.792C3720.29 598.515 3762.28 589.14 3789.51 569.177C3814.93 550.541 3821.93 525.565 3814.83 501.78C3814.54 500.753 3814.4 500.235 3814.11 499.208C3811.91 491.323 3808.99 483.67 3804.82 476.105C3782.31 439.291 3721.8 412.45 3672.66 390.829C3599.16 358.49 3520.23 331.219 3441.67 304.185C3417.55 295.875 3393.52 287.451 3369.51 279.011C3292.28 251.841 3214.87 224.415 3132.81 203.4C3049.24 181.998 2961.88 168.843 2871.85 165.168C2773.2 161.825 2678.63 175.267 2583.19 189.327C2542.62 195.313 2502.02 201.203 2461.29 206.713C2170.59 245.864 1877.39 277.735 1584.75 310.373C1546.22 314.646 1507.6 318.624 1468.99 322.594C1455.74 323.954 1442.5 325.313 1429.25 326.686C1363.19 333.383 1296.5 336.78 1229.7 338.738V338.73L1229.72 338.742ZM451.624 306.791C539.303 325.246 633.086 330.803 724.873 333.59C890.416 338.363 1056.36 342.464 1222.05 338.191C1182.38 327.54 1140.16 321.571 1097.62 317.765C883.405 299.79 667.022 300.585 451.564 306.782C451.591 306.782 451.604 306.786 451.624 306.791Z" fill="url(#paint17_linear_1779_1730)" style=""/>\n<path d="M3854.32 513.108C3854.29 565.228 3778.85 595.273 3703.85 599.516C3677.43 601.023 3649.14 594.983 3624.27 590.205C3580.94 581.882 3538.56 571.539 3496.52 560.93C3375.16 530.313 3255.94 496.311 3136.5 462.844C3114.94 456.803 3093.39 450.762 3071.83 444.721C2954.24 411.734 2836.61 378.334 2715.45 350.845C2618.67 328.887 2514.6 307.523 2410.62 308.024C2355.86 308.411 2299.13 311.678 2249.5 327.511C2213.97 338.847 2185.78 356.334 2158.12 374.062C2131.78 390.963 2104.79 406.998 2074.27 420.882C2053.76 430.046 2042.64 444.806 2032.27 458.769C2022.41 471.891 2012.15 485.151 1995.68 495.528C1974.32 508.978 1946.39 514.661 1917.16 517.263C1887.27 519.566 1857.06 518.097 1827.32 515.655C1738.05 507.686 1648.84 495.267 1566.4 471.605C1511.52 455.852 1461.86 434.791 1414.86 411.098C1406.6 406.914 1398.38 402.692 1390.18 398.461C1349.42 377.446 1308.22 357.538 1260.61 343.066C1092.17 347.246 923.627 342.855 755.388 337.496C658.395 334.259 557.354 328.214 466.486 304.9C448.316 305.363 430.14 305.852 411.971 306.344C363.807 307.641 315.59 309.194 267.367 309.219V308.483C315.317 308.458 363.268 306.904 411.165 305.62C428.735 305.145 446.313 304.677 463.883 304.218C432.797 295.854 404.467 285.292 376.824 273.092C347.495 260.101 321.35 251.298 284.624 251.896C250.882 253.188 216.873 262.445 186.899 271.682C152.244 282.357 116.751 295.799 91.8168 314.755C85.1056 320.754 81.7367 326.378 79.999 333.661C79.7992 334.461 79.6994 334.857 79.5063 335.656C77.2759 345.276 76.4969 354.819 76.6634 364.535C76.8298 372.007 79.2999 386.644 61.9959 386.985C52.3485 387.221 42.9741 385.158 34.1523 382.902C35.8102 382.75 36.6424 382.675 38.3003 382.523C45.5108 384.232 52.8878 386.207 60.6976 386.274C74.7459 385.474 71.9029 370.408 71.7764 364.531C71.6898 354.806 72.3956 345.25 74.6194 335.614C74.8191 334.814 74.919 334.419 75.112 333.619C76.8564 326.29 80.3053 320.636 87.0564 314.6C111.711 295.849 146.745 282.425 180.933 271.736C212.492 261.869 247.999 252.502 283.579 251.163C322.302 250.448 350.391 259.09 381.404 272.839C409.208 285.123 437.704 295.719 469.023 304.084C685.612 298.59 903.001 298.506 1118.23 316.789C1168.15 321.293 1217.34 328.82 1263.26 342.245C1333.48 340.304 1403.65 336.915 1473.03 329.632C1485.34 328.315 1497.66 327.001 1509.97 325.692C1550.11 321.419 1590.25 317.121 1630.31 312.516C1877.5 283.911 2124.66 254.914 2370.56 222.15C2417.87 215.848 2465.13 209.374 2512.29 202.626C2553.85 196.648 2595.24 190.266 2636.61 183.787C2733.54 168.607 2829.33 154.311 2929.91 157.611C3021.24 161.261 3109.64 174.926 3193.93 197.389C3276.43 219.376 3353.76 248.2 3430.91 276.708C3453.85 285.182 3476.79 293.648 3499.83 302.004C3575.34 329.333 3651.24 356.911 3721.47 389.507C3768.13 411.166 3826.11 438.44 3845.18 474.728C3848.71 482.268 3850.95 489.849 3852.42 497.65C3852.64 498.749 3852.74 499.3 3852.96 500.399C3853.92 504.554 3854.34 508.924 3854.34 513.095L3854.32 513.108ZM1265.6 342.927C1313.06 357.412 1354.15 377.278 1394.8 398.246C1403.01 402.477 1411.22 406.699 1419.49 410.884C1466.3 434.483 1515.75 455.469 1570.38 471.171C1652.31 494.716 1740.98 507.092 1829.73 515.011C1857.97 517.326 1886.59 518.787 1914.99 516.61C1943.6 514.059 1970.62 508.368 1991.4 495.158C2007.61 484.848 2017.73 471.668 2027.48 458.693C2037.95 444.671 2049.11 429.857 2069.74 420.655C2100.23 406.796 2127.14 390.77 2153.47 373.91C2181.43 355.998 2209.93 338.346 2245.9 326.955C2296.63 310.895 2354.68 307.687 2410.55 307.304C2515.58 306.803 2620.6 328.113 2718.4 350.247C2840.04 377.77 2958.08 411.288 3076.09 444.393C3097.65 450.434 3119.2 456.475 3140.76 462.516C3258.21 495.423 3375.48 528.764 3494.69 559.061C3536.68 569.733 3578.97 580.16 3622.16 588.752C3646.99 593.69 3675.61 600.232 3702.11 598.847C3785.57 594.128 3860.35 557.714 3848.13 500.449C3847.9 499.347 3847.79 498.795 3847.56 497.688C3846.05 489.904 3843.84 482.331 3840.33 474.804C3821.3 438.571 3763.37 411.343 3716.78 389.722C3646.62 357.164 3570.79 329.616 3495.36 302.316C3472.3 293.955 3449.33 285.489 3426.38 277.011C3349.53 248.612 3272.49 219.881 3190.34 197.94C3106.84 175.633 3019.24 161.973 2928.69 158.352C2829.77 155.106 2735.37 169.398 2640.05 184.33C2598.65 190.817 2557.21 197.199 2515.62 203.19C2468.42 209.942 2421.13 216.417 2373.78 222.727C2127.78 255.499 1880.53 284.509 1633.25 313.13C1593.15 317.744 1552.97 322.038 1512.78 326.328C1500.49 327.637 1488.19 328.95 1475.9 330.268C1406.38 337.559 1336.07 340.994 1265.71 342.964C1265.66 342.956 1265.64 342.952 1265.59 342.943L1265.6 342.927ZM471.666 304.766C561.308 327.578 660.758 333.577 756.36 336.764C923.487 342.093 1090.91 346.454 1258.24 342.371C1213.11 329.232 1164.83 321.853 1115.8 317.424C902.255 299.289 686.578 299.36 471.673 304.766H471.666Z" fill="url(#paint18_linear_1779_1730)" style=""/>\n<path d="M3886.81 506.966C3886.82 562.841 3805.95 593 3726.38 597.55C3699.3 599.108 3670.28 593.071 3644.71 588.289C3600.31 579.979 3556.85 569.615 3513.73 558.985C3389.4 528.335 3267.21 494.24 3144.8 460.685C3140.84 459.603 3138.85 459.064 3134.89 457.982C3120.3 453.983 3105.72 449.979 3091.14 445.967C2977.38 414.702 2863.58 383.062 2746.47 357.059C2651.77 336.031 2550.52 315.926 2449.13 316.09C2395.11 316.3 2339.39 319.323 2289.88 334.107C2254.32 344.728 2225.31 361.251 2196.78 378.027C2169.5 394.091 2141.67 409.318 2110.59 422.406C2089.89 430.72 2077.83 444.953 2066.35 458.129C2055.62 470.548 2044.43 483.084 2027.74 492.741C2005.97 505.337 1978.31 510.755 1949.59 513.251C1919.58 515.499 1889.28 514.03 1859.43 511.559C1769.92 503.535 1680.72 491.074 1597.58 468.144C1541.34 452.636 1489.82 432.033 1440.65 408.977C1431.97 404.893 1423.34 400.772 1414.73 396.63C1376.81 378.482 1338.62 360.944 1296.11 347.275C1126.28 351.19 956.384 346.56 786.806 340.679C687.057 337.058 580.589 330.676 489.302 302.762C471.812 303.145 454.322 303.541 436.831 303.936C390.066 305.01 343.247 306.319 296.435 306.205C296.482 305.911 296.508 305.763 296.555 305.469C343.094 305.591 389.646 304.282 436.152 303.208C453.123 302.821 470.101 302.433 487.072 302.063C460.32 293.475 436.259 282.972 413.009 271.038C385.498 256.91 361.197 247.762 324.711 248.208C291.408 249.379 257.752 258.749 228.291 267.952C192.232 279.213 156.292 293.484 129.926 312.979C122.929 318.969 118.881 324.774 116.191 332.036C115.818 333 115.632 333.484 115.259 334.448C112.11 342.914 109.819 351.392 107.895 360.001C105.598 370.732 104.38 387.31 82.2822 388.219C71.3831 388.732 60.6106 386.257 50.5371 383.992C52.1683 383.832 52.9872 383.756 54.6251 383.597C63.074 385.487 71.8625 387.663 80.9839 387.499C100.072 386.489 101.177 368.863 103.015 359.972C104.939 351.354 107.229 342.872 110.379 334.402C110.752 333.442 110.938 332.962 111.311 332.002C114.014 324.682 118.089 318.86 125.173 312.84C151.032 293.715 186.559 279.688 221.759 268.461C252.945 258.514 288.359 248.726 323.733 247.493C362.002 246.903 388.654 255.929 417.596 270.831C440.979 282.82 465.174 293.353 492.092 301.949C707.144 297.348 922.841 298.085 1136.41 316.452C1192.65 321.583 1247.74 330.546 1298.9 346.459C1372.75 344.547 1446.62 341.1 1519.55 333.194C1530.83 331.944 1542.12 330.693 1553.4 329.451C1595.2 324.838 1636.99 320.219 1678.69 315.244C1975.52 279.688 2272.65 243.628 2566.49 199.085C2608.79 192.644 2650.89 185.766 2692.97 178.799C2789.94 162.73 2885.72 147.546 2986.77 150.762C3078.86 154.37 3167.77 168.578 3252.16 192.063C3334.96 215.103 3412.08 245.337 3489.01 275.201C3510.51 283.549 3532.02 291.884 3553.62 300.131C3626.7 327.991 3700.42 355.989 3767.86 389.191C3811.66 410.758 3865.17 438.024 3880.69 473.423C3883.58 480.937 3885.14 488.456 3885.95 496.164C3886.1 497.33 3886.18 497.911 3886.33 499.077C3886.69 501.742 3886.82 504.381 3886.82 506.97L3886.81 506.966ZM1301.13 347.145C1343.48 360.814 1381.57 378.288 1419.37 396.402C1428.01 400.528 1436.64 404.649 1445.3 408.75C1494.27 431.718 1545.57 452.244 1601.57 467.706C1684.21 490.527 1772.87 502.933 1861.85 510.915C1890.19 513.255 1918.91 514.725 1947.42 512.578C1975.47 510.132 2002.27 504.71 2023.41 492.346C2039.84 482.735 2050.89 470.308 2061.52 458.024C2073.03 444.759 2085.19 430.497 2106.01 422.141C2137.04 409.082 2164.81 393.881 2192.02 377.833C2220.87 360.864 2250.2 344.211 2286.22 333.535C2336.83 318.531 2393.81 315.559 2448.98 315.353C2551.38 315.18 2653.55 335.244 2749.25 356.436C2866.84 382.473 2981.08 414.226 3095.28 445.605C3109.86 449.609 3124.44 453.621 3139.03 457.62C3142.98 458.702 3144.96 459.241 3148.92 460.323C3269.29 493.314 3389.5 526.747 3511.63 557.087C3555.49 567.982 3599.67 578.632 3644.79 587.287C3669.67 592.061 3698.07 598.266 3724.5 596.869C3808.72 592.061 3888.96 557.845 3881.35 499.098C3881.21 497.932 3881.13 497.351 3880.99 496.185C3880.19 488.486 3878.64 480.984 3875.73 473.482C3860.19 438.142 3806.74 410.918 3762.99 389.385C3695.62 356.221 3621.98 328.247 3548.96 300.417C3527.34 292.174 3505.82 283.827 3484.29 275.479C3407.68 245.729 3330.87 215.613 3248.44 192.611C3164.82 169.276 3076.75 155.073 2985.45 151.495C2886.06 148.346 2791.67 163.501 2696.31 179.304C2654.19 186.279 2612.04 193.158 2569.71 199.607C2275.72 244.171 1978.45 280.248 1681.48 315.82C1639.72 320.792 1597.86 325.423 1555.99 330.037C1544.71 331.278 1533.42 332.529 1522.14 333.779C1449.01 341.71 1374.94 345.196 1300.87 347.136H1301.11L1301.13 347.145ZM494.382 302.64C584.464 330.074 689.494 336.368 787.865 339.942C956.344 345.789 1125.15 350.403 1293.89 346.56C1243.53 330.95 1189.33 322.122 1134 317.075C921.976 298.847 707.869 298.11 494.382 302.631V302.64Z" fill="url(#paint19_linear_1779_1730)" style=""/>\n<path d="M3919.68 500.424C3919.71 559.987 3832.97 590.731 3748.77 595.585C3723.55 597.033 3696.89 592.053 3672.9 587.843C3630.74 580.446 3589.47 570.991 3548.53 561.28C3418.43 530.414 3290.61 495.621 3162.69 461.354C3145.46 456.732 3128.24 452.101 3111.01 447.466C3000.93 417.855 2890.8 387.924 2777.6 363.331C2684.95 343.2 2586.36 324.282 2487.48 324.134C2434.15 324.177 2379.52 326.972 2330.14 340.704C2294.56 350.601 2264.75 366.181 2235.4 381.988C2207.19 397.207 2178.5 411.612 2146.85 423.913C2126.12 431.596 2112.84 444.94 2100.44 457.489C2088.81 469.226 2076.73 480.942 2059.79 489.934C2037.59 501.717 2010.44 506.836 1982.15 509.235C1952.01 511.433 1921.59 509.951 1891.63 507.459C1801.9 499.376 1712.66 486.903 1628.83 464.684C1571.21 449.411 1517.83 429.272 1466.54 406.851C1457.43 402.856 1448.37 398.831 1439.31 394.799C1404.43 379.269 1369.38 364.076 1331.58 351.485C1160.4 355.076 989.008 350.214 818.131 343.844C716.451 339.87 604.498 333.236 514.13 300.552C496.639 300.855 479.149 301.179 461.658 301.507C416.265 302.358 370.824 303.44 325.41 303.17C325.484 302.875 325.523 302.728 325.597 302.433C370.771 302.694 415.965 301.617 461.106 300.771C478.144 300.455 495.181 300.139 512.219 299.836C489.129 291.071 468.729 280.631 449.168 268.983C423.728 253.845 400.685 244.188 364.586 244.521C330.191 245.624 295.623 255.811 265.575 265.687C229.909 277.411 194.522 291.964 167.817 311.198C160.48 317.197 155.832 323.166 152.224 330.407C151.731 331.363 151.292 332.297 150.799 333.232C147.111 340.514 143.808 347.844 140.772 355.248C135.286 368.724 129.687 388.492 102.283 389.431C90.0453 390.008 78.041 387.512 66.6426 385.066C68.2538 384.902 69.0527 384.822 70.664 384.657C80.278 386.741 90.6777 389.145 101.044 388.724C125.505 388.354 131.318 366.543 135.945 355.215C138.974 347.806 142.244 340.464 145.972 333.181C146.465 332.255 146.964 331.308 147.397 330.356C150.952 323.065 155.679 317.079 163.05 311.055C190.147 291.526 225.974 276.75 262.266 264.955C293.172 254.91 328.466 244.912 363.713 243.801C401.863 243.363 426.837 252.696 453.809 268.802C473.476 280.509 493.989 290.975 517.232 299.752C730.047 296.115 943.327 297.723 1154.56 316.107C1217.22 321.874 1278.2 332.407 1334.68 350.761C1412.15 349.026 1489.61 345.457 1565.98 336.751C1576.04 335.602 1586.11 334.452 1596.17 333.299C1639.83 328.323 1683.48 323.339 1727.03 317.976C2026.04 280.968 2325.23 242.845 2620.66 195.553C2663.55 188.662 2706.23 181.316 2748.87 173.861C2845.99 156.879 2941.92 140.802 3043.58 143.934C3136.68 147.508 3226.32 162.322 3311.01 186.944C3394.28 211.159 3471.34 242.921 3548.18 274.271C3567.87 282.298 3587.56 290.318 3607.33 298.262C3677.19 326.319 3747.72 354.537 3811.66 387.907C3853.24 409.613 3903.84 437.182 3916.17 472.122C3918.64 479.557 3919.28 487.155 3919.43 494.733C3919.48 495.937 3919.52 496.543 3919.57 497.747V500.433C3919.62 500.433 3919.64 500.437 3919.69 500.441L3919.68 500.424ZM1336.65 351.359C1374.28 363.946 1409.2 379.046 1443.94 394.542C1452.99 398.575 1462.05 402.608 1471.16 406.594C1522.25 428.927 1575.4 449.003 1632.78 464.229C1716.14 486.343 1804.87 498.766 1894.1 506.806C1922.58 509.168 1951.43 510.645 1980.08 508.553C2007.69 506.204 2034.01 501.085 2055.56 489.521C2072.24 480.575 2084.17 468.969 2095.68 457.363C2108.17 444.742 2121.55 431.356 2142.39 423.627C2173.96 411.347 2202.62 396.975 2230.75 381.778C2260.47 365.764 2290.62 350.092 2326.7 340.115C2377.18 326.155 2433.14 323.427 2487.6 323.389C2586.2 323.537 2684.14 341.681 2776.66 361.651C2891.7 386.484 3003.49 417.022 3115.28 447.087C3132.5 451.726 3149.72 456.353 3166.95 460.975C3286.54 493.011 3405.98 525.426 3527.28 554.818C3572.04 565.666 3617.12 576.245 3663.08 584.917C3689.28 589.859 3719.24 596.351 3747.03 594.877C3831.34 590.032 3917.47 557.171 3914.78 497.73C3914.74 496.526 3914.71 495.92 3914.66 494.716C3914.51 487.143 3913.9 479.553 3911.38 472.131C3899.06 437.245 3848.5 409.718 3806.97 388.05C3743.1 354.722 3672.65 326.534 3602.87 298.502C3583.1 290.558 3563.41 282.534 3543.72 274.511C3467.98 243.616 3391.96 212.472 3309.99 188.477C3225.39 163.711 3135.78 148.228 3042.58 144.629C2942.6 141.564 2848.07 157.624 2752.57 174.32C2709.89 181.783 2667.16 189.129 2624.24 196.042C2328.67 243.359 2029.33 281.511 1730.19 318.531C1686.6 323.895 1642.9 328.891 1599.2 333.872C1589.13 335.021 1579.06 336.17 1568.99 337.323C1492.39 346.075 1414.41 349.485 1336.72 351.35C1336.69 351.35 1336.68 351.354 1336.66 351.359H1336.65ZM519.256 300.455C608.593 332.592 718.935 339.193 819.357 343.116C989.134 349.426 1159.62 354.263 1329.71 350.849C1274.01 332.819 1213.93 322.413 1152.19 316.734C942.415 298.472 730.599 296.856 519.256 300.447V300.455Z" fill="url(#paint20_linear_1779_1730)" style=""/>\n<path d="M3953.39 484.562C3953.39 487.521 3953.27 490.443 3953.07 493.327C3953.02 494.556 3952.99 495.171 3952.95 496.4C3950.22 557.739 3857.6 588.601 3771.21 593.614C3745.7 595.084 3718.8 590.263 3694.43 586.138C3651.53 578.88 3609.51 569.539 3567.81 559.928C3440.6 530.608 3315.59 497.448 3190.51 464.743C3170.84 459.599 3151.19 454.425 3131.54 449.259C3025.03 421.24 2918.46 392.913 2809.02 369.7C2718.32 350.462 2622.36 332.651 2525.89 332.205C2473.31 332.078 2419.6 334.612 2370.44 347.338C2334.77 356.574 2304.2 371.127 2274.01 385.988C2244.86 400.334 2215.28 413.906 2183.1 425.437C2162.29 432.543 2147.99 445.016 2134.47 456.875C2121.93 467.892 2108.98 478.82 2091.84 487.172C2069.38 498.122 2042.49 502.95 2014.75 505.236C1984.44 507.379 1953.89 505.884 1923.78 503.363C1833.84 495.217 1744.55 482.739 1660.08 461.228C1601.05 446.195 1545.83 426.514 1492.44 404.733C1482.92 400.827 1473.41 396.895 1463.91 392.963C1432.48 379.9 1400.91 367.061 1367.76 355.796C1194.97 359.189 1022.03 353.914 849.605 347.035C746.746 342.737 629.067 335.909 540.902 298.333C522.853 298.569 504.81 298.822 486.76 299.078C442.704 299.714 398.602 300.56 354.533 300.156C354.66 299.861 354.72 299.714 354.84 299.419C398.642 299.811 442.478 298.977 486.267 298.342C503.924 298.085 521.574 297.832 539.231 297.605C519.311 288.647 502.093 278.299 485.582 266.95C462.119 250.705 440.694 240.656 404.588 240.85C370.379 241.843 335.964 252.258 306.257 262.21C269.538 274.511 233.771 289.804 205.841 309.438C198.191 315.458 192.885 321.571 188.517 328.79C187.838 329.885 187.153 330.975 186.473 332.04C182.652 338.115 179.017 344.223 175.461 350.361C166.007 366.901 155.76 389.478 122.557 390.669C108.915 391.174 95.8255 388.838 83.0156 386.16C84.6268 385.992 85.4258 385.912 87.037 385.743C97.9894 388.017 109.661 390.458 121.379 389.957C151.932 388.85 162.239 365.137 170.694 350.302C174.196 344.147 177.878 338.048 181.706 331.973C182.385 330.904 183.071 329.818 183.75 328.723C188.125 321.47 193.451 315.332 201.141 309.287C227.653 290.663 261.975 276.064 296.423 263.969C328.867 252.582 366.171 241.195 403.909 240.121C441.999 239.288 465.694 249.69 490.349 266.786C506.9 278.202 524.198 288.571 544.245 297.538C754.223 294.877 964.541 297.424 1172.85 315.774C1241.99 322.194 1308.64 334.419 1370.67 354.983C1451.66 353.165 1532.74 349.498 1612.55 340.304C1621.42 339.26 1630.29 338.216 1639.15 337.176C1684.65 331.83 1730.14 326.471 1775.52 320.712C2076.71 282.273 2377.97 242.071 2674.95 192.009C2718.32 184.667 2761.49 176.866 2804.59 168.935C2901.98 151.044 2998.14 134.024 3100.54 137.081C3195.86 140.68 3287.32 156.891 3373.2 183.093C3456.23 208.431 3532.66 241.355 3608.78 274.005C3626.23 281.486 3643.69 288.958 3661.2 296.38C3727.84 324.606 3795.15 353.017 3855.56 386.518C3894.94 408.358 3942.66 436.411 3951.84 470.805C3953.07 475.284 3953.54 480.045 3953.45 484.587C3953.43 484.579 3953.42 484.575 3953.39 484.566L3953.39 484.562ZM1372.77 355.682C1405.78 366.901 1437.2 379.698 1468.5 392.698C1477.96 396.642 1487.44 400.57 1496.96 404.468C1550.14 426.169 1605.14 445.787 1663.94 460.773C1747.94 482.188 1836.74 494.619 1926.2 502.723C1954.86 505.118 1983.85 506.604 2012.69 504.562C2039.76 502.327 2065.85 497.507 2087.68 486.764C2104.55 478.462 2117.32 467.639 2129.69 456.749C2143.27 444.793 2157.71 432.303 2178.64 425.138C2210.75 413.624 2240.3 400.107 2269.35 385.765C2299.92 370.74 2330.91 355.989 2367.07 346.724C2417.4 333.829 2472.33 331.316 2526.09 331.455C2622.27 331.91 2717.71 348.98 2808.25 368.096C2919.43 391.57 3027.6 420.427 3135.75 448.876C3155.4 454.054 3175.05 459.215 3194.71 464.36C3309.77 494.459 3424.76 524.798 3541.44 552.338C3587.31 563.166 3633.46 573.707 3680.46 582.425C3708.13 587.557 3740.1 594.599 3769.41 592.924C3855.13 587.957 3945.33 556.923 3948.07 496.391C3948.11 495.162 3948.14 494.547 3948.19 493.318C3948.66 485.804 3948.72 478.26 3946.87 470.809C3937.73 436.47 3890.05 408.459 3850.73 386.657C3790.38 353.19 3723.14 324.804 3656.56 296.611C3639.06 289.186 3621.59 281.713 3604.14 274.237C3528.31 241.717 3452.18 208.907 3369.5 183.606C3284.45 157.578 3193.91 141.362 3099.43 137.784C2998.6 134.757 2904.11 151.764 2808.23 169.386C2765.08 177.321 2721.88 185.134 2678.48 192.489C2381.33 242.576 2079.91 282.804 1778.56 321.255C1733.12 327.018 1687.55 332.386 1641.99 337.74C1633.12 338.784 1624.25 339.824 1615.39 340.868C1535.29 350.104 1453.93 353.817 1372.65 355.661C1372.69 355.661 1372.72 355.665 1372.77 355.669L1372.77 355.682ZM545.923 298.245C633.155 335.223 749.116 342.047 850.79 346.303C1022.09 353.135 1193.93 358.406 1365.6 355.084C1304.36 334.827 1238.57 322.741 1170.32 316.401C963.396 298.165 754.463 295.622 545.869 298.241H545.929L545.923 298.245Z" fill="url(#paint21_linear_1779_1730)" style=""/>\n<path d="M3988.02 477.46C3987.82 482.356 3987.33 487.168 3986.67 492.047C3986.49 493.251 3986.41 493.857 3986.23 495.061C3978.02 556.687 3880.77 586.555 3793.67 591.64C3766.79 593.219 3738.27 588.024 3712.57 583.743C3668.89 576.464 3626.01 567.224 3583.46 557.685C3460.43 530.107 3339.39 498.98 3218.35 468.123C3196.47 462.537 3174.61 456.917 3152.75 451.305C3049.68 424.818 2946.56 398.078 2840.77 376.158C2751.8 357.724 2658.56 341.243 2564.31 340.266C2512.44 339.971 2459.7 342.27 2410.77 353.977C2374.99 362.535 2343.63 376.129 2312.61 390.016C2282.55 403.483 2252.09 416.201 2219.37 426.956C2198.44 433.507 2183.12 445.096 2168.56 456.277C2155.15 466.561 2141.36 476.715 2123.97 484.41C2101.14 494.51 2074.82 499.064 2047.47 501.245C2016.97 503.325 1986.25 501.813 1955.95 499.262C1865.8 491.053 1776.43 478.584 1691.33 457.763C1630.83 442.962 1573.76 423.753 1518.29 402.603C1508.35 398.794 1498.43 394.963 1488.52 391.119C1460.7 380.321 1432.8 369.654 1404 359.917C1229.59 363.074 1055.01 357.635 881.028 350.209C777.583 345.612 653.925 338.57 569.11 296.094C550.008 296.254 530.913 296.443 511.811 296.632C469.114 297.053 426.37 297.681 383.666 297.142C383.839 296.847 383.926 296.7 384.099 296.405C426.576 296.931 469.087 296.321 511.565 295.892C530.294 295.706 549.023 295.53 567.752 295.361C550.601 286.277 536.026 276.039 522.271 264.904C500.906 247.585 481.018 237.116 444.799 237.17C410.837 238.063 376.489 248.949 347.187 258.947C309.516 271.804 273.111 287.687 244.009 307.679C236.053 313.728 230.174 319.971 225.074 327.153C224.148 328.399 223.283 329.628 222.351 330.849C218.775 335.665 215.26 340.498 211.771 345.339C197.676 364.939 182.336 390.235 142.968 391.915C127.974 392.466 113.613 390.113 99.4648 387.263C101.049 387.095 101.842 387.006 103.426 386.838C115.837 389.351 128.613 391.654 141.789 391.203C178.741 389.579 193.901 363.478 206.944 345.263C210.433 340.422 213.948 335.589 217.524 330.773C218.449 329.552 219.315 328.323 220.247 327.077C225.36 319.857 231.299 313.598 239.302 307.527C267.944 287.859 303.771 272.149 340.696 259.343C371.855 248.537 407.974 237.377 444.173 236.451C482.683 236.261 504.201 246.263 527.085 264.782C540.927 275.95 555.561 286.222 572.812 295.332C779.454 293.681 986.31 297.167 1191.2 315.446C1267 322.556 1339.41 336.578 1407.27 359.193C1491.61 357.53 1576.18 353.935 1659.18 343.882C1666.5 342.994 1673.82 342.106 1681.14 341.217C1728.83 335.454 1776.52 329.67 1824.08 323.465C2127.49 283.599 2430.8 241.334 2729.31 188.498C2773.04 180.718 2816.55 172.463 2860 164.09C2957.92 145.218 3054.13 127.238 3157.57 130.257C3254.49 133.839 3347.14 150.884 3433.65 178.496C3517.63 205.299 3594.33 240.096 3670.71 274.553C3685.5 281.225 3700.3 287.893 3715.14 294.528C3778.55 322.893 3842.66 351.464 3899.49 385.083C3936.83 407.171 3981.41 435.628 3987.52 469.521C3988 472.207 3988.18 474.871 3988.18 477.511C3988.11 477.49 3988.08 477.481 3988 477.464L3988.02 477.46ZM1409.03 359.799C1437.61 369.511 1465.35 380.107 1493.01 390.833C1502.91 394.676 1512.81 398.512 1522.75 402.317C1578.02 423.387 1634.87 442.541 1695.14 457.3C1779.79 478.029 1868.69 490.451 1958.36 498.614C1987.24 501.043 2016.43 502.537 2045.5 500.563C2097.18 496.433 2131.52 480.967 2163.79 456.125C2178.46 444.865 2193.9 433.229 2214.98 426.632C2247.65 415.906 2278.02 403.205 2308.03 389.768C2339.46 375.699 2371.24 361.963 2407.53 353.35C2457.61 341.462 2511.61 339.201 2564.64 339.517C2658.6 340.489 2751.31 356.318 2840.1 374.605C2947.58 396.739 3052.26 424.022 3156.91 450.918C3178.77 456.534 3200.64 462.145 3222.51 467.736C3334.54 496.311 3446.55 525.055 3560.13 551.105C3607.32 561.928 3654.81 572.456 3703.16 581.053C3730.87 585.982 3762.65 592.638 3791.89 590.954C3878.27 585.911 3973.33 555.908 3981.42 495.044C3981.59 493.836 3981.67 493.23 3981.85 492.022C3982.84 484.432 3983.37 477.094 3982.53 469.487C3976.41 435.645 3931.89 407.23 3894.59 385.175C3837.81 351.59 3773.76 323.048 3710.4 294.721C3695.56 288.091 3680.77 281.423 3665.98 274.746C3589.89 240.412 3513.5 205.741 3429.9 178.98C3344.2 151.549 3252.47 134.496 3156.41 130.939C3054.73 127.988 2959.91 145.971 2863.68 164.507C2820.17 172.888 2776.6 181.156 2732.82 188.94C2434.13 241.805 2130.66 284.1 1827.08 323.983C1779.48 330.201 1731.75 335.985 1684.02 341.756C1676.69 342.645 1669.38 343.533 1662.05 344.421C1578.77 354.503 1493.65 358.002 1409.04 359.791V359.799H1409.03ZM574.07 296.031C658.067 337.892 779.954 344.926 882.273 349.477C1055.13 356.802 1228.75 362.27 1402.03 359.252C1334.92 336.949 1263.48 323.09 1188.56 316.052C984.958 297.895 779.401 294.406 574.063 296.022V296.031H574.07Z" fill="url(#paint22_linear_1779_1730)" style=""/>\n<path d="M4023.11 471.979C4022.79 478.323 4021.8 484.545 4020.27 490.818C4020 491.98 4019.86 492.561 4019.59 493.722C4005.68 556.249 3905.19 584.256 3816.15 589.678C3792.34 591.08 3767.44 587.237 3744.47 583.776C3704.01 577.681 3664.29 569.577 3624.9 561.2C3497.16 534.03 3371.62 502.639 3246.21 471.499C3222.31 465.555 3198.42 459.582 3174.55 453.587C3073.64 428.283 2972.7 402.646 2869.21 381.791C2783.16 364.447 2693.56 349.544 2602.75 348.298C2551.61 347.835 2499.7 349.873 2451.05 360.595C2415.14 368.509 2383.01 381.126 2351.18 394.041C2320.18 406.603 2288.88 418.474 2255.58 428.451C2234.64 435.195 2218.64 444.961 2202.62 455.667C2167.8 479.039 2131.64 493.301 2080.27 497.242C2049.51 499.258 2018.56 497.726 1988.01 495.133C1897.66 486.869 1808.17 474.417 1722.48 454.269C1660.52 439.704 1601.63 420.954 1544.12 400.444C1533.73 396.727 1523.37 392.984 1513.01 389.233C1489.36 380.679 1465.69 372.171 1441.59 364.135C1265.04 367.162 1088.36 361.289 912.302 353.341C840.968 349.986 768.41 344.526 700.386 329.86C663.401 321.882 627.248 310.798 598.406 293.837C577.886 293.913 557.36 294.01 536.84 294.119C495.434 294.343 453.995 294.751 412.596 294.073C412.796 293.778 412.889 293.631 413.089 293.336C454.242 294.006 495.441 293.597 536.594 293.383C556.767 293.273 576.934 293.176 597.108 293.101C582.314 283.907 570.077 273.732 558.618 262.824C539.936 244.963 520.568 232.885 484.555 233.445C451.013 234.236 416.997 245.291 388.208 255.247C349.306 268.705 312.248 285.388 281.788 305.86C273.505 311.947 267.054 318.3 261.248 325.448C260.069 326.85 258.958 328.235 257.779 329.599C254.763 333.101 251.794 336.616 248.871 340.148C230.189 362.371 208.77 391.755 162.983 393.094C146.651 393.704 130.998 391.309 115.525 388.29C117.083 388.118 117.862 388.029 119.427 387.857C133.169 390.547 147.224 392.883 161.752 392.374C205.181 391.153 226.473 360.881 243.984 340.051C246.953 336.532 249.889 333.009 252.892 329.502C254.071 328.138 255.182 326.753 256.361 325.351C262.18 318.182 268.672 311.804 276.967 305.692C306.808 285.607 343.167 269.177 381.131 255.794C411.957 244.929 447.93 233.517 483.943 232.696C522.659 232.654 542.786 243.064 563.332 262.69C574.87 273.635 587.181 283.852 602.068 293.071C804.976 292.444 1007.98 296.885 1209.07 315.05C1291.84 322.88 1370.27 338.839 1444.44 363.335C1531.71 361.601 1619.57 358.052 1705.39 347.368C1712.29 346.509 1715.74 346.08 1722.64 345.221C1772.55 339.02 1822.46 332.807 1872.21 326.126C2134.65 290.684 2396.43 252.591 2655.31 207.774C2698.06 200.374 2740.73 192.767 2783.27 184.878C2827.28 176.681 2871.04 168.001 2914.75 159.186C3013.12 139.379 3109.75 120.393 3214.17 123.34C3313.01 126.914 3407.15 144.906 3494.52 174.105C3579.67 202.563 3656.79 239.461 3733.57 275.959C3745.22 281.507 3756.9 287.047 3768.59 292.566C3828.79 321.032 3889.71 349.742 3942.95 383.449C3978.34 405.866 4019.59 434.728 4022.71 468.115C4022.83 469.39 4022.89 470.666 4022.89 471.933C4022.99 471.954 4023.04 471.963 4023.13 471.979H4023.11ZM1446.72 364.064C1470.59 372.049 1494.07 380.473 1517.51 388.964C1527.84 392.715 1538.2 396.453 1548.56 400.166C1605.87 420.604 1664.56 439.295 1726.3 453.814C1811.55 473.869 1900.59 486.276 1990.48 494.505C2019.6 496.968 2049.03 498.492 2078.35 496.568C2128.64 492.699 2163.79 478.344 2197.83 455.515C2213.55 444.957 2229.99 434.189 2251.23 428.123C2284.45 418.167 2315.68 406.325 2346.6 393.788C2378.55 380.835 2410.84 368.299 2446.88 360.376C2497.04 349.351 2550.42 347.086 2603.13 347.566C2694.81 348.816 2785.24 363.706 2872.15 381.176C2976.07 402.069 3077.39 427.799 3178.7 453.2C3202.58 459.186 3226.46 465.164 3250.36 471.112C3366.59 499.974 3482.89 528.924 3600.91 554.763C3643.76 564.142 3686.89 573.235 3730.75 580.548C3757.16 584.951 3786.69 590.55 3814.35 588.988C3902.68 583.789 4001.04 555.39 4014.76 493.693C4015.04 492.531 4015.18 491.954 4015.45 490.792C4017.19 483.346 4018.91 475.722 4018.11 468.174C4014.99 434.829 3973.74 406.005 3938.39 383.626C3885.19 349.953 3824.32 321.272 3764.18 292.831C3752.49 287.312 3740.81 281.772 3729.15 276.224C3652.65 239.865 3575.81 203.085 3491.02 174.665C3404.52 145.668 3311.3 127.647 3213.34 124.102C3110.98 120.793 3015.13 140.267 2918.82 159.674C2875.07 168.498 2831.25 177.186 2787.21 185.395C2744.64 193.289 2701.95 200.9 2659.17 208.305C2400.13 253.146 2138.19 291.261 1875.58 326.715C1825.77 333.409 1775.81 339.626 1725.85 345.827C1718.94 346.686 1715.49 347.115 1708.58 347.974C1622.45 358.679 1534.31 362.296 1446.72 364.064V364.072L1446.72 364.064ZM603.473 293.842C632.129 310.613 667.948 321.579 704.627 329.481C771.779 343.945 843.372 349.346 913.786 352.66C1088.67 360.561 1264.17 366.408 1439.55 363.466C1366.16 339.294 1288.62 323.482 1206.77 315.728C1006.9 297.685 805.142 293.244 603.473 293.854V293.846V293.842Z" fill="url(#paint23_linear_1779_1730)" style=""/>\n<path d="M4058.44 467.193C4058.51 474.754 4056.11 482.297 4053.75 489.673C4053.4 490.763 4053.23 491.306 4052.88 492.396C4033.22 555.327 3928.9 581.684 3838.54 587.717C3813.94 589.165 3788.2 585.3 3764.41 581.823C3723.97 575.913 3684.22 568.108 3644.77 560C3519.74 534.3 3396.78 504.516 3273.98 474.884C3248.24 468.658 3222.53 462.385 3196.82 456.113C3099.15 432.252 3001.47 408.072 2901.41 388.442C2817.13 371.906 2729.7 357.854 2641.04 356.368C2590.57 355.733 2539.6 357.555 2491.18 367.276C2455.07 374.525 2422.17 386.207 2389.52 398.141C2357.64 409.789 2325.5 420.798 2291.64 429.996C2270.48 436.163 2253.51 445.206 2236.5 455.132C2200.13 476.408 2163.15 489.664 2113.11 493.301C2082.04 495.242 2050.89 493.697 2020.05 491.062C1929.5 482.735 1839.87 470.316 1753.6 450.838C1690.13 436.508 1629.39 418.221 1569.85 398.347C1559.03 394.719 1548.22 391.065 1537.42 387.411C1518.3 380.94 1499.17 374.495 1479.87 368.24C1301.05 371.254 1121.9 364.981 943.656 356.545C870.745 352.933 796.109 347.149 727.199 330.845C690.627 322.194 655.367 310.045 628.708 291.682C606.451 291.652 584.2 291.652 561.942 291.661C521.835 291.682 481.688 291.88 441.594 291.063C441.84 290.768 441.966 290.621 442.213 290.326C482.08 291.13 522.001 290.937 561.883 290.912C583.787 290.903 605.692 290.899 627.597 290.933C614.913 281.6 604.633 271.522 595.172 260.795C578.667 242.058 560.837 229.324 524.445 229.77C491.129 230.469 457.32 241.742 428.89 251.749C388.976 265.796 351.358 283.22 319.693 304.101C311.111 310.234 304.107 316.683 297.669 323.794C296.244 325.355 294.819 326.896 293.401 328.407C290.924 331.013 289.686 332.314 287.209 334.92C263.374 360.005 235.657 392.757 183.199 394.331C165.528 394.992 148.577 392.61 131.779 389.389C133.337 389.212 134.116 389.124 135.674 388.947C150.768 391.81 166.121 394.171 182.02 393.607C232.155 392.138 259.825 358.578 282.442 334.798C284.919 332.192 286.157 330.891 288.634 328.285C290.059 326.774 291.477 325.233 292.902 323.671C299.36 316.528 306.424 310.07 315.053 303.915C346.125 283.427 383.07 266.268 422.066 252.3C452.513 241.393 488.292 229.715 524.065 229.012C562.901 228.557 582.183 240.429 600.046 260.677C609.58 271.442 619.887 281.558 632.657 290.92C831.483 291.32 1030.31 296.717 1227.28 314.713C1317.29 323.322 1401.78 341.348 1482.78 367.415C1572.73 365.756 1663.49 362.279 1751.87 350.938C1756.5 350.344 1758.81 350.049 1763.44 349.456C1815.86 342.767 1868.28 336.077 1920.54 328.866C2184.34 292.301 2447.31 252.637 2707.03 205.724C2750.62 197.852 2794.09 189.757 2837.42 181.354C2881.62 172.741 2925.57 163.648 2969.46 154.425C3068.35 133.641 3165.56 113.637 3271.06 116.508C3372.23 120.082 3468.16 139.185 3556.59 170.177C3643.22 200.542 3720.94 239.818 3798.3 278.628C3806.33 282.669 3814.38 286.693 3822.44 290.709C3879.44 319.255 3937.19 348.084 3986.8 381.85C4020.35 404.683 4058.12 433.932 4058.37 466.835V467.184C4058.37 467.184 4058.4 467.197 4058.43 467.205L4058.44 467.193ZM1485.07 368.139C1504.14 374.318 1523.04 380.692 1541.94 387.091C1552.74 390.745 1563.54 394.394 1574.36 398.027C1633.7 417.834 1694.23 436.058 1757.47 450.346C1843.33 469.744 1932.53 482.116 2022.65 490.409C2052.06 492.927 2081.8 494.455 2111.44 492.603C2160.46 488.995 2196.39 475.713 2231.99 454.926C2249.16 444.928 2266.28 435.826 2287.61 429.609C2321.37 420.44 2353.42 409.474 2385.19 397.838C2417.96 385.861 2451.01 374.281 2487.25 366.989C2537.1 356.958 2589.67 354.971 2641.66 355.623C2731.13 357.122 2819.38 371.161 2904.46 387.827C3004.92 407.504 3102.99 431.756 3201.03 455.709C3226.74 461.985 3252.44 468.271 3278.2 474.484C3391.5 501.83 3504.92 529.181 3619.93 553.551C3664.11 562.913 3708.59 571.968 3753.8 579.158C3780.16 583.351 3809.4 588.58 3836.88 587.022C3926.48 581.549 4028.83 554.224 4048.2 492.35C4048.54 491.26 4048.72 490.717 4049.06 489.626C4051.48 482.158 4053.88 474.505 4053.76 466.843C4053.54 433.987 4015.78 404.776 3982.28 381.984C3932.71 348.256 3875.01 319.458 3818.08 290.937C3810.03 286.908 3801.98 282.879 3793.94 278.855C3716.85 240.189 3639.42 201.03 3553.16 170.708C3465.63 139.935 3370.66 120.802 3270.4 117.249C3166.98 114.003 3070.53 134.53 2973.7 154.871C2929.78 164.115 2885.79 173.217 2841.54 181.83C2798.18 190.241 2754.67 198.34 2711.06 206.221C2451.18 253.163 2188.05 292.848 1924.09 329.439C1871.77 336.65 1819.29 343.352 1766.8 350.045C1762.18 350.639 1759.87 350.934 1755.24 351.527C1666.55 362.906 1575.47 366.455 1485.2 368.147C1485.15 368.147 1485.13 368.143 1485.08 368.139H1485.07ZM633.842 291.682C660.327 309.843 695.268 321.866 731.527 330.436C799.565 346.522 873.228 352.26 945.201 355.825C1122.26 364.207 1300.21 370.445 1477.83 367.52C1397.63 341.769 1314.01 323.89 1224.94 315.366C1029.16 297.466 831.529 292.09 633.902 291.678H633.842V291.682Z" fill="url(#paint24_linear_1779_1730)" style=""/>\n<path d="M4094.17 462.381C4094.17 463.438 4094.17 464.478 4094.03 465.53C4092.95 473.411 4090.4 480.942 4087.24 488.595C4086.85 489.58 4086.65 490.068 4086.26 491.053C4060.7 554.473 3953.87 579.571 3861.08 585.742C3835.97 587.258 3809.64 583.427 3785.3 580.009C3744.56 574.283 3704.45 566.714 3664.64 558.821C3542.38 534.582 3422.04 506.406 3301.91 478.273C3274.53 471.845 3247.19 465.357 3219.85 458.853C3125.32 436.382 3030.75 413.624 2934.02 395.156C2851.47 379.395 2766.16 366.177 2679.61 364.417C2629.82 363.617 2579.68 365.196 2531.57 373.948C2495.22 380.557 2461.55 391.288 2428.1 402.25C2395.39 412.989 2362.43 423.1 2328.04 431.516C2306.61 437.123 2288.68 445.467 2270.67 454.581C2232.94 473.768 2195.26 485.989 2146.43 489.357C2115.02 491.213 2083.55 489.643 2052.38 486.957C1961.63 478.563 1871.84 466.191 1785 447.365C1720 433.271 1657.41 415.464 1595.86 396.217C1584.58 392.685 1573.33 389.12 1562.08 385.546C1548.12 381.121 1534.15 376.705 1520.12 372.348C1477.29 373.022 1434.45 373.144 1391.61 372.87C1252.6 371.877 1113.74 366.61 975.179 359.719C900.916 355.863 824.303 349.767 754.794 331.809C718.654 322.472 684.346 309.257 660.105 289.56C635.85 289.396 611.595 289.274 587.34 289.165C548.484 288.988 509.595 288.975 470.766 288.041C471.065 287.75 471.212 287.603 471.512 287.312C510.134 288.238 548.824 288.251 587.466 288.428C611.368 288.537 635.277 288.651 659.179 288.815C648.333 279.335 639.838 269.375 632.081 258.775C617.7 239.124 601.754 225.754 564.636 226.095C531.593 226.697 497.997 238.215 469.967 248.246C428.907 262.938 391.05 281.158 357.847 302.341C348.959 308.521 341.442 315.042 334.398 322.11C332.667 323.84 330.929 325.541 329.198 327.224C328.186 328.184 327.68 328.664 326.661 329.624C296.927 358.01 263.444 393.329 203.589 395.577C184.554 396.293 166.298 393.881 148.148 390.492C149.686 390.315 150.452 390.227 151.983 390.046C168.402 393.119 185.107 395.493 202.351 394.858C259.935 392.681 293.365 356.663 321.834 329.51C322.846 328.551 323.352 328.071 324.371 327.107C326.102 325.427 327.84 323.722 329.571 322.004C336.628 314.915 344.165 308.378 353.08 302.181C385.378 281.276 422.988 263.401 463.029 248.848C493.09 237.92 528.677 225.973 564.203 225.366C603.539 225.025 621.355 237.554 636.848 258.699C644.685 269.337 653.234 279.343 664.139 288.866C858.618 290.297 1052.99 296.599 1245.59 314.414C1343.34 323.857 1434.36 344.16 1522.92 371.565C1615.01 369.881 1708.11 366.404 1798.52 354.533C1800.32 354.297 1801.23 354.179 1803.03 353.948C1858.47 346.707 1913.92 339.454 1969.17 331.649C2279.37 287.573 2588.94 239.174 2891.87 177.868C2936.17 168.872 2980.2 159.379 3024.15 149.748C3123.63 127.992 3221.43 106.914 3328.09 109.713C3432.07 113.3 3530.14 133.696 3619.89 166.734C3708.28 199.271 3786.72 241.33 3864.8 282.774C3869.41 285.212 3871.72 286.432 3876.32 288.874C3928.68 316.688 3981.54 344.901 4026.61 377.551C4058.65 400.76 4094.09 430.038 4094.13 462.411C4094.15 462.398 4094.16 462.394 4094.19 462.381H4094.17ZM1525.25 372.251C1539.02 376.537 1552.74 380.873 1566.46 385.222C1577.71 388.796 1588.96 392.361 1600.24 395.893C1661.59 415.077 1723.96 432.829 1788.75 446.885C1875.17 465.635 1964.53 477.961 2054.85 486.318C2084.61 488.885 2114.69 490.439 2144.69 488.662C2192.38 485.332 2229.2 473.108 2266.02 454.358C2284.21 445.159 2302.3 436.761 2323.94 431.103C2358.23 422.717 2391.08 412.627 2423.69 401.921C2457.28 390.913 2491.11 380.267 2527.59 373.615C2577.15 364.581 2628.87 362.847 2680.17 363.672C2767.51 365.44 2853.6 378.659 2936.92 394.533C3034.04 413.039 3128.98 435.877 3223.87 458.441C3251.2 464.945 3278.54 471.428 3305.91 477.856C3420.12 504.604 3534.51 531.286 3650.51 554.776C3692.68 563.313 3735.12 571.539 3778.21 578.009C3804.04 581.89 3832.41 586.593 3859.21 585.052C3950.35 578.956 4056.3 553.184 4081.34 490.995C4081.74 490.009 4081.94 489.521 4082.33 488.536C4085.5 480.9 4088.03 473.381 4089.08 465.509C4091.66 432.838 4056.06 402.751 4024.1 379.349C3978.55 345.996 3924.79 317.311 3871.58 289.034C3866.98 286.597 3864.67 285.376 3860.07 282.938C3782.25 241.629 3704.08 199.738 3616.07 167.214C3527.23 134.382 3430.12 113.961 3327.07 110.395C3222.51 107.204 3125.41 128.83 3028.03 150.126C2984.02 159.754 2939.95 169.264 2895.61 178.268C2592.49 239.612 2282.74 288.041 1972.36 332.15C1917.07 339.971 1861.58 347.225 1806.1 354.478C1804.29 354.714 1803.38 354.832 1801.57 355.063C1710.88 366.985 1617.5 370.525 1525.12 372.247H1525.24L1525.25 372.251ZM665.105 289.594C689.213 309.076 723.222 322.181 759.048 331.434C827.698 349.165 903.366 355.206 976.716 359.016C1114.86 365.878 1253.31 371.136 1391.91 372.129C1433.9 372.395 1475.89 372.281 1517.88 371.649C1430.16 344.526 1339.97 324.396 1243.16 315.046C1051.71 297.331 858.491 291.05 665.171 289.607C665.145 289.607 665.131 289.602 665.111 289.598L665.105 289.594Z" fill="url(#paint25_linear_1779_1730)" style=""/>\n<path d="M4130.16 457.346C4130.16 459.653 4129.98 461.939 4129.6 464.221C4127.81 472.27 4124.48 479.86 4120.63 487.606C4120.21 488.448 4120 488.873 4119.58 489.715C4088.29 552.944 3978.09 577.495 3883.52 583.781C3855.37 585.422 3825.85 580.994 3798.59 577.154C3755.79 571.126 3713.59 563.368 3671.67 555.256C3556.55 532.969 3443.04 507.362 3329.74 481.662C3300.89 475.103 3272.09 468.46 3243.28 461.809C3151.77 440.676 3060.23 419.316 2966.71 401.942C2885.87 386.926 2802.54 374.495 2718.02 372.487C2668.9 371.515 2619.47 372.828 2571.69 380.646C2535.06 386.64 2500.62 396.419 2466.38 406.413C2432.85 416.196 2399.14 425.428 2364.21 433.052C2342.47 438.125 2323.59 445.744 2304.64 454.075C2265.84 471.167 2227.35 482.377 2179.76 485.459C2147.94 487.223 2116.09 485.61 2084.54 482.87C1993.59 474.408 1903.63 462.103 1816.25 443.913C1749.7 430.059 1685.28 412.728 1621.76 394.104C1610.02 390.648 1598.28 387.175 1586.55 383.685C1578.39 381.26 1570.22 378.84 1562.05 376.415C1376.8 379.42 1191.2 372.491 1006.65 362.897C931.206 358.806 852.649 352.428 782.794 332.806C747.067 322.775 713.824 308.445 692.133 287.51C665.694 287.182 639.249 286.912 612.81 286.66C575.172 286.293 537.495 286.07 499.884 285.014C500.231 284.723 500.404 284.576 500.75 284.285C538.174 285.35 575.665 285.557 613.116 285.923C639.189 286.176 665.261 286.445 691.327 286.765C682.126 277.175 675.115 267.219 668.863 256.741C656.739 236.375 642.378 222.171 604.634 222.407C570.339 222.912 535.678 235.419 507.002 246.146C466.675 261.229 428.904 279.545 395.867 300.564C386.686 306.778 378.67 313.337 371.12 320.379C369.076 322.278 366.972 324.16 364.928 326.012C329.834 356.958 290.179 394.302 223.972 396.794C203.659 397.564 183.985 395.148 164.57 391.578C166.108 391.397 166.874 391.304 168.405 391.123C186.175 394.373 204.178 396.764 222.794 396.087C286.757 393.666 326.405 355.678 360.161 325.898C362.265 324.046 364.309 322.173 366.353 320.274C374.043 313.248 381.992 306.652 391.227 300.413C423.291 279.84 460.429 261.995 499.512 247.097C530.438 235.31 567.343 222.209 604.454 221.687C644.342 221.047 660.794 235.028 673.757 256.691C680.075 267.207 687.093 277.213 696.34 286.845C886.205 289.299 1075.88 296.477 1263.87 314.086C1369.86 324.421 1468.04 347.086 1564.83 375.644C1658.47 373.982 1753.22 370.458 1845.07 358.103C1902.67 350.395 1960.26 342.691 2017.65 334.385C2330.2 288.92 2641.77 238.509 2946.16 174.328C2990.46 164.945 3034.5 155.081 3078.46 145.079C3178.23 122.389 3277.39 99.6773 3385.06 102.872C3492.74 106.51 3592.17 128.653 3684.03 163.842C3773.3 198.833 3851.97 242.921 3930.11 286.996C3978.43 314.284 4027.07 341.992 4068.2 373.771C4098.42 397.118 4130.12 425.912 4130.16 457.376V457.338V457.346ZM1567.13 376.318C1575.03 378.654 1582.93 380.995 1590.82 383.331C1602.55 386.813 1614.28 390.294 1626.03 393.746C1689.35 412.311 1753.56 429.592 1819.9 443.408C1906.88 461.527 1996.46 473.794 2087.01 482.217C2117.19 484.844 2147.65 486.419 2178.09 484.743C2224.59 481.699 2262.14 470.506 2300.03 453.81C2319.19 445.403 2338.28 437.733 2360.25 432.61C2395.04 425.016 2428.62 415.801 2462.03 406.068C2496.43 396.028 2531.02 386.303 2567.82 380.292C2617.1 372.243 2668.01 370.753 2718.69 371.75C2803.97 373.78 2888.02 386.223 2969.62 401.336C3063.53 418.731 3155.43 440.188 3247.31 461.4C3276.09 468.052 3304.9 474.694 3333.74 481.253C3444.87 506.465 3556.23 531.521 3669.06 553.551C3711.37 561.81 3753.94 569.741 3797.11 576.018C3824.14 579.946 3853.72 584.724 3881.71 583.111C3975.49 576.868 4083.8 552.271 4114.76 489.681C4115.18 488.839 4115.38 488.414 4115.8 487.572C4119.62 479.839 4122.93 472.244 4124.77 464.225C4130.14 432.059 4098.38 401.593 4068.24 377.619C4026.28 344.257 3975.6 315.488 3925.46 287.182C3848.31 243.674 3770.62 199.725 3682.33 165.302C3591.45 129.874 3491.18 107.217 3384.12 103.588C3278.32 100.452 3180.46 123.201 3082.46 145.483C3038.45 155.49 2994.39 165.374 2950.04 174.757C2645.45 238.981 2333.68 289.421 2020.93 334.916C1963.49 343.221 1905.86 350.942 1848.22 358.65C1756.07 371.043 1661.06 374.638 1567.11 376.347V376.318H1567.13ZM697.086 287.573C718.705 308.302 751.661 322.493 787.108 332.444C856.118 351.817 933.676 358.149 1008.2 362.194C1191.43 371.717 1375.7 378.616 1559.64 375.703C1463.7 347.418 1366.38 324.934 1261.34 314.696C1074.47 297.188 885.899 290.04 697.153 287.577H697.093L697.086 287.573Z" fill="url(#paint26_linear_1779_1730)" style=""/>\n<path d="M4166.5 452.274C4166.5 455.856 4166.06 459.401 4165.19 462.907C4162.63 471.142 4158.54 478.871 4153.94 486.738C4153.55 487.391 4153.34 487.719 4152.94 488.372C4115.91 551.336 4002.54 575.382 3906 581.806C3884.28 583.111 3861.88 580.653 3840.6 578.182C3803.95 573.93 3767.8 567.91 3731.94 561.583C3605.65 539.301 3481.43 512.182 3357.6 485.038C3327.45 478.407 3297.35 471.68 3267.26 464.949C3103.29 428.245 2932.23 385.264 2756.4 380.536C2707.48 379.391 2658.45 380.654 2610.61 387.629C2574.01 392.963 2539.15 401.648 2504.46 410.585C2470.21 419.4 2435.82 427.731 2400.44 434.559C2378.31 439.114 2358.48 446.035 2338.57 453.549C2298.93 468.595 2259.73 478.77 2213.26 481.548C2180.98 483.181 2148.72 481.548 2116.73 478.748C1953.38 463.463 1798.79 433.519 1647.65 391.961C1635.41 388.585 1623.18 385.192 1610.96 381.791C1609.48 381.374 1607.93 380.961 1606.44 380.544C1416.83 383.731 1226.83 376.293 1037.99 366.063C961.527 361.74 881.125 355.097 811.15 333.821C775.803 323.074 743.712 307.611 724.65 285.544C695.881 285.026 667.106 284.576 638.33 284.134C601.844 283.587 565.326 283.17 528.873 281.979C529.266 281.688 529.466 281.541 529.865 281.25C566.131 282.437 602.464 282.85 638.769 283.397C667.172 283.827 695.575 284.264 723.971 284.778C716.221 275.07 710.582 265.098 705.655 254.7C695.828 233.921 682.765 218.589 644.582 218.711C610.606 219.123 576.165 231.921 547.928 242.639C506.516 258.362 468.319 277.428 433.831 298.775C424.344 305.035 415.968 311.657 407.779 318.607C405.362 320.695 402.952 322.749 400.475 324.779C360.614 357.463 314.934 395.333 244.113 397.99C222.255 398.469 201.682 396.415 180.689 392.631C182.201 392.445 182.953 392.353 184.464 392.168C203.553 395.611 222.987 398.006 242.941 397.27C311.645 394.672 357.305 356.284 395.714 324.644C398.191 322.611 400.601 320.56 403.018 318.472C411.081 311.518 419.417 304.673 429.131 298.594C462.194 277.76 499.778 259.364 539.533 243.923C570.266 231.984 607.291 218.378 644.462 217.962C661.426 217.73 679.909 219.856 691.74 228.174C702.007 235.39 706.174 245.569 710.482 254.628C715.469 265.077 721.115 275.104 728.925 284.858C913.982 288.331 1098.78 296.325 1281.97 313.699C1396.92 325.01 1503.16 350.235 1609.11 379.736C1703.51 378.01 1799.02 374.318 1891.52 361.597C1949.76 353.636 2007.98 345.642 2066 337.058C2380.87 290.213 2694.56 237.789 3000.34 170.733C3044.58 160.992 3088.55 150.762 3132.46 140.406C3233.32 116.617 3332.59 93.2996 3441.89 95.9686C3549.8 99.5552 3650.1 122.359 3741.43 158.34C3830.22 194.156 3907.74 239.359 3983.86 285.064C4027.73 311.476 4071.59 338.389 4108.48 368.875C4137.15 392.572 4166.36 421.307 4166.4 452.257C4166.45 452.257 4166.48 452.261 4166.52 452.265L4166.5 452.274ZM1611.63 380.456C1612.8 380.789 1613.99 381.109 1615.16 381.441C1627.36 384.843 1639.57 388.231 1651.8 391.603C1802.39 433.014 1956.38 462.886 2119.14 478.117C2149.79 480.799 2180.72 482.419 2211.64 480.849C2257.06 478.1 2295.3 467.959 2334.05 453.276C2354.2 445.66 2374.26 438.693 2396.66 434.096C2431.92 427.297 2466.18 418.992 2500.3 410.21C2535.53 401.143 2570.93 392.344 2608.08 386.947C2657.02 379.837 2707.25 378.625 2757.26 379.799C2934.24 384.561 3106.22 427.584 3271.28 464.524C3301.37 471.259 3331.46 477.982 3361.6 484.613C3469.47 508.263 3577.59 531.66 3687.04 552.233C3730.49 560.4 3774.2 568.221 3818.5 574.363C3845.97 578.173 3875.9 582.77 3904.27 581.12C3999.99 574.747 4111.55 550.633 4148.19 488.313C4148.58 487.66 4148.78 487.332 4149.17 486.675C4153.77 478.82 4157.87 471.104 4160.44 462.882C4168.53 430.893 4139.36 399.547 4110.73 374.781C4072.71 341.887 4025.92 313.282 3979.39 285.271C3903.29 239.599 3825.83 194.408 3737.08 158.622C3646.85 123.087 3547.83 100.267 3441.19 96.7137C3334.06 93.628 3235.38 117.548 3136.68 140.831C3092.77 151.204 3048.79 161.434 3004.52 171.175C2698.54 238.269 2384.65 290.735 2069.56 337.614C2011.51 346.21 1953.24 354.204 1894.96 362.173C1802.2 374.916 1706.46 378.684 1611.81 380.456C1611.73 380.456 1611.7 380.46 1611.63 380.465V380.456ZM729.644 285.637C748.679 307.498 780.497 322.821 815.578 333.484C884.714 354.503 964.097 361.096 1039.64 365.373C1227.11 375.531 1415.72 382.927 1603.95 379.854C1498.89 350.588 1393.46 325.578 1279.48 314.355C1097.35 297.083 913.623 289.114 729.644 285.645V285.637Z" fill="url(#paint27_linear_1779_1730)" style=""/>\n<path d="M4203.24 446.464C4202.96 451.676 4202.19 456.462 4200.76 461.598C4197.37 470.06 4192.44 477.97 4187.04 485.998C4186.74 486.419 4186.59 486.629 4186.29 487.046C4143.24 550.158 4028.03 573.24 3928.5 579.845C3906.53 581.162 3883.88 578.809 3862.28 576.435C3825.57 572.398 3789.32 566.664 3753.33 560.606C3629.28 539.726 3507.17 514.148 3385.48 488.427C3354.19 481.796 3322.96 475.048 3291.73 468.283C3131.53 433.608 2965.73 393.839 2794.88 388.594C2746.53 387.276 2698.09 388.257 2650.52 394.323C2613.49 399.046 2577.82 406.83 2542.29 414.82C2507.4 422.663 2472.41 430.072 2436.62 436.096C2414.02 440.141 2393.23 446.346 2372.37 453.082C2332.09 466.128 2292.35 475.246 2246.91 477.717C2214.12 479.212 2181.37 477.532 2148.89 474.665C1984.22 459.169 1827.42 429.546 1673.56 389.852C1666.67 388.067 1659.77 386.287 1652.88 384.493C1605.29 385.276 1557.69 385.369 1510.08 384.965C1362.98 383.613 1216.03 377.514 1069.52 369.254C992.203 364.708 909.97 357.816 840.075 334.895C804.988 323.389 774.308 306.778 757.79 283.688C726.564 282.93 695.338 282.269 664.106 281.617C628.752 280.888 593.365 280.278 558.051 278.96C558.524 278.674 558.757 278.531 559.223 278.24C594.377 279.554 629.598 280.147 664.785 280.88C695.625 281.52 726.457 282.168 757.29 282.913C750.852 273.075 746.391 263.056 742.69 252.683C735.026 231.433 723.714 215.061 684.772 215.032C651.156 215.335 617.147 228.149 589.357 238.85C546.819 255.234 507.83 275.172 472.037 297.016C462.31 303.292 453.528 309.918 444.939 316.822C442.09 319.108 439.307 321.369 436.404 323.592C412.555 341.971 388.201 360.001 358.932 375.055C330.529 388.682 300.455 397.341 264.696 399.236C241.499 399.758 219.628 397.674 197.311 393.725C198.822 393.54 199.574 393.447 201.086 393.262C221.545 396.895 242.238 399.307 263.584 398.516C337.314 395.758 388.347 356.852 431.763 323.44C434.606 321.221 437.456 318.961 440.299 316.671C448.908 309.754 457.723 303.12 467.463 296.83C501.525 275.702 539.462 256.649 579.909 240.631C610.516 228.511 647.547 214.594 684.839 214.287C701.87 214.11 720.139 216.341 731.384 225.076C741.198 232.7 744.241 243.304 747.643 252.629C751.418 263.064 755.899 273.138 762.43 283.031C942.521 287.502 1122.3 296.266 1300.57 313.375C1419.02 325.145 1529.43 350.719 1639.76 379.534C1645.02 380.915 1650.34 382.296 1655.66 383.685C1750.15 381.879 1845.84 378.158 1938.38 365.175C1997.27 356.953 2056.14 348.673 2114.79 339.812C2432.03 291.598 2747.86 237.154 3055.01 167.209C3099.12 157.127 3142.95 146.569 3186.69 135.872C3287.9 111.149 3388.78 86.0464 3499.21 89.1363C3606.29 92.5673 3706.7 114.997 3796.58 151.57C3886.28 188.064 3963.52 235.36 4038.09 283.195C4078.12 308.938 4118.03 335.181 4151.2 364.666C4177.87 388.379 4203.57 416.483 4203.6 446.46C4203.46 446.46 4203.38 446.464 4203.24 446.469L4203.24 446.464ZM1658.01 384.38C1664.54 386.08 1671.07 387.781 1677.62 389.465C1830.96 429.015 1987.19 458.576 2151.3 474.021C2182.46 476.77 2213.88 478.433 2245.35 477.002C2289.71 474.564 2328.56 465.526 2367.85 452.754C2388.99 445.938 2410.05 439.674 2432.95 435.586C2468.58 429.588 2503.42 422.208 2538.14 414.391C2574.24 406.283 2610.46 398.398 2648.09 393.628C2696.72 387.465 2746.24 386.501 2795.67 387.857C2967.87 393.708 3133.91 432.854 3295.53 467.845C3326.75 474.602 3357.97 481.354 3389.26 487.989C3493.42 510.031 3597.88 531.698 3703.51 550.785C3747.89 558.804 3792.51 566.466 3837.69 572.486C3866.19 576.283 3897.18 580.876 3926.53 579.154C4024.42 572.629 4139.02 548.958 4181.34 486.962C4181.64 486.541 4181.79 486.33 4182.08 485.913C4187.52 477.907 4192.43 470.005 4195.83 461.556C4206.53 430.059 4181.55 398.411 4154.77 372.896C4120.29 340.051 4076.51 311.388 4032.96 283.372C3959.12 235.983 3882.72 189.774 3794.44 153.158C3704.43 116.71 3605.18 93.3587 3497.92 89.8688C3389.4 86.8378 3289.83 111.97 3190.4 136.264C3146.62 146.948 3102.79 157.536 3058.66 167.618C2751.33 237.6 2435.32 292.082 2117.89 340.334C2059.2 349.199 2000.29 357.492 1941.36 365.722C1848.64 378.734 1752.77 382.527 1658.08 384.384H1658.02L1658.01 384.38ZM762.603 283.793C779.095 306.677 809.535 323.133 844.356 334.554C913.433 357.206 994.633 364.047 1071.06 368.543C1217.09 376.773 1363.56 382.852 1510.2 384.207C1556.82 384.603 1603.43 384.523 1650.03 383.773C1645.07 382.477 1640.14 381.193 1635.18 379.905C1525.34 351.224 1415.45 325.726 1297.52 314.002C1120.29 296.986 941.576 288.255 762.544 283.789C762.57 283.789 762.583 283.793 762.603 283.797V283.793Z" fill="url(#paint28_linear_1779_1730)" style=""/>\n<path d="M4240.3 440.529C4239.97 447.319 4238.69 453.663 4236.23 460.276C4231.96 469.033 4226.14 477.153 4219.77 485.375C4219.67 485.505 4219.62 485.568 4219.53 485.695C4170.78 548.381 4052.7 571.105 3950.86 577.858C3928.93 579.192 3906.34 576.986 3884.74 574.768C3847.68 570.958 3811.05 565.464 3774.67 559.646C3652.84 540.155 3532.81 516.101 3413.22 491.79C3380.93 485.202 3348.71 478.492 3316.49 471.76C3159.69 439.013 2999.36 402.894 2833.18 396.63C2785.32 395.131 2737.44 395.838 2690.14 401.012C2652.55 405.121 2616.03 411.999 2579.61 419.055C2544.21 425.908 2508.74 432.387 2472.64 437.603C2449.51 441.156 2427.75 446.645 2405.93 452.594C2365.21 463.737 2324.97 471.769 2280.45 473.89C2247.03 475.006 2213.99 473.486 2180.9 470.544C2015.89 454.922 1857.72 426.014 1702.14 388.387C1501.54 392.269 1300.44 384.064 1100.78 372.39C1022.73 367.633 938.717 360.498 869.108 335.964C834.207 323.663 805.105 305.902 791.09 281.89C757.354 280.867 723.605 279.949 689.863 279.053C655.554 278.144 621.226 277.348 586.964 275.904C587.483 275.622 587.743 275.479 588.262 275.197C622.378 276.632 656.566 277.424 690.728 278.325C724.045 279.209 757.354 280.114 790.657 281.124C785.411 271.109 782.122 261.018 779.399 250.629C773.859 229.008 764.472 211.466 724.637 211.323C691.394 211.55 657.645 224.647 630.341 235.306C586.771 252.304 546.89 272.928 509.865 295.218C499.931 301.499 490.763 308.104 481.775 314.928C478.493 317.433 475.217 319.908 471.875 322.358C422.526 358.309 365.008 397.434 284.76 400.431C260.332 401.012 236.903 398.895 213.354 394.786C214.838 394.597 215.584 394.504 217.069 394.314C239.073 398.137 260.738 400.204 283.588 399.711C362.258 396.777 418.911 357.362 467.174 322.207C470.517 319.769 473.799 317.29 477.075 314.785C486.083 307.94 495.258 301.326 505.231 295.037C540.904 273.559 579.361 253.71 621.026 237.036C651.12 224.996 687.859 210.797 724.704 210.586C741.701 210.452 760.017 212.792 770.564 221.931C779.871 229.997 781.795 241.035 784.292 250.608C787.069 261.056 790.384 271.206 795.677 281.284C970.655 286.719 1145.26 296.186 1318.47 313.029C1438.24 325.044 1551.01 350.037 1663.69 377.602C1676.94 380.848 1690.2 384.089 1703.47 387.31C1703.89 387.415 1704.33 387.528 1704.82 387.629C1798.38 385.689 1893.09 381.774 1984.63 368.715C2044.14 360.207 2103.64 351.679 2162.9 342.523C2482.49 292.941 2800.45 236.493 3108.92 163.656C3152.82 153.25 3196.43 142.372 3239.97 131.368C3341.98 105.609 3443.87 79.2519 3555.79 82.2871C3666.58 85.7685 3770.08 110.303 3861.65 149.348C3947.83 186.103 4021.48 233.142 4091.58 281.318C4128.72 306.938 4165.46 333.24 4195.31 362.527C4218.87 385.638 4240.35 412.383 4240.38 440.533H4240.33L4240.3 440.529ZM1707.45 388.295C1862.15 425.66 2019.42 454.391 2183.47 469.921C2215.23 472.75 2247.24 474.463 2279.33 473.192C2322.8 471.087 2362.01 463.126 2401.77 452.244C2423.9 446.22 2445.96 440.676 2469.4 437.072C2505.32 431.886 2540.61 425.424 2575.83 418.6C2612.8 411.444 2649.88 404.464 2688.04 400.313C2736.39 395.055 2785.36 394.378 2834.27 395.914C3001.48 402.22 3162.68 438.382 3320.44 471.331C3352.65 478.062 3384.87 484.773 3417.16 491.352C3535.49 515.411 3654.27 539.149 3774.76 558.577C3810.44 564.332 3846.35 569.779 3882.66 573.694C3904.29 576.026 3927.1 578.506 3949.11 577.171C4050.13 570.457 4166.49 547.695 4214.79 485.602C4214.9 485.471 4214.95 485.408 4215.05 485.282C4221.38 477.069 4227.2 468.953 4231.5 460.222C4244.29 430.232 4224.74 399.177 4201.08 373.502C4169.98 339.757 4128.41 310.137 4086.85 281.465C4016.98 233.449 3943.65 186.578 3857.88 149.84C3767.27 111.027 3664.75 86.4589 3554.95 82.9985C3444.95 80.0097 3344.36 106.421 3244.14 131.738C3200.59 142.747 3156.96 153.637 3113.03 164.048C2804.37 236.939 2486.18 293.425 2166.39 343.04C2107.07 352.205 2047.5 360.738 1987.94 369.254C1896.19 382.266 1801.31 386.253 1707.58 388.282C1707.53 388.282 1707.5 388.286 1707.44 388.29L1707.45 388.295ZM796.084 282.063C810.045 305.869 838.987 323.474 873.595 335.673C942.418 359.93 1025.39 367.01 1102.56 371.713C1300.8 383.315 1500.31 391.229 1699.47 387.735C1699.47 387.735 1699.41 387.714 1699.35 387.705C1686.06 384.481 1672.78 381.235 1659.51 377.998C1547.33 350.542 1435.03 325.621 1315.78 313.652C1143.57 296.919 969.982 287.472 796.024 282.063H796.084Z" fill="url(#paint29_linear_1779_1730)" style=""/>\n<path d="M4278.04 433.667C4277.63 442.415 4275.69 450.535 4271.85 458.963C4266.83 467.845 4260.22 476.147 4252.93 484.364C4198.59 546.571 4077.67 568.979 3973.38 575.908C3950.72 577.298 3927.42 575.197 3905.06 573.033C3868.86 569.531 3833.03 564.475 3797.43 559.082C3677.4 540.892 3559.03 518.185 3441.12 495.2C3407.98 488.717 3374.92 482.095 3341.87 475.444C3188.79 444.688 3033.06 411.427 2871.66 404.708C2783.7 401.589 2701.52 409.469 2616.67 423.34C2580.91 429.2 2545.1 434.74 2508.82 439.156C2485.08 442.217 2462.36 447.007 2439.58 452.164C2410.35 458.799 2380.94 464.831 2350.16 467.816C2304.62 472.232 2258.54 470.544 2213.11 466.465C2056.28 451.52 1904.23 425.706 1754.87 392.277C1699.5 393.397 1644.12 393.531 1588.73 392.988C1436.26 391.317 1284.03 384.767 1132.27 375.585C1028.55 369.052 860.435 356.848 824.928 280.274C788.656 278.935 752.376 277.723 716.091 276.54C682.754 275.453 649.391 274.473 616.095 272.898C616.661 272.616 616.947 272.473 617.52 272.191C650.69 273.753 683.926 274.729 717.143 275.811C752.976 276.973 788.802 278.169 824.622 279.486C820.474 269.286 818.19 259.074 816.393 248.625C812.851 227.139 805.593 207.349 764.727 207.648C731.91 207.774 698.66 220.879 671.849 231.483C627.127 249.168 586.334 270.646 547.971 293.45C537.857 299.714 528.397 306.281 519.075 313.017C515.3 315.766 511.525 318.481 507.69 321.154C479.128 340.927 449.673 359.993 415.245 375.724C381.569 390.223 345.942 399.619 305.102 401.652C279.343 402.267 254.595 400.141 229.734 395.868C231.219 395.678 231.965 395.586 233.45 395.396C256.712 399.404 279.869 401.509 303.99 400.936C387.588 397.636 449.74 357.879 502.923 320.994C506.758 318.317 510.533 315.606 514.308 312.857C523.663 306.121 533.144 299.541 543.264 293.261C579.849 271.505 618.771 251.05 661.036 233.828C691.037 221.603 727.829 207.012 764.84 206.898C781.838 206.806 800.181 209.273 810.021 218.804C818.809 227.32 819.608 238.783 821.213 248.596C823.011 259.124 825.321 269.396 829.569 279.659C999.313 286.02 1168.64 296.14 1336.7 312.676C1457.79 324.943 1572.87 349.292 1687.78 375.661C1701.63 378.831 1715.47 382.001 1729.32 385.163C1738.6 387.28 1747.9 389.381 1757.21 391.46C1848.82 389.347 1941.56 385.293 2031.13 372.272C2091.28 363.512 2151.42 354.689 2211.32 345.255C2533.38 294.305 2853.32 235.895 3163.17 160.108C3206.81 149.398 3250.14 138.221 3293.41 126.927C3396.24 100.094 3499.17 72.4406 3612.64 75.4295C3836.52 82.3039 4006.35 176.782 4145.32 279.423C4178.71 304.189 4211.62 329.607 4237.9 357.682C4259.27 380.494 4278.31 406.59 4278.04 433.658V433.679V433.667ZM1760.18 392.151C1908.65 425.336 2059.78 450.964 2215.64 465.816C2259.33 469.736 2303.63 471.466 2347.44 467.235C2377.79 464.301 2406.75 458.272 2435.56 451.735C2458.69 446.506 2481.75 441.669 2505.85 438.558C2541.94 434.168 2577.57 428.653 2613.14 422.831C2699.55 408.682 2783.26 400.797 2872.84 403.984C3035.17 410.72 3191.72 444.044 3345.69 474.985C3378.75 481.624 3411.81 488.258 3444.94 494.733C3535.1 512.329 3625.47 529.551 3716.63 544.971C3766.77 553.454 3817.18 561.532 3868.1 567.914C3901.33 572.078 3937.47 577.293 3971.58 575.218C4075.08 568.344 4194.25 545.893 4248.15 484.263C4255.44 476.058 4262.07 467.774 4267.09 458.9C4282.29 429.36 4266.99 398.061 4245.27 371.519C4217.79 337.909 4179.25 308.239 4140.62 279.579C4002.79 177.751 3834.16 82.9985 3611.88 76.162C3500.35 73.2278 3398.7 100.949 3297.67 127.301C3254.36 138.6 3210.98 149.785 3167.31 160.499C2857.25 236.329 2537.11 294.784 2214.83 345.764C2154.87 355.198 2094.68 364.03 2034.47 372.799C1944.78 385.84 1851.96 389.974 1760.24 392.138C1760.21 392.146 1760.2 392.151 1760.18 392.159L1760.18 392.151ZM829.808 280.455C865.309 356.212 1031.06 368.408 1134 374.899C1285.27 384.055 1437.01 390.576 1588.97 392.248C1643.24 392.774 1697.51 392.652 1751.76 391.587C1742.91 389.595 1734.06 387.6 1725.22 385.592C1711.38 382.435 1697.54 379.273 1683.71 376.091C1569.23 349.826 1454.6 325.536 1333.98 313.316C1166.9 296.872 998.561 286.799 829.815 280.446V280.455H829.808Z" fill="url(#paint30_linear_1779_1730)" style=""/>\n<path d="M4316.11 426.851C4315.64 437.607 4312.93 447.483 4307.38 457.649C4301.96 466.624 4294.09 474.854 4286.22 483.03C4226.32 544.693 4102.73 566.841 3995.83 573.938C3937.87 577.483 3874.88 566.176 3818.99 558.19C3701.14 541.347 3584.81 520.159 3468.95 498.58C3435.08 492.241 3401.28 485.749 3367.49 479.241C3218.08 450.455 3066.72 419.893 2910.03 412.757C2822.23 409.267 2738.82 416.024 2653.18 427.596C2617.22 432.463 2581.23 437.072 2544.9 440.672C2520.46 443.248 2496.75 447.31 2472.99 451.693C2442.4 457.346 2411.7 462.558 2379.97 464.936C2335.05 468.308 2289.92 466.406 2245.29 462.356C2097.46 448.178 1952.98 425.306 1810.91 396.024C1595.11 401.071 1378.39 392.294 1163.69 378.764C1059.22 371.969 887.409 358.629 858.953 278.771C820.17 277.066 781.368 275.517 742.559 274.005C710.068 272.738 677.551 271.572 645.106 269.863C645.752 269.581 646.072 269.442 646.718 269.164C679.015 270.869 711.393 272.031 743.737 273.285C782.047 274.78 820.35 276.308 858.64 277.984C855.491 267.564 854.106 257.188 853.26 246.609C851.636 224.988 846.616 203.762 804.691 203.969C772.353 203.981 739.623 217.12 713.364 227.644C667.47 246.036 625.692 268.356 585.957 291.69C575.711 297.912 565.997 304.408 556.383 311.021C552.042 314.019 547.707 317.024 543.266 319.963C512.507 340.439 480.296 360.056 443.397 376.095C407.191 390.997 368.648 400.81 325.339 402.902C298.221 403.555 272.155 401.395 245.949 396.967C247.434 396.777 248.18 396.684 249.664 396.495C274.246 400.658 298.714 402.793 324.167 402.187C412.891 397.808 480.069 358.742 538.506 319.807C542.92 316.856 547.275 313.867 551.622 310.874C561.236 304.252 570.957 297.748 581.197 291.513C618.368 269.665 657.457 248.869 699.855 231.159C729.982 218.572 767.313 203.249 804.877 203.244C821.755 203.202 840.431 205.766 849.419 215.684C857.608 224.718 857.322 236.547 858.087 246.613C858.94 257.276 860.344 267.72 863.594 278.215C1028 285.523 1192.04 296.153 1354.89 312.368C1477.29 324.892 1594.58 348.542 1711.66 373.737C1726.14 376.844 1740.62 379.959 1755.11 383.049C1774.41 387.166 1793.73 391.233 1813.09 395.232C1901.67 392.908 1991.12 388.589 2077.67 375.846C2138.46 366.825 2199.25 357.753 2259.76 348.008C2584.23 295.706 2906.31 235.297 3217.44 156.597C3260.77 145.605 3303.79 134.142 3346.75 122.587C3450.46 94.6888 3554.46 65.6756 3669.55 68.6097C3893.03 73.9982 4066.5 172.45 4199.09 277.575C4250.94 319.108 4316.66 370.984 4316.12 426.876V426.855L4316.11 426.851ZM1816.23 395.885C1957.38 424.94 2100.93 447.635 2247.77 461.724C2291.1 465.652 2334.93 467.471 2378.53 464.174C2409.46 461.834 2439.4 456.74 2469.23 451.225C2493.37 446.776 2517.47 442.667 2542.3 440.053C2578.43 436.466 2614.22 431.882 2649.97 427.045C2737.11 415.27 2822.01 408.484 2911.32 412.041C3068.9 419.206 3221.06 449.84 3371.32 478.778C3405.08 485.286 3438.87 491.777 3472.72 498.109C3587.35 519.456 3702.45 540.345 3819 557.146C3855.11 562.353 3891.45 567.228 3928.13 570.596C3949.68 572.574 3972.16 574.574 3993.98 573.248C4100.05 566.201 4222.07 544.049 4281.45 482.916C4289.33 474.758 4297.19 466.54 4302.61 457.582C4340.95 393.805 4252.49 324.219 4194.39 277.693C4062.49 172.522 3891.42 76.002 3668.82 69.3212C3555.65 66.4417 3452.88 95.5055 3350.96 122.928C3307.96 134.492 3264.91 145.95 3221.56 156.959C2910.24 235.718 2587.95 296.161 2263.28 348.5C2202.7 358.246 2141.86 367.326 2081.01 376.356C1994.4 389.107 1904.92 393.502 1816.29 395.876H1816.23L1816.23 395.885ZM863.78 278.99C892.356 358.01 1061.72 371.325 1165.42 378.073C1378.46 391.498 1593.46 400.229 1807.58 395.354C1788.7 391.443 1769.85 387.474 1751.02 383.462C1736.54 380.363 1722.06 377.257 1707.59 374.15C1590.9 349.047 1474.02 325.448 1352.04 312.97C1190.18 296.851 1027.13 286.277 863.713 278.977C863.74 278.981 863.753 278.985 863.773 278.99H863.78Z" fill="url(#paint31_linear_1779_1730)" style=""/>\n<path d="M4355.27 419.451C4354.75 432.299 4351.05 444.503 4342.96 456.336C4336.35 465.277 4328.25 473.499 4319.58 481.687C4253.77 543.157 4128.58 564.647 4018.31 571.964C3960.07 575.525 3897.01 564.892 3840.63 557.323C3724.97 541.797 3610.68 522.134 3496.87 501.957C3462.35 495.806 3427.91 489.492 3393.47 483.156C3247.71 456.336 3100.54 428.341 2948.47 420.793C2860.59 416.916 2775.78 422.486 2689.25 431.806C2653.24 435.675 2617.22 439.367 2580.97 442.183C2555.79 444.258 2531.08 447.601 2506.35 451.2C2429.48 462.44 2355.95 465.437 2277.48 458.235C2139.73 444.936 2004.29 424.898 1870.83 399.644C1803.12 401.526 1735.37 401.766 1667.62 401.033C1509.79 399.092 1352.14 392.096 1195.13 381.921C1089.61 374.849 914.695 360.3 893.176 277.373C851.963 275.281 810.724 273.365 769.485 271.475C737.733 270.031 705.955 268.68 674.256 266.824C674.949 266.546 675.295 266.411 675.987 266.133C707.586 267.981 739.258 269.333 770.903 270.764C811.63 272.616 852.343 274.515 893.043 276.577C890.819 265.906 890.34 255.318 890.32 244.571C890.44 222.891 887.883 200.18 844.839 200.256C813.188 199.961 780.683 213.377 755.197 223.729C708.092 242.854 665.221 265.998 624.062 289.889C613.775 296.043 603.888 302.412 594.114 308.891C589.148 312.196 584.161 315.496 579.081 318.733C514.852 359.458 440.895 400.389 345.746 404.102C317.29 404.83 289.893 402.645 262.402 398.023C263.86 397.83 264.593 397.733 266.051 397.539C291.97 401.871 317.763 404.014 344.575 403.369C438.212 398.865 510.917 358.806 574.38 318.548C579.454 315.311 584.44 312.015 589.414 308.719C599.208 302.231 609.108 295.854 619.421 289.699C653.244 269.947 688.537 251.029 726.068 234.144C759.145 219.262 802.442 199.186 845.146 199.519C862.077 199.519 880.786 202.238 889.061 212.518C896.711 222.024 895.307 234.253 895.2 244.571C895.22 255.407 895.706 266.07 897.983 276.826C1056.99 284.993 1215.62 296.11 1373.19 311.998C1496.93 324.783 1616.34 347.692 1735.55 371.729C1750.71 374.781 1765.85 377.838 1781.01 380.873C1811.59 386.977 1842.2 392.997 1872.91 398.831C1957.1 396.238 2042.12 391.768 2124.3 379.37C2185.76 370.096 2247.16 360.704 2308.34 350.706C2635.21 297.053 2959.46 234.67 3271.81 153.018C3314.78 141.758 3357.43 130.05 3400.02 118.242C3504.63 89.2415 3609.82 58.8516 3726.6 61.7311C3837.63 65.002 3940.44 90.7233 4030.72 131.069C4117.7 170.337 4189.93 221.502 4253.04 275.66C4299.71 316.292 4355.55 366.762 4355.43 419.438C4355.36 419.438 4355.33 419.442 4355.25 419.446L4355.27 419.451ZM1876.14 399.505C2008.67 424.54 2143.17 444.422 2279.93 457.628C2356.39 464.629 2428.05 461.644 2502.93 450.691C2528.08 447.033 2553.2 443.652 2578.81 441.539C2614.85 438.739 2650.67 435.064 2686.46 431.217C2774.31 421.757 2860.65 416.163 2949.87 420.099C3102.74 427.676 3250.63 455.721 3397.17 482.684C3431.59 489.007 3466.01 495.33 3500.51 501.477C3613.51 521.511 3726.96 541.056 3841.77 556.59C3897.1 564.079 3959.23 574.776 4016.43 571.278C4126 564.374 4249.73 542.365 4314.8 481.561C4323.48 473.385 4331.59 465.181 4338.2 456.248C4380.96 394.129 4303.78 323.714 4248.15 275.79C4122.92 168.321 3947.86 67.6078 3725.67 62.4678C3610.84 59.6389 3506.89 90.1087 3404.1 118.608C3361.5 130.438 3318.82 142.141 3275.83 153.397C2963.25 235.091 2638.8 297.538 2311.68 351.22C2250.45 361.218 2188.99 370.631 2127.47 379.909C2045.3 392.311 1960.31 396.853 1876.14 399.497V399.505H1876.14ZM897.996 277.638C919.675 359.706 1092.2 374.23 1196.92 381.252C1353.41 391.41 1510.55 398.377 1667.87 400.309C1734.35 401.029 1800.85 400.806 1867.29 399.004C1837.11 393.258 1807.01 387.335 1776.95 381.336C1761.79 378.296 1746.62 375.244 1731.47 372.192C1612.65 348.227 1493.62 325.368 1370.3 312.629C1213.67 296.839 1056 285.763 897.937 277.634H897.996V277.638Z" fill="url(#paint32_linear_1779_1730)" style=""/>\n<path d="M4394.38 410.442C4393.83 426.157 4388.88 440.693 4378.54 455.023C4371.17 463.993 4362.36 472.211 4352.93 480.357C4281.72 541.212 4153.83 562.496 4040.77 569.998C3982.63 573.639 3920.03 563.852 3863.49 556.771C3749.57 542.504 3636.92 524.192 3524.72 505.35C3489.65 499.431 3454.65 493.322 3419.67 487.197C3277.58 462.343 3134.33 436.807 2986.9 428.855C2898.78 424.565 2812.45 428.847 2725.04 435.969C2689.08 438.895 2653.12 441.674 2617 443.711C2591.03 445.277 2565.35 447.887 2539.66 450.716C2462.28 459.266 2387.66 461.388 2309.6 454.147C2182.97 441.842 2057.92 424.469 1934.37 403.075C1858.65 405.601 1782.84 405.946 1707.05 405.079C1546.51 403.02 1386.17 395.754 1226.51 385.104C1119.63 377.732 942.318 361.9 927.464 276.14C883.941 273.626 840.398 271.286 796.842 269.004C766.309 267.4 735.749 265.881 705.262 263.94C690.601 271.867 676.167 279.941 661.885 288.142C651.619 294.17 641.692 300.388 631.811 306.668C626.086 310.314 620.34 313.943 614.547 317.551C545.018 360.035 466.095 400.692 365.8 405.348C336.012 406.114 307.303 403.913 278.494 399.126C279.952 398.932 280.685 398.836 282.143 398.646C309.38 403.172 336.518 405.34 364.688 404.632C463.552 400.002 541.436 359.206 609.907 317.374C615.699 313.774 621.445 310.146 627.171 306.504C637.031 300.207 646.978 293.993 657.245 287.956C700.541 263.094 745.223 238.551 794.618 218.585C820.631 208.069 852.928 195.444 885.073 195.865C902.164 195.92 920.733 198.765 928.256 209.445C935.327 219.481 932.864 231.976 931.978 242.593C931.133 253.66 930.806 264.576 932.225 275.63C1085.81 284.584 1239 296.144 1391.28 311.682C1516.27 324.711 1637.66 346.829 1758.84 369.742C1774.77 372.757 1790.71 375.762 1806.66 378.76C1849.68 386.821 1892.77 394.735 1936.04 402.271C2014.68 399.408 2093.87 394.66 2170.61 382.948C2232.71 373.434 2294.75 363.727 2356.55 353.455C2685.89 298.455 3012.31 234.076 3325.92 149.499C3368.43 137.99 3410.66 126.06 3452.82 114.032C3558.38 83.9246 3664.81 52.0909 3783.37 54.9156C4008.61 60.2661 4186.19 161.291 4306.7 273.807C4349.12 313.981 4394.34 360.494 4394.38 410.459V410.45V410.442ZM1939.7 402.885C2062.33 424.102 2186.46 441.307 2312.14 453.524C2388.36 460.588 2461.17 458.462 2536.74 450.122C2562.85 447.256 2588.93 444.599 2615.33 443.025C2651.21 441 2686.95 438.226 2722.68 435.321C2811.37 428.097 2898.95 423.799 2988.36 428.156C3136.53 436.138 3280.46 461.729 3423.25 486.709C3458.22 492.83 3493.19 498.93 3528.24 504.849C3639.24 523.493 3750.7 541.549 3863.36 555.769C3919.23 562.82 3981.35 572.827 4038.84 569.316C4151.16 561.861 4277.43 540.623 4348.06 480.222C4357.47 472.089 4366.28 463.884 4373.67 454.934C4420.98 393.893 4355.08 323.895 4301.83 273.913C4241.88 217.949 4170.76 165.888 4084.03 125.87C3994.91 85.1581 3893.05 58.818 3782.51 55.6354C3665.94 52.8612 3560.71 84.7876 3456.97 114.378C3414.79 126.422 3372.54 138.352 3329.99 149.865C3016.21 234.514 2689.58 298.931 2360.03 353.964C2298.16 364.245 2236.06 373.948 2173.9 383.479C2097.22 395.177 2018.1 399.989 1939.51 402.902C1939.59 402.902 1939.63 402.898 1939.71 402.894L1939.7 402.885ZM932.284 276.426C947.318 361.315 1122.3 377.114 1228.36 384.434C1387.48 395.055 1547.29 402.3 1707.29 404.35C1781.75 405.201 1856.21 404.868 1930.6 402.452C1887.88 394.996 1845.33 387.179 1802.83 379.227C1786.88 376.234 1770.93 373.224 1754.99 370.21C1634.15 347.368 1513.12 325.296 1388.5 312.301C1237.16 296.86 1084.92 285.363 932.284 276.439V276.43V276.426ZM926.159 260.463C926.179 254.493 926.612 248.528 927.091 242.567C928.895 220.904 928.875 196.614 884.647 196.589C859.46 196.37 834.16 205.547 813.194 213.39C775.124 227.627 740.316 245.24 706.567 263.224C737.113 265.182 767.733 266.706 798.327 268.31C841.304 270.566 884.267 272.865 927.211 275.344C926.572 270.36 926.212 265.464 926.099 260.467H926.159V260.463Z" fill="url(#paint33_linear_1779_1730)" style=""/>\n<path d="M4434.58 401.547C4433.97 420.149 4427.61 437.148 4414.11 453.709C4405.91 462.676 4396.41 470.902 4386.26 479.014C4309.67 539.246 4179.36 560.324 4063.28 568.032C4033.48 569.918 4002.65 567.333 3973.13 564.9C3931.28 561.452 3889.72 556.674 3848.33 551.509C3749.14 539.137 3650.71 524.293 3552.67 508.734C3517.05 503.064 3481.49 497.2 3445.95 491.323C3307.51 468.422 3168.28 445.235 3025.37 436.912C2936.75 432.177 2849.12 435.073 2760.73 440.032C2724.87 442.04 2689 443.951 2653.06 445.231C2626.3 446.25 2599.71 448.135 2573.12 450.186C2495.3 456.197 2419.66 457.346 2341.83 450.047C2227.34 438.84 2113.96 423.963 2001.56 406.211C1754.19 416.163 1504.07 405.167 1258 388.269C1149.59 380.591 970.229 363.424 961.986 275.033C916.426 272.073 870.832 269.307 825.238 266.575C798.38 264.971 771.509 263.405 744.677 261.612C729.63 269.737 714.777 277.988 700.062 286.348C689.982 292.183 680.149 298.165 670.361 304.193C663.77 308.268 657.159 312.33 650.434 316.321C575.865 360.325 491.762 401.766 386.22 406.548C355.121 407.377 325.06 405.142 294.953 400.187C296.411 399.989 297.144 399.892 298.602 399.694C327.158 404.384 355.6 406.573 385.102 405.82C488.526 401.042 572.816 359.361 645.727 316.123C652.451 312.141 659.063 308.079 665.654 304.004C675.455 297.963 685.308 291.977 695.415 286.146C710.203 277.756 725.116 269.463 740.216 261.296C737.553 261.115 734.957 260.938 732.42 260.757C733.239 260.488 733.645 260.357 734.464 260.088C736.754 260.248 739.105 260.408 741.515 260.581C776.609 241.839 812.675 223.241 852.39 208.494C874.008 200.466 899.495 191.819 925.347 192.152C942.558 192.244 961.081 195.267 967.858 206.288C974.337 216.821 970.781 229.681 969.097 240.559C967.372 251.904 966.167 263.132 966.806 274.532C1114.91 284.222 1262.64 296.132 1409.59 311.32C1535.77 324.606 1658.99 345.873 1782.02 367.659C1798.87 370.643 1815.72 373.62 1832.58 376.592C1889.27 386.548 1946.05 396.28 2003.11 405.378C2074.98 402.237 2147.17 397.35 2217.27 386.48C2280.01 376.693 2342.7 366.745 2405.13 356.166C2670.58 311.093 2933.66 259.587 3189.61 196.033C3253.68 180.125 3317.29 163.467 3380.29 145.934C3422.34 134.205 3464.09 122.069 3505.78 109.844C3612.32 78.5951 3720.03 45.2796 3840.41 48.0411C3953.15 51.1858 4056.95 78.0479 4147.19 120.187C4233.61 160.937 4304.13 214.177 4360.66 271.905C4397.84 310.672 4434.78 354.983 4434.8 401.542C4434.72 401.542 4434.68 401.547 4434.6 401.551L4434.58 401.547ZM2006.75 405.996C2118.24 423.58 2230.71 438.314 2344.28 449.432C2420.56 456.584 2494.55 455.435 2570.81 449.533C2597.79 447.462 2624.75 445.563 2651.89 444.524C2687.65 443.24 2723.32 441.345 2758.99 439.341C2848.5 434.315 2937.24 431.419 3026.97 436.222C3170.52 444.574 3310.34 467.824 3449.4 490.822C3484.92 496.703 3520.45 502.559 3556.07 508.225C3665.47 525.539 3775.31 542.256 3886.25 555.235C3942.32 561.793 4003.9 570.878 4061.35 567.35C4176.54 559.701 4305.5 538.64 4381.44 478.883C4391.61 470.792 4401.09 462.575 4409.29 453.617C4460.63 394.02 4405.5 323.962 4355.71 272.018C4244.19 156.95 4062.68 53.8926 3839.53 48.7778C3721.15 46.0583 3614.62 79.4834 3509.92 110.193C3468.22 122.435 3426.44 134.572 3384.37 146.304C3321.33 163.85 3257.67 180.52 3193.56 196.437C2937.44 260.025 2674.2 311.573 2408.58 356.68C2346.12 367.267 2283.39 377.215 2220.6 387.015C2150.6 397.872 2078.53 402.81 2006.75 405.996ZM966.673 275.357C975.129 362.868 1152.33 379.985 1259.84 387.608C1504 404.371 1752.13 415.317 1997.6 405.618C1941.11 396.588 1884.88 386.952 1828.72 377.097C1811.87 374.133 1795.03 371.148 1778.18 368.164C1655.45 346.429 1532.55 325.2 1406.68 311.947C1260.64 296.864 1113.85 285.014 966.673 275.357ZM961.473 267.021C961.72 258.156 962.765 249.379 964.07 240.555C967.386 218.963 970.149 193.065 924.655 192.901C899.874 192.611 875.067 201.817 854.58 209.601C815.797 224.339 780.357 242.508 745.829 260.905C772.8 262.719 799.818 264.285 826.823 265.897C871.824 268.583 916.812 271.32 961.773 274.233C961.587 271.812 961.46 269.413 961.46 267.03V267.021H961.473Z" fill="url(#paint34_linear_1779_1730)" style=""/>\n<path d="M4475.43 391.469C4474.83 413.035 4467.33 433.776 4449.63 452.392C4441.01 461.476 4430.38 469.647 4419.51 477.679C4337.67 537.255 4204.68 558.16 4085.62 566.062C4056.2 567.931 4025.88 565.746 3996.65 563.603C3954.75 560.53 3913.1 556.14 3871.61 551.362C3773.97 540.113 3677 526.478 3580.39 512.127C3544.15 506.722 3507.97 501.119 3471.81 495.499C3337.12 474.572 3201.92 453.633 3063.61 444.966C2974.51 439.754 2885.78 441.168 2796.55 444.002C2760.65 445.142 2724.75 446.203 2688.82 446.763C2661.38 447.226 2634.03 448.371 2606.66 449.634C2528.38 453.276 2451.58 453.339 2373.74 445.959C2272.44 435.97 2171.86 423.5 2071.92 409.044C1976.77 413.864 1881.14 414.353 1785.74 413.166C1619.85 410.867 1454.14 403.092 1289.25 391.473C1178.95 383.453 998.368 364.931 996.264 274.106C949.013 270.692 901.735 267.464 854.443 264.273C830.721 262.673 806.992 261.098 783.283 259.394C768.003 267.695 752.89 276.11 737.863 284.597C728.122 290.141 718.548 295.799 709.027 301.499C701.351 306.071 693.667 310.63 685.884 315.13C606.908 360.494 516.326 402.852 406.264 407.786C373.833 408.649 342.454 406.401 311.035 401.282C312.493 401.084 313.226 400.987 314.684 400.789C344.531 405.655 374.332 407.874 405.145 407.066C513.79 402.153 603.279 359.69 681.177 314.941C688.933 310.445 696.61 305.894 704.26 301.318C713.814 295.622 723.402 289.956 733.156 284.395C748.316 275.866 763.582 267.417 779.009 259.082C772.637 258.619 766.698 258.173 761.185 257.748C762.078 257.482 762.524 257.352 763.409 257.087C768.669 257.495 774.302 257.92 780.36 258.362C816.38 239.103 853.178 219.772 893.805 204.465C915.011 196.475 939.738 188.115 965.185 188.49C982.502 188.746 1000.92 191.777 1007.07 203.173C1012.96 214.11 1008.26 227.518 1005.84 238.581C1003.31 250.267 1001.26 261.823 1001.14 273.631C1143.74 283.995 1286.01 296.195 1427.65 311.009C1554.83 324.53 1679.64 344.88 1804.29 365.55C1822.28 368.534 1840.27 371.515 1858.26 374.474C1929.73 386.232 2001.31 397.691 2073.27 408.202C2137.22 404.839 2201.31 399.888 2263.66 390.05C2327.05 380.006 2390.38 369.776 2453.44 358.915C2739.52 309.561 3023.12 252.751 3296.88 180.335C3343.03 168.131 3388.86 155.464 3434.42 142.414C3475.91 130.497 3517.1 118.187 3558.24 105.803C3665.79 73.3962 3774.87 38.5441 3897.14 41.2089C4010.79 44.3282 4115.1 71.7966 4205.41 114.782C4291.7 156.273 4361.38 210.46 4414.25 270.036C4446.38 307.115 4475.41 348.387 4475.43 391.477V391.469H4475.43ZM2077.18 408.766C2176.26 423.079 2275.98 435.426 2376.42 445.332C2453 452.602 2528.26 452.505 2605.28 448.927C2632.99 447.651 2660.68 446.498 2688.45 446.022C2724.2 445.471 2759.91 444.41 2795.62 443.282C2885.76 440.423 2975.38 439.022 3065.4 444.284C3204.28 452.989 3340.03 473.97 3475.28 494.99C3511.4 500.597 3547.53 506.2 3583.73 511.597C3702.43 529.189 3821.73 546.335 3942.29 558.118C3988.08 562.593 4037.13 568.302 4083.69 565.384C4201.85 557.537 4333.51 536.649 4414.67 477.528C4425.52 469.508 4436.11 461.35 4444.74 452.291C4499.89 394.251 4456.05 323.97 4409.35 270.124C4356.49 210.607 4286.87 156.462 4200.66 115.001C4111.88 72.7606 4008.13 45.0481 3896.34 41.9413C3776.06 39.3103 3668.14 74.2887 3562.4 106.135C3521.26 118.528 3480.06 130.842 3438.58 142.764C3312.13 178.904 3183.42 211.672 3052.96 241.565C2857.09 286.251 2657.81 324.753 2456.96 359.412C2393.87 370.281 2330.5 380.519 2267.07 390.568C2204.87 400.368 2140.96 405.361 2077.18 408.775V408.766H2077.18ZM1001.14 274.443C1003.59 364.35 1181.86 382.826 1291.28 390.791C1455.64 402.359 1620.84 410.13 1786.18 412.429C1880.11 413.603 1974.26 413.128 2067.95 408.468C1996.55 398.019 1925.53 386.64 1854.6 374.975C1836.61 372.016 1818.63 369.035 1800.65 366.051C1676.28 345.427 1551.77 325.103 1424.88 311.611C1284.17 296.898 1142.83 284.757 1001.15 274.452V274.439L1001.14 274.443ZM996.258 272.275C996.417 261.027 998.521 249.77 1001.02 238.539C1005.73 217.12 1011.38 189.487 964.639 189.214C934.758 188.788 904.285 201.986 880.489 211.9C846.793 225.943 815.308 242.113 784.641 258.661C808.557 260.37 832.485 261.97 856.421 263.586C903.053 266.718 949.672 269.909 996.258 273.265C996.258 272.932 996.258 272.599 996.258 272.271V272.275Z" fill="url(#paint35_linear_1779_1730)" style=""/>\n<path d="M4517.83 380.039C4517.17 405.407 4507.35 429.705 4485.23 451.078C4475.77 460.171 4464.48 468.346 4452.86 476.345C4365.85 535.222 4230.22 555.984 4108.14 564.096C4038.21 568.415 3963.74 558.447 3895.12 551.214C3799.03 541.086 3703.54 528.642 3608.37 515.508C3571.32 510.372 3534.35 505.034 3497.37 499.683C3366.66 480.757 3235.64 461.994 3102.11 453.015C3012.75 447.331 2923.32 447.142 2833.62 447.883C2797.38 448.186 2761.14 448.426 2724.9 448.262C2696.94 448.161 2669.01 448.565 2641.07 449.057C2562.09 450.459 2484.32 449.369 2406.06 441.846C2318.7 433.166 2231.78 422.932 2145.25 411.419C2038.98 417.889 1931.95 418.567 1825.29 417.186C1656.71 414.765 1488.27 406.708 1320.75 394.622C1208.53 386.266 1027.02 366.345 1030.87 273.323C982.483 269.459 934.066 265.763 885.643 262.113C864.478 260.522 843.312 258.926 822.16 257.272C806.653 265.708 791.294 274.25 775.94 282.795C766.786 287.91 757.771 293.134 748.776 298.363C739.781 303.57 730.773 308.765 721.671 313.892C637.648 360.696 541.874 403.913 426.585 408.99C392.862 409.911 360.085 407.634 327.395 402.342C328.833 402.145 329.545 402.048 330.983 401.85C362.162 406.88 393.301 409.112 425.466 408.27C538.811 403.193 634.406 359.711 716.964 313.703C726.066 308.575 735.087 303.393 744.062 298.182C753.057 292.953 762.065 287.729 771.226 282.614C786.68 273.993 802.193 265.409 817.879 256.96C808.677 256.232 799.476 255.495 790.281 254.708C791.22 254.451 791.693 254.321 792.632 254.064C801.473 254.813 810.329 255.529 819.177 256.228C854.524 237.234 890.384 218.079 929.805 202.504C952.016 193.731 978.162 184.347 1005.24 184.789C1022.72 185.092 1041.05 188.317 1046.45 200.028C1051.72 211.458 1045.93 225.219 1042.74 236.552C1039.41 248.638 1036.53 260.61 1035.56 272.881C1172.65 283.86 1309.43 296.266 1445.74 310.647C1574.33 324.497 1701.07 343.992 1827.7 363.622C1846.43 366.522 1865.15 369.427 1883.89 372.31C1971.01 385.722 2058.27 398.777 2145.99 410.556C2201.13 407.045 2256.23 402.195 2310.02 393.586C2374.07 383.289 2438.02 372.761 2501.71 361.626C2790.17 311.093 3075.95 252.645 3351.13 177.818C3397.24 165.277 3443.03 152.265 3488.53 138.853C3529.43 126.767 3570.05 114.293 3610.61 101.749C3719.18 68.1762 3829.64 31.7244 3953.84 34.3512C4178.88 39.1966 4370.88 145.205 4467.84 268.141C4494.87 302.922 4517.63 340.746 4517.65 380.035C4517.73 380.035 4517.76 380.039 4517.83 380.044V380.039ZM2150.19 411.12C2235.92 422.507 2322.03 432.644 2408.57 441.236C2485.79 448.666 2562.52 449.714 2640.42 448.333C2668.62 447.841 2696.81 447.437 2725.02 447.542C2761.09 447.706 2797.17 447.466 2833.24 447.163C2923.68 446.422 3013.85 446.616 3103.94 452.354C3237.96 461.362 3369.46 480.163 3500.64 499.166C3537.57 504.52 3574.51 509.846 3611.51 514.981C3701.41 527.396 3791.62 539.086 3882.32 548.92C3925.03 553.551 3967.88 557.815 4010.94 560.85C4042.24 563.056 4074.72 565.443 4106.2 563.435C4227.4 555.374 4361.72 534.645 4448.06 476.202C4459.67 468.224 4470.91 460.057 4480.37 450.981C4539.42 394.041 4506.87 324.513 4463.18 268.247C4414.06 206.823 4344.8 152.21 4259.22 109.57C4170.38 66.446 4066.02 38.1358 3953.3 35.1006C3831.12 32.5242 3721.82 69.0897 3615.09 102.094C3574.51 114.651 3533.87 127.112 3492.95 139.207C3410.84 163.353 3327.71 186.077 3243.67 207.412C3002.86 268.55 2755.47 318.405 2505.47 362.131C2441.73 373.283 2377.73 383.815 2313.64 394.121C2260.04 402.713 2205.11 407.583 2150.17 411.128V411.12H2150.19ZM1035.55 276.881C1035.59 366.783 1213.98 385.853 1322.78 393.965C1489.75 406.005 1657.63 414.045 1825.66 416.453C1930.78 417.813 2036.3 417.203 2141.04 410.875C2053.85 399.151 1967.13 386.169 1880.53 372.837C1861.8 369.945 1843.08 367.048 1824.35 364.148C1697.94 344.552 1571.44 325.09 1443.07 311.257C1307.67 296.978 1171.79 284.635 1035.61 273.719C1035.61 274.767 1035.55 275.828 1035.55 276.876V276.881ZM1030.79 272.503C1031.8 260.358 1034.65 248.495 1037.96 236.526C1043.92 215.352 1052.58 185.909 1004.61 185.517C975.379 185.021 945.738 197.89 922.548 207.648C887.627 222.34 855.243 239.36 823.378 256.556C844.803 258.227 866.235 259.84 887.667 261.461C935.391 265.06 983.102 268.701 1030.79 272.503Z" fill="url(#paint36_linear_1779_1730)" style=""/>\n<path d="M4560.76 367.688C4560.08 397.261 4547.85 425.433 4520.74 449.777C4510.5 458.896 4498.52 467.067 4486.14 475.019C4394.04 533.214 4255.7 553.82 4130.53 562.147C4060.87 566.474 3987.21 557.626 3918.59 551.084C3824.02 542.067 3729.97 530.831 3636.22 518.917C3597.93 514.034 3559.71 508.932 3521.49 503.83C3395.23 486.953 3268.78 470.333 3140.45 461.093C3051.23 454.934 2961.71 453.099 2872.04 451.802C2834.95 451.267 2797.85 450.691 2760.78 449.79C2732.55 449.116 2704.3 448.801 2676.05 448.544C2596.2 447.82 2517.14 445.471 2438.1 437.767C2365.17 430.467 2292.5 422.288 2220.03 413.351C2148.82 418.609 2077.05 420.793 2005.4 421.543C1787.4 423.829 1568.55 413.818 1352.1 397.817C1237.87 389.107 1055.56 367.755 1065.24 272.688C1016.98 268.486 968.69 264.411 920.393 260.37C900.506 258.703 880.619 257.044 860.745 255.352C845.059 263.864 829.466 272.452 813.906 281.052C805.797 285.565 797.721 290.103 789.651 294.645C778.912 300.72 768.139 306.769 757.227 312.718C669.062 360.148 566.257 405.963 446.734 410.244C411.68 411.195 377.584 408.901 343.582 403.454C345.02 403.256 345.733 403.159 347.171 402.961C379.668 408.147 412.112 410.408 445.615 409.52C564.193 404.308 665.001 359.951 752.586 312.516C763.479 306.555 774.251 300.51 785.011 294.452C793.06 289.893 801.136 285.35 809.265 280.85C824.971 272.191 840.698 263.544 856.543 254.977C844.16 253.908 831.783 252.835 819.419 251.685C820.431 251.433 820.943 251.307 821.955 251.054C833.946 252.165 845.957 253.214 857.968 254.249C893.202 235.28 928.782 216.092 967.738 200.192C990.342 190.969 1017.56 180.537 1045.52 181.11C1063.2 181.459 1081.4 184.89 1086.06 196.909C1090.69 208.839 1083.86 222.937 1079.92 234.556C1075.73 247.076 1072.03 259.49 1070.27 272.254C1201.84 283.738 1333.16 296.321 1464.12 310.322C1592.92 324.324 1720.33 342.746 1847.68 361.197C1868.38 364.194 1889.1 367.191 1909.81 370.184C2013.19 385.07 2116.7 399.543 2220.74 412.475C2266.52 408.968 2312 404.275 2356.75 397.164C2421.43 386.606 2486.03 375.8 2550.35 364.371C2841.19 312.655 3129.17 252.57 3405.75 175.313C3451.82 162.444 3497.54 149.087 3542.96 135.317C3583.25 123.062 3623.27 110.463 3663.25 97.7998C3772.86 63.0445 3884.76 24.9509 4010.93 27.5188C4125.48 30.5372 4233.19 59.1295 4322.54 103.908C4408.08 147.331 4476.78 203.004 4521.85 266.272C4543.89 298.295 4560.75 332.453 4560.76 367.692V367.684L4560.76 367.688ZM2224.82 412.984C2296.56 421.816 2368.5 429.907 2440.69 437.136C2518.96 444.764 2597.26 447.075 2676.33 447.786C2704.74 448.043 2733.14 448.363 2761.53 449.045C2798.48 449.95 2835.44 450.514 2872.4 451.049C2962.58 452.345 3052.63 454.214 3142.36 460.407C3271.1 469.677 3397.93 486.339 3524.59 503.257C3562.78 508.364 3600.97 513.453 3639.23 518.332C3743.66 531.568 3848.45 544.108 3953.97 553.403C4010.67 558.4 4071.17 565.022 4128.61 561.448C4252.9 553.18 4389.96 532.591 4481.38 474.829C4493.71 466.885 4505.68 458.727 4515.9 449.638C4578.52 394.47 4556.81 324.349 4516.94 266.339C4471.95 203.118 4403.3 147.495 4317.84 104.11C4228.91 60.1187 4123.93 31.2149 4010.25 28.2302C3886.09 25.7128 3775.3 63.9327 3667.5 98.1071C3627.51 110.787 3587.47 123.391 3547.15 135.645C3501.71 149.428 3455.95 162.793 3409.85 175.671C3133.07 252.978 2844.9 313.097 2553.85 364.842C2489.48 376.267 2424.86 387.095 2360.13 397.653C2315.58 404.738 2270.32 409.453 2224.74 412.976C2224.77 412.976 2224.78 412.98 2224.8 412.984H2224.82ZM1069.64 281.078C1069.73 369.784 1247.16 388.972 1354.21 397.139C1568.58 412.98 1785.28 422.928 2001.18 420.836C2072.86 420.141 2144.66 418.019 2215.91 412.82C2112.37 399.93 2009.34 385.529 1906.46 370.719C1885.72 367.73 1865 364.733 1844.26 361.731C1717.1 343.305 1589.87 324.896 1461.25 310.92C1331.18 297.016 1200.75 284.509 1070.08 273.1C1069.83 275.748 1069.64 278.413 1069.64 281.086V281.078ZM1065.31 271.833C1067.11 259.2 1070.78 246.907 1074.96 234.514C1082.06 213.6 1093.93 182.381 1044.64 181.83C1016.35 181.274 987.465 193.907 965.041 203.43C928.789 218.825 895.233 236.703 862.05 254.599C882.256 256.325 902.477 258.008 922.69 259.701C970.241 263.679 1017.79 267.691 1065.31 271.82V271.829V271.833Z" fill="url(#paint37_linear_1779_1730)" style=""/>\n<path d="M4605.43 354.508C4604.71 388.522 4589.47 421.341 4556.24 448.46C4545.19 457.578 4532.55 465.757 4519.43 473.68C4421.86 531.416 4281.9 551.564 4153 560.173C4083.63 564.492 4010.76 556.742 3942.19 550.911C3849.12 542.997 3756.5 532.982 3664.13 522.302C3623.53 517.591 3583 512.658 3542.46 507.715C3421.76 492.994 3300.96 478.521 3178.88 469.138C3090.56 462.541 3001.87 459.039 2913.12 455.818C2874.33 454.412 2835.55 452.972 2796.79 451.28C2768.7 450.055 2740.58 449.062 2712.46 448.102C2631.3 445.336 2550.57 441.602 2470.21 433.667C2412 427.79 2353.91 421.467 2295.91 414.778C2166.34 426.237 2034.57 427.087 1903.99 425.281C1730.04 422.625 1556.23 414.05 1383.48 400.999C1267.19 391.936 1084.34 369.136 1099.65 272.204C1053.81 267.876 1007.96 263.628 962.098 259.394C941.039 257.453 919.973 255.516 898.921 253.542C887.855 259.549 876.836 265.59 865.818 271.635C860.225 274.696 857.429 276.224 851.836 279.28C845.431 282.787 839.039 286.306 832.654 289.83C819.472 297.112 806.249 304.37 792.866 311.505C699.222 360.936 592.063 406.089 466.9 411.461C430.541 412.45 395.147 410.135 359.854 404.531C361.292 404.329 362.004 404.233 363.442 404.03C397.205 409.398 431.06 411.68 465.848 410.741C589.652 405.39 695.714 360.161 788.286 311.295C801.688 304.172 814.884 296.91 828.073 289.628C834.458 286.1 840.85 282.581 847.255 279.07C852.848 276.009 855.644 274.481 861.237 271.425C872.402 265.317 883.581 259.217 894.773 253.134C879.293 251.681 863.813 250.221 848.367 248.65C849.432 248.406 849.965 248.28 851.03 248.036C866.03 249.551 881.051 250.974 896.078 252.393C932.077 232.94 968.23 213.104 1007.86 196.618C1030.44 187.235 1057.4 176.82 1085.48 177.422C1103.49 177.831 1121.4 181.455 1125.34 193.802C1129.32 206.28 1121.5 220.584 1116.78 232.548C1111.73 245.539 1107.09 258.488 1104.59 271.787C1230.67 283.721 1356.57 296.367 1482.22 309.977C1610.07 323.991 1736.96 341.188 1863.82 358.359C1887.72 361.592 1911.61 364.826 1935.52 368.05C2055.49 384.178 2175.62 399.859 2296.26 413.885C2332.2 410.581 2367.97 406.518 2403.13 400.717C2468.47 389.903 2533.68 378.781 2598.65 367.103C2891.51 314.284 3181.32 252.65 3458.97 173.12C3505.39 159.826 3551.44 146.018 3597.15 131.785C3636.8 119.408 3676.18 106.691 3715.52 93.9143C3826.21 57.9466 3939.6 18.1607 4067.84 20.6739C4183.37 23.6165 4291.81 52.8066 4381.25 98.4818C4466.35 142.461 4535.66 199.393 4575.59 264.399C4592.89 293.172 4605.66 323.528 4605.48 354.524C4605.45 354.512 4605.45 354.508 4605.42 354.495L4605.43 354.508ZM2300.48 414.353C2357.86 420.966 2415.33 427.222 2472.93 433.031C2552.75 440.916 2632.96 444.616 2713.56 447.361C2741.79 448.329 2770.02 449.327 2798.23 450.556C2836.9 452.248 2875.6 453.68 2914.3 455.094C3003.38 458.327 3092.41 461.859 3181.06 468.468C3303.42 477.877 3424.51 492.371 3545.49 507.13C3585.99 512.068 3626.51 516.998 3667.09 521.704C3754.33 531.795 3841.81 541.195 3929.66 548.899C4001.41 555.192 4078.54 564.117 4151.2 559.478C4278.58 550.953 4418.45 530.545 4514.84 473.486C4527.95 465.589 4540.56 457.418 4551.6 448.321C4617.73 394.218 4607.21 324.909 4570.84 264.454C4491.91 136.096 4290.86 25.8392 4067.3 21.4022C3941.13 18.9311 3828.82 58.8643 3719.98 94.2258C3680.64 107.002 3641.26 119.724 3601.61 132.105C3555.87 146.355 3509.81 160.167 3463.37 173.469C3185.55 253.054 2895.55 314.722 2602.5 367.574C2537.49 379.277 2472.23 390.395 2406.85 401.21C2371.82 406.859 2336.36 411.031 2300.6 414.361C2300.56 414.361 2300.53 414.357 2300.48 414.353ZM1103.49 285.001C1103.58 372.731 1279.97 392.071 1385.7 400.318C1557.9 413.334 1731.14 421.875 1904.53 424.528C2033.57 426.321 2163.75 425.492 2291.82 414.281C2171.61 400.288 2051.92 384.67 1932.38 368.593C1908.47 365.373 1884.56 362.144 1860.66 358.907C1733.94 341.765 1607.21 324.577 1479.5 310.575C1354.74 297.062 1229.72 284.504 1104.53 272.641C1103.87 276.725 1103.51 280.892 1103.54 284.997C1103.51 284.997 1103.5 285.001 1103.48 285.005L1103.49 285.001ZM1099.84 271.332C1102.39 258.181 1106.94 245.35 1111.97 232.498C1120.08 211.916 1135.18 178.824 1084.68 178.146C1056.46 177.498 1028.04 190.148 1005.9 199.683C968.743 215.684 934.454 234.321 900.346 252.784C921.771 254.788 943.203 256.762 964.635 258.741C1009.71 262.892 1054.78 267.072 1099.83 271.324V271.332H1099.84Z" fill="url(#paint38_linear_1779_1730)" style=""/>\n<path d="M4650.92 340.047C4650.93 379.025 4631.11 416.916 4591.83 447.146C4579.97 456.26 4566.66 464.469 4552.8 472.35C4450.28 529.362 4307.56 549.4 4175.46 558.211C4106.52 562.522 4034.48 555.837 3966.11 550.747C3874.43 543.923 3783.12 535.129 3692.04 525.704C3646.31 520.947 3600.64 515.945 3554.98 510.94C3442.68 498.614 3330.31 486.473 3217.25 477.199C3131.52 470.304 3045.48 465.244 2959.42 460.297C2917.2 457.868 2874.99 455.431 2832.81 452.783C2805.56 451.078 2778.29 449.483 2751.01 447.917C2667.86 443.122 2584.89 437.851 2502.39 429.579C2458.68 425.13 2415.02 420.511 2371.41 415.729C2230.44 430.606 2085.86 431.398 1943.35 429.36C1766.74 426.595 1590.26 417.792 1414.93 404.186C1333.65 397.745 1234.26 388.248 1172.55 350.412C1138.29 329.401 1127.75 301.129 1133.88 271.867C1096.51 268.061 1059.14 264.285 1021.76 260.505C993.524 257.651 965.281 254.805 937.051 251.921C932.411 254.456 927.71 257.007 923.003 259.558C911.977 265.552 900.939 271.534 889.9 277.521C888.788 278.135 888.229 278.438 887.117 279.053C867.762 289.581 848.374 300.076 828.64 310.323C729.983 361.134 617.603 407.2 487.207 412.715C449.556 413.759 412.771 411.414 376.199 405.643C377.637 405.441 378.35 405.344 379.788 405.142C414.842 410.661 449.989 412.968 486.089 411.995C614.148 407.402 727.246 359.576 823.933 310.112C843.687 299.887 863.081 289.396 882.403 278.851C883.515 278.236 884.074 277.933 885.186 277.318C896.245 271.349 907.27 265.354 918.289 259.36C923.129 256.746 927.956 254.119 932.77 251.484C914.261 249.581 895.745 247.67 877.27 245.64C878.408 245.4 878.974 245.283 880.113 245.047C898.096 247.025 916.112 248.882 934.128 250.738C970.82 230.902 1007.49 210.561 1047.63 193.507C1070.1 183.964 1097.23 173.082 1125.45 173.76C1143.72 174.214 1161.4 178.087 1164.59 190.704C1167.87 203.687 1159.03 218.303 1153.54 230.574C1147.56 244.095 1142 257.575 1138.69 271.475C1259.34 283.768 1379.89 296.452 1500.29 309.666C1629.06 323.907 1757.24 340.157 1885.42 356.364C1910.68 359.563 1935.95 362.746 1961.22 365.928C2097.7 382.99 2234.28 399.711 2371.33 414.828C2397.62 411.945 2423.8 408.636 2449.6 404.3C2515.6 393.233 2581.42 381.77 2647.05 369.865C2942.13 315.694 3234.13 252.54 3513.12 170.682C3559.58 157.051 3605.65 142.886 3651.36 128.266C3690.3 115.784 3729 103.003 3767.64 90.134C3879.4 52.9413 3994.33 11.4041 4124.66 13.8584C4350.17 18.1481 4558.73 129.52 4629.33 262.547C4642.33 287.822 4650.39 313.463 4650.91 340.089V340.051L4650.92 340.047ZM2375.61 415.254C2418.72 419.977 2461.86 424.544 2505.05 428.944C2587.24 437.182 2669.91 442.427 2752.74 447.205C2780.05 448.784 2807.36 450.375 2834.66 452.084C2876.78 454.732 2918.92 457.174 2961.07 459.59C3047.35 464.545 3133.6 469.613 3219.55 476.53C3332.79 485.812 3445.33 497.97 3557.82 510.317C3603.45 515.322 3649.07 520.328 3694.76 525.072C3796.65 535.592 3898.81 545.514 4001.49 552.469C4057.87 556.287 4116.87 561.099 4173.62 557.512C4304.81 548.756 4446.37 528.76 4548.15 472.135C4562.02 464.28 4575.29 456.088 4587.14 446.991C4656.11 394.352 4656.75 324.892 4624.57 262.555C4589.24 195.949 4520.34 137.918 4435.42 93.245C4346.65 47.7886 4239.31 17.3735 4124.19 14.5404C3995.95 12.124 3882.07 53.8253 3772.17 90.3908C3733.51 103.247 3694.79 116.045 3655.83 128.543C3610.09 143.168 3564 157.346 3517.5 170.986C3238.34 252.89 2946.16 316.086 2650.9 370.29C2585.23 382.207 2519.37 393.683 2453.33 404.755C2427.73 409.057 2401.76 412.366 2375.68 415.245C2375.65 415.245 2375.65 415.249 2375.62 415.254H2375.61ZM1136.85 288.84C1136.95 375.737 1312.49 395.199 1417.09 403.496C1591.85 417.06 1767.74 425.841 1943.78 428.594C2084.74 430.611 2227.73 429.844 2367.2 415.237C2230.52 400.153 2094.31 383.483 1958.21 366.459C1932.93 363.272 1907.67 360.085 1882.39 356.894C1754.3 340.7 1626.21 324.45 1497.52 310.226C1378.01 297.108 1258.34 284.525 1138.58 272.309C1137.61 277.857 1137 283.254 1136.78 288.832C1136.81 288.832 1136.82 288.836 1136.84 288.84H1136.85ZM1134.06 270.966C1137.41 257.217 1142.88 243.872 1148.85 230.498C1158.04 209.875 1176.2 175.717 1124.65 174.463C1096.06 173.739 1067.1 187.176 1044.92 196.955C1007.57 213.432 973.011 232.426 938.463 251.147C967.105 254.077 995.754 256.965 1024.41 259.861C1060.96 263.553 1097.51 267.249 1134.05 270.97L1134.06 270.966Z" fill="url(#paint39_linear_1779_1730)" style=""/>\n<path d="M4698.19 325.848C4698.2 370.546 4673.18 411.903 4627.4 445.837C4614.53 454.879 4600.8 463.147 4586.12 471.007C4478.79 527.312 4333.19 547.215 4197.91 556.232C4141.05 559.853 4082.35 555.992 4025.7 552.772C3923.44 546.962 3821.59 538.282 3719.98 529.075C3658.09 523.43 3596.29 517.41 3534.48 511.39C3441.64 502.344 3348.79 493.365 3255.73 485.236C3178.62 478.559 3101.38 472.531 3024.12 466.528C2972.38 462.507 2920.64 458.466 2868.93 454.256C2845.22 452.328 2821.5 450.43 2797.77 448.54C2709.91 441.518 2622.08 434.336 2534.62 425.454C2505.04 422.406 2475.46 419.316 2445.89 416.18C2294.27 435.106 2136.76 435.62 1982.86 433.347C1803.55 430.459 1624.38 421.383 1446.41 407.322C1365.04 400.726 1264.58 390.959 1203.82 352.167C1169.63 330.34 1160.82 301.208 1168.33 271.652C1166.66 271.471 1164.98 271.294 1163.38 271.105C1100.5 264.235 1037.62 257.402 974.781 250.385C973.915 250.865 972.99 251.349 972.117 251.829C957.43 259.802 942.743 267.775 928.002 275.706C907.003 286.984 885.91 298.186 864.392 309.068C760.661 361.1 642.935 408.249 507.366 413.89C468.45 414.963 430.407 412.593 392.59 406.67C394.001 406.468 394.707 406.367 396.119 406.169C432.404 411.861 468.903 414.197 506.261 413.174C639.5 408.497 758.051 359.53 859.758 308.849C881.276 297.98 902.376 286.773 923.368 275.5C938.129 267.586 952.816 259.617 967.484 251.631C968.536 251.054 969.587 250.486 970.639 249.922C949.274 247.526 927.915 245.127 906.597 242.567C907.782 242.332 908.381 242.214 909.566 241.982C930.372 244.466 951.211 246.819 972.058 249.155C1009.77 228.684 1047.29 207.547 1088.39 189.794C1110.54 180.23 1137.72 169.116 1165.79 170.034C1184.25 170.548 1201.89 174.677 1204.33 187.521C1206.9 200.975 1197.06 215.975 1190.85 228.52C1183.83 242.605 1177.41 256.729 1173.34 271.286C1288.52 283.869 1403.68 296.489 1518.79 309.287C1632.35 321.962 1745.7 335.332 1859.06 348.685C1901.77 353.716 1944.48 358.747 1987.19 363.752C2139.84 381.551 2292.61 398.97 2445.69 415.254C2462.7 413.043 2479.58 410.593 2496.37 407.815C2563.02 396.495 2629.49 384.758 2695.74 372.555C2993.17 317.332 3287.23 252.515 3567.44 168.241C3613.99 154.244 3660.12 139.695 3705.87 124.691C3744.09 112.134 3782.06 99.2859 3819.97 86.3579C3932.81 47.9443 4049.33 4.57598 4181.77 6.9713C4299.35 9.76654 4408.96 40.691 4499.06 87.625C4583.61 132.871 4652.84 192.674 4683.28 260.623C4692.83 281.92 4697.85 303.717 4698.31 325.848H4698.19ZM2449.68 415.7C2478.85 418.79 2508.04 421.842 2537.23 424.847C2624.55 433.722 2712.23 440.878 2799.96 447.883C2823.7 449.777 2847.44 451.676 2871.18 453.612C2922.86 457.826 2974.57 461.855 3026.29 465.875C3103.6 471.887 3180.9 477.919 3258.08 484.6C3351.22 492.72 3444.16 501.717 3537.08 510.776C3598.85 516.796 3660.61 522.816 3722.46 528.452C3823.06 537.566 3923.89 546.108 4025.13 551.9C4081.3 555.117 4139.66 559.145 4196.06 555.563C4330.45 546.6 4474.88 526.731 4581.49 470.809C4596.16 462.97 4609.87 454.728 4622.7 445.694C4693.45 393.346 4707.49 325.726 4678.38 260.69C4648.02 192.8 4578.82 133.052 4494.37 87.8439C4405.42 41.5161 4297.32 10.4906 4181.15 7.72063C4050.79 5.3632 3935.31 48.8957 3824.32 86.6694C3786.38 99.6016 3748.39 112.445 3710.15 125.011C3664.37 140.032 3618.21 154.585 3571.64 168.594C3291.23 252.927 2996.97 317.778 2699.34 373.034C2633.04 385.255 2566.54 396.996 2499.85 408.32C2483.24 411.073 2466.55 413.511 2449.73 415.704C2449.7 415.704 2449.7 415.7 2449.67 415.696L2449.68 415.7ZM1170.26 292.322C1170.42 378.537 1344.67 398.246 1448.51 406.674C1625.92 420.688 1804.51 429.739 1983.25 432.623C2135.63 434.871 2291.49 434.374 2441.63 415.75C2288.88 399.497 2136.44 382.123 1984.12 364.346C1941.37 359.34 1898.64 354.31 1855.91 349.279C1742.58 335.926 1629.25 322.564 1515.73 309.897C1401.5 297.192 1287.21 284.673 1172.92 272.191C1171.42 278.918 1170.5 285.544 1170.26 292.334V292.326V292.322ZM1168.46 270.785C1172.61 256.384 1179.02 242.445 1185.91 228.486C1195.94 208.216 1217.42 172.19 1164.69 170.783C1135.66 169.979 1106.09 184.137 1083.82 194.173C1046.11 211.171 1011.16 230.578 976.086 249.648C1039.4 256.725 1102.76 263.607 1166.11 270.528C1166.92 270.612 1167.72 270.701 1168.52 270.793C1168.49 270.793 1168.48 270.789 1168.46 270.785Z" fill="url(#paint40_linear_1779_1730)" style=""/>\n<path d="M4746.88 311.463C4745.88 361.42 4716.77 407.891 4662.98 444.511C4552.24 520.003 4375.59 543.931 4220.44 554.258C4151.87 558.665 4080.87 553.896 4012.49 550.271C3793.12 538.644 3574.68 518.968 3356.87 499.056C3093.07 474.939 2829.77 448.582 2566.74 421.341C2550.56 419.665 2534.4 417.986 2518.23 416.302C2455 425.546 2390.17 430.37 2325.54 433.536C2186.33 440.352 2046.14 439.047 1906.79 434.664C1763.4 430.156 1620.26 421.938 1477.84 410.488C1396.45 403.748 1294.91 393.687 1235.11 354.032C1201 331.417 1193.79 301.486 1202.56 271.656C1138.99 264.251 1075.45 256.779 1011.98 249.063C975.207 269.088 938.188 288.912 899.985 307.839C792.233 360.59 667.49 410.202 527.613 415.089C487.339 416.222 447.957 413.835 408.809 407.726C410.22 407.524 410.926 407.428 412.337 407.226C449.981 413.077 487.838 415.439 526.561 414.369C665.506 408.589 788.232 360.405 895.405 307.62C933.781 288.6 970.959 268.676 1007.9 248.558C983.762 245.615 959.634 242.656 935.565 239.524C936.83 239.296 937.456 239.183 938.721 238.955C962.237 242.007 985.813 244.904 1009.38 247.783C1011.37 246.705 1013.34 245.628 1015.32 244.558C1051.27 224.979 1086.92 204.764 1125.86 187.538C1148.71 177.426 1176.7 165.542 1205.9 166.334C1224.67 166.902 1242.03 171.305 1243.79 184.381C1245.67 198.332 1234.89 213.626 1227.94 226.49C1220.04 241.245 1212.58 256.005 1207.64 271.29C1532.28 309.089 1857.46 345.052 2182.92 379.938C2294.53 391.902 2406.17 403.706 2517.87 415.342C2526.25 414.075 2534.6 412.744 2542.93 411.343C2900.01 349.915 3254.31 277.049 3588.7 175.936C3646.49 158.462 3703.61 140.128 3760.17 121.109C3797.6 108.497 3834.81 95.6149 3871.97 82.6743C3985.91 43.0062 4104.08 -2.23965 4238.71 0.100945C4357.36 2.8162 4467.8 34.3974 4558.1 82.1817C4642.6 128.135 4711.67 189.281 4737.11 258.716C4743.2 276.148 4746.68 293.585 4747.01 311.442C4746.96 311.451 4746.93 311.455 4746.89 311.463H4746.88ZM2521.69 415.792C2537.57 417.447 2553.45 419.093 2569.33 420.734C2915.82 456.618 3262.74 491.457 3610.83 520.61C3775.42 534.392 3940.96 548.373 4106.91 553.631C4143.89 554.801 4181.54 555.95 4218.47 553.576C4372.75 543.304 4548.11 519.401 4658.21 444.347C4733.2 393.481 4755.52 325.907 4732.09 258.766C4706.65 189.399 4637.72 128.303 4553.27 82.3964C4464.08 35.2141 4355.24 3.54869 4237.95 0.846062C4105.42 -1.46085 3988.26 43.9703 3876.16 82.9942C3839 95.9348 3801.8 108.821 3764.35 121.437C3707.77 140.465 3650.61 158.811 3592.78 176.294C3258.17 277.47 2903.63 350.378 2546.32 411.852C2538.13 413.224 2529.93 414.529 2521.69 415.784V415.792H2521.69ZM1203.54 295.685C1203.19 380.991 1376.79 401.29 1480.01 409.848C1757.31 432.139 2041.8 446.38 2321.14 432.985C2385.85 429.882 2450.76 425.104 2514.07 415.889C2403.6 404.38 2293.16 392.702 2182.76 380.873C1857.21 345.983 1531.92 310.019 1207.18 272.212C1205.12 280.004 1203.56 287.8 1203.53 295.685H1203.54ZM1202.74 270.776C1207.71 255.668 1215.09 241.06 1222.91 226.461C1233.65 206.545 1258.58 168.649 1204.65 167.087C1176.34 166.409 1148.23 179.695 1126.47 189.55C1089.1 206.469 1054.55 225.842 1019.77 244.79C1017.6 245.952 1015.5 247.135 1013.27 248.318C1076.35 255.996 1139.5 263.422 1202.68 270.776H1202.74Z" fill="url(#paint41_linear_1779_1730)" style=""/>\n</g>\n</g>\n<defs>\n<linearGradient id="paint0_linear_1779_1730" x1="-596.991" y1="398.264" x2="3328.71" y2="398.264" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint1_linear_1779_1730" x1="-558.94" y1="401.337" x2="3355.61" y2="401.337" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint2_linear_1779_1730" x1="-520.999" y1="404.429" x2="3382.1" y2="404.429" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint3_linear_1779_1730" x1="-483.122" y1="407.535" x2="3409.76" y2="407.535" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint4_linear_1779_1730" x1="-445.216" y1="410.592" x2="3437.36" y2="410.592" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint5_linear_1779_1730" x1="-407.136" y1="413.629" x2="3465.48" y2="413.629" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint6_linear_1779_1730" x1="-369.37" y1="416.735" x2="3493.49" y2="416.735" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint7_linear_1779_1730" x1="-331.896" y1="419.788" x2="3521.7" y2="419.788" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint8_linear_1779_1730" x1="-294.06" y1="421.855" x2="3550.41" y2="421.855" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint9_linear_1779_1730" x1="-256.513" y1="417.619" x2="3579.3" y2="417.619" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint10_linear_1779_1730" x1="-218.534" y1="413.282" x2="3608.44" y2="413.282" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint11_linear_1779_1730" x1="-181.118" y1="408.96" x2="3638.08" y2="408.96" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint12_linear_1779_1730" x1="-144.167" y1="404.61" x2="3668.11" y2="404.61" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint13_linear_1779_1730" x1="-107.009" y1="400.258" x2="3698.18" y2="400.258" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint14_linear_1779_1730" x1="-70.0247" y1="395.899" x2="3728.62" y2="395.899" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint15_linear_1779_1730" x1="-34.7767" y1="391.536" x2="3759.61" y2="391.536" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint16_linear_1779_1730" x1="1.44208" y1="387.181" x2="3790.69" y2="387.181" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint17_linear_1779_1730" x1="17.8874" y1="382.805" x2="3822.43" y2="382.805" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint18_linear_1779_1730" x1="34.1609" y1="378.429" x2="3854.35" y2="378.429" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint19_linear_1779_1730" x1="50.5457" y1="374.051" x2="3886.84" y2="374.051" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint20_linear_1779_1730" x1="66.6512" y1="369.678" x2="3919.71" y2="369.678" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint21_linear_1779_1730" x1="83.0243" y1="365.29" x2="3953.48" y2="365.29" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint22_linear_1779_1730" x1="99.4736" y1="360.913" x2="3988.2" y2="360.913" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint23_linear_1779_1730" x1="115.534" y1="356.492" x2="4023.15" y2="356.492" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint24_linear_1779_1730" x1="131.788" y1="352.117" x2="4058.46" y2="352.117" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint25_linear_1779_1730" x1="148.157" y1="347.759" x2="4094.2" y2="347.759" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint26_linear_1779_1730" x1="164.579" y1="343.338" x2="4130.18" y2="343.338" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint27_linear_1779_1730" x1="180.698" y1="338.95" x2="4166.54" y2="338.95" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint28_linear_1779_1730" x1="197.32" y1="334.537" x2="4203.62" y2="334.537" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint29_linear_1779_1730" x1="213.363" y1="330.141" x2="4240.4" y2="330.141" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint30_linear_1779_1730" x1="229.743" y1="325.767" x2="4278.06" y2="325.767" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint31_linear_1779_1730" x1="245.958" y1="321.491" x2="4316.14" y2="321.491" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint32_linear_1779_1730" x1="262.412" y1="317.092" x2="4355.45" y2="317.092" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint33_linear_1779_1730" x1="278.503" y1="312.748" x2="4394.4" y2="312.748" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint34_linear_1779_1730" x1="294.962" y1="308.266" x2="4434.82" y2="308.266" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint35_linear_1779_1730" x1="311.044" y1="303.902" x2="4475.45" y2="303.902" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint36_linear_1779_1730" x1="327.404" y1="299.665" x2="4517.85" y2="299.665" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint37_linear_1779_1730" x1="343.591" y1="295.329" x2="4560.78" y2="295.329" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint38_linear_1779_1730" x1="359.863" y1="290.979" x2="4605.5" y2="290.979" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint39_linear_1779_1730" x1="376.209" y1="286.659" x2="4650.94" y2="286.659" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint40_linear_1779_1730" x1="392.599" y1="282.269" x2="4698.33" y2="282.269" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<linearGradient id="paint41_linear_1779_1730" x1="408.818" y1="278.005" x2="4747.02" y2="278.005" gradientUnits="userSpaceOnUse">\n<stop stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.02" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.06" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.11" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.15" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n<stop offset="0.3" stop-color="white" style="stop-color:white;stop-opacity:1;"/>\n<stop offset="0.47" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4977 0.6339 0.7646);stop-opacity:1;"/>\n<stop offset="0.64" stop-color="#6E90BD" style="stop-color:#6E90BD;stop-color:color(display-p3 0.4300 0.5628 0.7399);stop-opacity:1;"/>\n<stop offset="0.79" stop-color="#7FA2C3" style="stop-color:#7FA2C3;stop-color:color(display-p3 0.4980 0.6353 0.7647);stop-opacity:1;"/>\n<stop offset="1" stop-color="#2B435D" style="stop-color:#2B435D;stop-color:color(display-p3 0.1686 0.2627 0.3647);stop-opacity:1;"/>\n</linearGradient>\n<clipPath id="clip0_1779_1730">\n<rect width="4320" height="323" fill="white" style="fill:white;fill-opacity:1;"/>\n</clipPath>\n</defs>\n</svg>\n';

  // src/WaveAnimAlt.ts
  var WaveAnimAlt = class {
    container;
    isAnimating = false;
    waveCtn;
    constructor() {
      this.container = document.querySelector(".bottom-wave-box");
      this.container.innerHTML = "";
      this.container.style.opacity = "1";
      this.waveCtn = document.createElement("div");
      this.waveCtn.style.opacity = "0";
      this.waveCtn.style.width = "100%";
      this.waveCtn.style.position = "relative";
      this.waveCtn.style.top = "5px";
      this.container.append(this.waveCtn);
      const waveDiv = document.createElement("div");
      waveDiv.style.width = "100%";
      waveDiv.innerHTML = wave_default;
      this.waveCtn.append(waveDiv);
      const prevWave = document.createElement("div");
      prevWave.style.width = "100%";
      prevWave.style.height = "100%";
      prevWave.style.scale = "-1 1";
      prevWave.style.position = "absolute";
      prevWave.style.top = "0";
      prevWave.style.left = "-100%";
      prevWave.innerHTML = wave_default;
      this.waveCtn.append(prevWave);
      const prevWave2 = document.createElement("div");
      prevWave2.style.width = "100%";
      prevWave2.style.height = "100%";
      prevWave2.style.position = "absolute";
      prevWave2.style.top = "0";
      prevWave2.style.left = "-200%";
      prevWave2.innerHTML = wave_default;
      this.waveCtn.append(prevWave2);
      const nextWave = document.createElement("div");
      nextWave.style.width = "100%";
      nextWave.style.height = "100%";
      nextWave.style.scale = "-1 1";
      nextWave.style.position = "absolute";
      nextWave.style.top = "0";
      nextWave.style.left = "100%";
      nextWave.innerHTML = wave_default;
      this.waveCtn.append(nextWave);
      const nextWave2 = document.createElement("div");
      nextWave2.style.width = "100%";
      nextWave2.style.height = "100%";
      nextWave2.style.position = "absolute";
      nextWave2.style.top = "0";
      nextWave2.style.left = "200%";
      nextWave2.innerHTML = wave_default;
      this.waveCtn.append(nextWave2);
    }
    scrolling(dir) {
      if (this.isAnimating) {
        return;
      }
      this.isAnimating = true;
      const x = dir === 1 /* RIGHT */ ? "-200vw" : "200vw";
      gsap.to(this.waveCtn, {
        x,
        duration: ScrollSnap.SCROLL_DUR,
        ease: ScrollSnap.SCROLL_EASE_BETWEEN_SECTIONS,
        onComplete: () => {
          gsap.set(this.waveCtn, { x: 0 });
          this.isAnimating = false;
        }
      });
    }
    onPreloaderComplete() {
      gsap.to(this.waveCtn, { opacity: 1, duration: 0.5, ease: "linear" });
    }
  };

  // src/index.js
  var Main = class {
    isMobile;
    scrollSections;
    scrollSnap;
    mobilePinning;
    preloader;
    carousels;
    animations;
    modals;
    mql;
    nav;
    waveAnim;
    waveAnimAlt;
    preloaderComplete = false;
    constructor() {
      this.scrollSections = document.querySelectorAll(".section");
      this.scrollSnap = new ScrollSnap(this.scrollSections);
      this.mobilePinning = new MobilePinning();
      this.preloader = new Preloader();
      this.carousels = new Carousels();
      this.animations = new Sections();
      this.modals = new Modals();
      this.nav = new Nav();
      this.waveAnim = new WaveAnim();
      this.waveAnimAlt = new WaveAnimAlt();
      document.body.style.overflow = "hidden";
      this.initBreakpointListener();
      if (!this.isMobile) {
        gsap.set($("[data-animation]").not(".nav"), { visibility: "hidden" });
      }
      window.addEventListener("preloader_complete", this.onPreloaderComplete.bind(this));
      window.addEventListener("go_to_section", this.onScrollToSection.bind(this));
      window.addEventListener("scrolling", this.onScrolling.bind(this));
      window.addEventListener("modal_open", this.onModalOpen.bind(this));
      window.addEventListener("modal_closed", this.onModalClosed.bind(this));
      window.addEventListener("clicked_nav", this.onClickedNav.bind(this));
      this.preloader.start();
      this.animations.init();
      this.nav.deepLink();
    }
    initBreakpointListener() {
      this.mql = window.matchMedia("(min-width: 992px)");
      this.mql.addEventListener("change", this.onChangeBreakpoint.bind(this));
      this.onChangeBreakpoint(this.mql);
    }
    onModalOpen() {
      if (this.isMobile) {
        this.mobilePinning.kill();
      } else {
        this.scrollSnap.paused = true;
      }
    }
    onModalClosed() {
      if (this.isMobile) {
        this.mobilePinning.start();
      } else {
        this.scrollSnap.paused = false;
      }
    }
    onClickedNav(e) {
      const sectionId = e.detail;
      if (!this.isMobile) {
        const section = document.querySelector(`[data-section=${sectionId}]`).querySelectorAll(".section")[0];
        const sectionIdx = [...this.scrollSections].findIndex((s) => s === section);
        this.scrollSnap.gotoIdx(sectionIdx, true);
      }
    }
    onPreloaderComplete() {
      this.preloaderComplete = true;
      document.body.style.overflow = "";
      this.waveAnim.onPreloaderComplete();
      this.waveAnimAlt.onPreloaderComplete();
      this.onChangeBreakpoint(this.mql);
    }
    onScrollToSection(e) {
      const currentSection = this.scrollSections[e.detail];
      const parentSection = currentSection.closest(".section_part").dataset.section;
      this.nav.currentSection = parentSection;
      window.history.replaceState(
        {},
        "",
        `${document.location.origin}#${parentSection === "none" ? "top" : parentSection}`
      );
    }
    onChangeBreakpoint(e) {
      this.isMobile = !e.matches;
      this.preloader.isMobile = this.isMobile;
      this.animations.isMobile = this.isMobile;
      this.nav.isMobile = this.isMobile;
      this.waveAnim.isMobile = this.isMobile;
      if (this.isMobile) {
        gsap.set($("[data-animation]").not(".nav"), { visibility: "visible" });
      }
      if (!this.preloaderComplete) {
        return;
      }
      if (this.isMobile) {
        this.scrollSnap.kill();
        this.mobilePinning.start();
      } else {
        this.mobilePinning.kill();
        this.scrollSnap.start();
      }
    }
    onScrolling(e) {
      this.waveAnimAlt.scrolling(e.detail);
    }
  };
  (function() {
    if (document.readyState !== "loading") {
      init();
    } else {
      document.addEventListener("DOMContentLoaded", init);
    }
    function init() {
      new Main();
    }
  })();
})();
/*! Bundled license information:

three/build/three.core.js:
  (**
   * @license
   * Copyright 2010-2025 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)

three/build/three.module.js:
  (**
   * @license
   * Copyright 2010-2025 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)
*/
//# sourceMappingURL=index.js.map
